---
title: 代码练习 | 数组（二分查找）
tags: [leetcode]
date: 2024-03-29 16:31:04
categories: technique
urlname: 29
mathjax: true
---

## 二分查找


### 704. 二分查找

leetcode链接：[二分查找][1]


给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1

提示：

你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。


思路：
考虑在闭区间[left, right]查找与target值相同的元素，left初始值为0，right初始值为len(nums) -1，由于left = right时区间是有意义的，因此考虑循环条件为left <= right。当middle位置元素大于target，则说明目标元素可能在[left, middle-1]，right更新。当middle位置元素小于target，则说明目标元素可能在[middle + 1, right]，当middle位置元素等于target，直接返回middle。循环结束则不存在目标值，返回-1。



核心代码实现：

```
func search(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    for (left <= right){
        middle := left + ((right - left) / 2)
        if(target < nums[middle]){
            right = middle - 1    
        }
        if(target > nums[middle]){ 
            left = middle + 1    
        }
        if target == nums[middle]{
            return middle
        } 
    }
    return -1
}

```

### 35. 搜索插入位置

leetcode链接：[搜索插入位置][2]

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法

示例 1:
输入: nums = [1,3,5,6], target = 5
输出: 2

示例 2:
输入: nums = [1,3,5,6], target = 2
输出: 1

示例 3:
输入: nums = [1,3,5,6], target = 7
输出: 4

提示:

1 <= nums.length <= $10^4$
$-10^4$ <= nums[i] <= $10^4$
nums 为 无重复元素 的 升序 排列数组
$-10^4$ <= target <= $10^4$

思路：当遇到排序数组时，就可以考虑二分查找。由题意知“nums为**无重复元素**的**升序**数组”，和704思路类似，考虑在闭区间[left, right]查找与target值相同的元素，但是此时若查找不到目标元素需要将“按顺序插入的位置”返回。针对查找不到目标元素这一情景，因为我们考虑的是闭区间[left, right]，循环条件为left <= right，循环结束时，left > right，target值插入位置位于left。

核心代码实现：

```
func searchInsert(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    middle := 0
    for (left <= right){
        middle = left + ((right - left) / 2) 
        if target < nums[middle]{
            right = middle - 1
        }
        if target > nums[middle]  {
            left = middle + 1
        }
        if nums[middle] == target{
            return middle
        }

    }

    return left

}
```


### 34. 在排序数组中查找元素的第一个和最后一个位置

leetcode链接：[在排序数组中查找元素的第一个和最后一个位置][3]

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：

输入：nums = [], target = 0
输出：[-1,-1]


提示：

0 <= nums.length <= $10^5$
$-10^9$ <= nums[i] <= $10^9$
nums 是一个非递减数组
$-10^9$ <= target <= $10^9$

思路：当遇到排序数组时，且要求时间复杂度为O(log n)时，可以考虑二分查找。之后，考虑在闭区间[left, right]查找与target值相同的元素，若元素不存在，则返回 [-1, -1]；若元素存在，由于数组是非递减顺序排列的，因此向左查找目标值起始位置，向右查找结束位置。



```

func searchRange(nums []int, target int) []int {
    head := 0
    tail := len(nums) - 1
    left := 0
    right := 0
    for (head <= tail){
        middle := head + ((tail - head) / 2)
        if target < nums[middle]{
            tail = middle - 1
        }
        if target > nums[middle]{
            head = middle + 1
        }
        if target == nums[middle]{
            for i := middle; i >= head; i--{
                if nums[i] == target{
                    left = i
                }
            }
            for j := middle; j <= tail; j++{
                if nums[j] == target{
                    right = j
                }
            }
            return []int{left, right}
        }
    }
    return []int{-1, -1}
}

```


### 69. x的平方根

leetcode链接：[x的平方根][4]

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。


示例 1：

输入：x = 4
输出：2
示例 2：

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。

提示：

0 <= x <= $2^{31}$ - 1

思路：一个非负整数的算术平方根一定小于等于它本身。不使用任何内置函数和算符，则可以通过查找 [0,1,...,x] 内的元素，计算元素的平方是否和 x 值相同，由于x的算术平方根只保留整数结果，当元素平方不和 x 相同时，相当于找插入位置前一元素。这符合二分查找的场景，同35类似。

```
func mySqrt(x int) int {
    left := 0
    right := x
    for (left <= right){
        middle := left + ((right - left) / 2)
        if middle*middle < x{
            left = middle + 1
        }
        if middle*middle > x{
            right = middle - 1
        }
        if middle*middle == x{
            return middle
        }
    }
    return right
}

```


### 367. 有效的完全平方数

leetcode链接：[有效的完全平方数][5]

给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如  sqrt 。

示例 1：

输入：num = 16
输出：true
解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
示例 2：

输入：num = 14
输出：false
解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
 

提示：

1 <= num <= $2^{31}$ - 1

思路：查看一个正整数是否为完全平方数，可以在[1,...,num]内查找元素的平方是否与目标值相同。这符合二分查找的场景，和704类似。

```
func isPerfectSquare(num int) bool {
    left := 0
    right := num
    for (left <= right){
        middle := left + ((right - left) / 2)
        if middle * middle < num{
            left = middle + 1
        }
        if middle * middle > num{
            right = middle - 1
        }
        if middle * middle == num{
            return true
        }
    }
    return false
}

```

[1]: https://leetcode.cn/problems/binary-search/description/
[2]: https://leetcode.cn/problems/search-insert-position/description/
[3]: https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/
[4]: https://leetcode.cn/problems/sqrtx/description/
[5]: https://leetcode.cn/problems/valid-perfect-square/description/