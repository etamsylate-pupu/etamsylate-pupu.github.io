---
title: 论文阅读笔记 | 模型水印 When Federated Learning meets Watermarking
date: 2023-12-31 14:28:04
tags: [paper]
categories: academic
urlname: 26
---
### 论文信息

- 发表时间：2023.08
- 论文地址： [https://arxiv.org/pdf/2308.03573][1]

摘要：联邦学习是一种允许多个参与者协作训练深度神经网络而无需集中数据的技术。除其他优点外，它具有隐私保护特性，这使得它在敏感环境中的应用具有吸引力，例如医疗保健或军事。虽然数据没有显式交换，但训练过程需要共享有关参与者模型的信息。这使得单个模型容易被恶意行为者盗窃或未经授权的分发。为了解决机器学习背景下的所有权保护问题，深度神经网络水印方法在过去五年中得到了发展。大多数现有的工作集中在水印的方式，但只有少数方法已被设计为联邦学习及其独特的约束。在本文中，我们概述了联邦学习水印的最新进展，阐明了该领域出现的新挑战和机遇。

*   机器学习
    *   问题
        *   敏感信息可能暴露给未经授权的实体
        *   训练模型的知识产权问题，外部方盗窃、剽窃和未经授权的使用
    *   解决
        *   联邦学习允许多个数据所有共同训练全局模型，无需直接共享他们的私有数据
        *   模型水印嵌入模型中，在非法模型泄露的情况下能够追踪来源
            *   大多数仅解决局部/集中训练的问题
                *   如何识别参与方对联邦学习做出了贡献
                *   如何确保最终模型不会被聚合方滥用
*   联邦学习
    *   框架
        *   中心-服务器
        *   无中心服务器，对等（随机选择客户端作为聚合器）
        *   Split-Learning
            *   在服务器和客户端之间分裂模型，常见的是U型配置：每个客户端有第一层和最后一层，服务器有剩余的层
    *   目的
        *   确保客户端数据的安全性和隐私性，同时实现与集中式训练相当的模型性能
    *   威胁
        *   假设服务器是诚实但好奇的，它将遵循关于客户端选择和全局模型聚合/分发的协议，但尝试推断关于客户端数据的信息
            *   反转攻击
                *   从参与方共享的梯度中重建用户学习的数据
                *   防御方法
                    *   同态加密
                        *   缺点
                            *   高计算和通信复杂度
                            *   只允许对加密数据执行线性运算，限制了聚合的范围
                    *   差分隐私
                        *   缺点
                            *   难以平衡隐私与模型性能
                    *   可信执行环境
                        *   缺点
                        *   *    资源消耗
                    *   安全多方计算
                        *   缺点
                            *   效率低
        *   假设客户端是恶意的，引入恶意数据破坏模型的训练，导致模型错误地将特定模式地数据分类，同时保持其在主要任务上的性能
            *   中毒攻击（后门攻击）
            *   具有鲁棒性的聚合方法
                *   中值聚合
                *   Krum聚合
                *   修剪均值聚合
            *   异常检测
                *   执行模型聚合前过滤掉异常的客户端更新
    *   安全FL环境的建立过程
        *   对参与联邦学习的实体进行安全性分析，并评估他们的可信程度
        *   集成安全方法，确保数据和模型的隐私
* DNN水印
    *   水印需求
        *   机密性
            *   任何分析模型的人无法检测到模型是否带有水印
        *   保真度
            *   保持模型在主要任务上的性能
        *   可靠性
            *   确保模型所有者在IP验证期间的低误报率
        *   完整性
            *   防止其他方的误报
        *   通用性
            *   水印算法应该独立于模型
        *   鲁棒性
            *   从被攻击的模型中重构出正确水印的可能性
        *   容量
            *   嵌入多个水印的能力
        *   效率
            *   水印嵌入和验证过程产生的性能成本
        *   子主题
    *   攻击
        *   修剪攻击（Pruning Attack）
            *   将冗余的模型权重归零，也可以移除冗余的神经元、滤波器或层来修剪模型。
        *   微调（Fine Tuning Attack）
            *   重新训练模型并更新其权重，而不降低精度。
        *   覆盖攻击（Overwriting Attack）
            *   嵌入一个新的水印来替换原来的水印
        *   Wang and Kerschbaum Attack
            *   针对静态白盒水印算法，依赖视觉检查来改变水印模型的权重分布
        *   属性推断攻击（Property Inference Attack）
            *   训练辨别模型以区分带水印模型和不带水印的模型
        *   模糊攻击（Ambiguity Attack）
            *   在模型上伪造一个新的水印，使外部实体难以确定合法的水印所有者
    *   验证过程访问模型参数的类型
        *   白盒
            *   完全访问模型（架构、参数、激活映射）
            *   方法
                *   以二进制字符串或图像的形式，将信息隐藏至模型参数
                *   激活映射
                *   添加护照层（passport layer）
            *   典型方案
                *   目标模型M，加水印版本Mwat，秘密密钥Kext，特征提取函数Ext，投影函数Proj，秘密密钥Kproj，水印b，从水印模型Mwat提取的水印bext
                *   提取模型特征，利用这些特征进行水印插入/提取
                    *   所获得的特征可以是模型权重的子集、从触发集中秘密选择的特定输入数据的模型激活图
                    *   使用特定正则化项Ewat正则化M
                        *   依赖在水印空间定义的距离度量d，距离度量可以是汉明距离、铰链距离或者交叉熵
                        *   确保投影函数在预定的水印空间对水印进行编码
                    *   通过损失函数参数化的微调操作导出带水印模型
                *   例子
                    *   方案1
                        *   特征提取函数涉及计算秘密选择的滤波器权重w的平均值
                        *   使用二进制交叉熵作为水印正则化项Ewat的距离度量d
                    *   方案2
                        *   特征提取函数由批量归一化权重中的缩放参数组成
                        *   铰链损失被用作水印正则化Ewat的距离度量d
        *   黑盒
            *   通过提供输入和接收相关预测与模型交互，只能通过API执行验证过程
            *   方法
                *   通过改变模型的行为对其添加水印
                *   常用技术包括
                    *   使用触发集训练模型
                *   每一个epoch训练期间，一个batch不是仅来自训练集，而是训练集和触发集之间的串联
            *   例子
                *   不同类型的输入
                    *   内容水印：将有意义的内容添加到训练集的图像中。模型应该由内容触发，并返回相关的固定标签。
                    *   不相关水印：与模型的主要任务无关的图像。每个图像都有一个相关的标签，或者每个样本都可以有其特定的输出。
                    *   噪声水印：为训练集中的图像添加特定的噪声。然后，该模型将具有该特定噪声的任何图像分类为预定义的标签。
*   联邦学习模型水印
    *   问题
        *   存在多个参与者
        *   需要考虑参与方交换期间的威胁
        *   在训练完成后对模型进行水印处理，或是开始训练之前嵌入水印，存在模型被窃取以及水印剔除的风险
    *   定义
        *   一个或多个参与者将水印插入共享模型的过程，遵循客户端-服务器框架
        *   服务器
            *   负责给全局模型加水印
        *   客户端
            *   一个或多个客户端对模型更新添加水印，以便为全局模型添加水印
        *   服务器和客户端
            *   服务器和客户端协作，共同为全局模型添加水印
        *   水印需求
            *   容量
                *   避免插入不同客户端信息的冲突，需要足够的比特数
            *   通用性
                *   FL有许多额外的安全和隐私机制（如鲁棒聚合和差分隐私），水印需要独立地应用这些机制
            *   效率
                *   跨设备架构中，客户端的计算能力较低，需要考虑嵌入水印过程产生的成本
            *   保密性
                *   所有参与方未参与注册水印过程，应当没有水印被检测出
            *   鲁棒性
                *   每个参与者需要有唯一的一个水印，能够标识所有者
    *   相关工作
        *   WAFFLE
            *   B,G, Tekgul,et al.“Waffle: Watermarking in federated learning“，SRDS.2021
            *   假设
                *   服务器是一个可信方，使用黑盒水印技术。利用触发集嵌入模型水印
                *   客户端不能够使用后门、投毒或是嵌入自己的水印
                    *   被激励最大限度提高全局模型准确率
                *   对手只能保存模型和应用模型
                *   可以使用不需要客户端数据的触发集，WAFFLEPattern：一组包含随机图案的图像，背景有噪声
                    *   WAFFLEPATTERN更好地保留了模型性能，并降低了通信和计算开销
                    *   弹性的水印去除技术，包括微调，修剪和逆向工程，如果不超过10%的客户端串通击败水印程序。
            *   黑盒水印
                *   预训练
                    *   使用触发集训练初始化的模型，直到该模型在该集合上具有良好的准确率
                *   再训练
                    *   使用触发集微调模型，直到模型学习了水印
                *   PreTrain用于在第一轮之前将水印嵌入到模型中。在每一轮中，在聚合过程之后，服务器使用ReTrain将水印重新嵌入到模型中。
        *   FedIPR
            *   Li B,et al. “FedIPR: Ownership verification for federated deep neural network models”, TPAMI, 2022
            *   既有白盒水印也有黑盒水印
                *   白盒水印
                    *   每个客户端生成一个随机秘密矩阵以及一个批量归一化层的位置，嵌入消息
                    *   损失：原始消息和重建消息之间的类似铰链的损失
                *   黑盒水印
                    *   每个客户端在本地数据训练的小型CNN中使用投影梯度下降技术生成触发集
                    *   损失：和主任务的损失相同，但使用触发集作为输入
        *   FedTracker
            *   Shao S, et al. “Fedtracker:Furnishing ownership verification and traceability for federated learning model", arxiv, 2022
            *   假设
                *   服务器是一个可信方，不能访问与原始任务相关的数据
                *   客户端可能是恶意的，也可能是诚实的。恶意客户端可以复制和分发模型，但需要遵循训练过程以最大限度提高全局准确率
            *   允许服务器嵌入全局黑盒水印，也可以嵌入特定于每个客户端的白盒水印
                *   全局黑盒水印
                    *   使用WAFFLEPattern方法生成触发集
                    *   聚合之后嵌入
                *   白盒水印
                    *   服务器为每个客户端生成一个随机秘密矩阵和指纹
                    *   损失：原始消息和重构消息之间类似铰链的损失
        *   Liu
            *   Liu X, et al.“Secure federated learing model verification: A client-side backdoor triggered watermarking scheme",SMC,2021
            *   客户端黑盒水印方案
                *   假设
                    *   服务器是不可信的
                    *   客户端也可能是恶意的
                    *   验证过程中，一个完全值得信赖的第三方被招募为仲裁者
                    *   引入比例因子避免特定客户端在每一轮被选中
                        *   客户端发送其乘以λ的模型权重
                            *   近似于每次迭代都选择该客户端，并且水印更容易嵌入
                *   触发集
                    *   由发起者创建具有给定标签的高斯噪声图像组成的触发集
        *   FedRight
            *   Chen J, et al. “Fedright: An effective model copyright protection for federated learning", Computers & Security, 2023
            *   模型指纹（白盒）
                *   假设
                    *   服务器是可信且诚实的
                    *   客户端可能不可信
                *   方法
                    *   服务器从一组输入（关键样本）中生成对抗性示例
                    *   服务器提取每个预测的概率分布，并将其反馈至具有关键样本目标的检测器
                    *   验证过程中，由检测器预测对应的模型是否是好的
        *   FedCIP
            *   Liang J, Wang R.“FedCIP: Federated Client Intellectual Property Protection with Traitor Tracking", arxiv, 2023
            *   白盒水印方案
                *   假设
                    *   服务器是诚实但好奇的，不能直接修改模型的参数
                    *   客户端可能是恶意的，可以发起模型窃取行为
                    *   触发集不依赖于原始数据
                *   方法
                    *   对于每个客户端，水印在一个周期期间是唯一的
                        *   如果该轮是循环的第一次迭代，则用新的水印替换先前的水印
                        *   否则进行小的更新增强水印
                    *   Federated watermark进行水印验证
                        *   给定周期的所有贡献者的水印的级联
                        *   如客户端泄露模型，可以通过计算具有高水印检测率的参与者与泄露模型的交集来识别
        *   Yang
            *   Yang W, et al.“Watermarking in Secure FederatedLearming: A Verification Framework Based on Client-Side Backdooring", arxiv,2022
            *   黑盒水印方案
                *   方法
                    *   使用基于置换的密钥和基于噪声的模式构建图像
                        *   可以抵抗歧义攻击，无论是试图暴力破解密钥还是生成新的触发集
        *   Merkle Sign
            *   Li F Q, et al, “Towards practical watermark for deep neural networks in federated learning”, arxiv, 2021
            *   Li F Q, et al.“Merkle-Sign: Watermarking Framework for Deep Neural Networks in Federated Learning”, arxiv, 2021
            *   假设
                *   服务器是可信的
                *   客户端是诚实但好奇的
            *   使用Merkle树的公共验证协议&#x20;
                *   服务器在每一轮使用嵌入函数将两条身份信息（密钥）插入全局模型中，一条标识服务器，另一条标识接收模型的客户端
                *   服务器上传密钥元组和由水印嵌入函数生成的验证函数元组，转化为具有事件记录的merkle树
                *   最后一轮，服务器将客户端生成的所有密钥嵌入全局模型并更新merkle树
            *   黑盒水印方案
                *   依赖于每个客户端的自动编码器
            *   白盒水印
            *   防御
                *   歧义攻击
                    *   使用授权的时间服务器或分散的共识协议进行授权
                *   破坏攻击
                    *   应用多个水印
                *   叛徒跟踪
                    *   为每个客户端嵌入唯一的水印
            *   缺点
                *   缺少训练终止后识别叛徒客户端的协议，因为模型的水印同时来自所有客户端的信息
        *   FedZKP
            *   Yang W, et al.“FedZKP: Federated Model Ownership Verification with Zero-knowledge Proof, arxiv, 2023
            *   假设
                *   客户端是可信的
                *   服务器是诚实但好奇的
            *   基于零知识证明的验证协议
                *   用户需要与可信机构共享其公钥验证模型所有权
                    *   存在拦截密钥的攻击者
                    *   使用零知识证明协议解决，确保只有拥有水印中公钥相关联的私钥的个人才能证明
            *   白盒水印
                *   每个客户端配备公钥和私钥
                *   客户端公钥的散列嵌入到模型中
        *   子主题
    *   讨论
        *   基于触发集的服务器端水印算法
            *   大多数方法通过在损失函数中添加正则化项，让模型在触发集上过拟合
            *   大多数黑盒水印算法基于主任务数据集构建触发集
            *   服务器没有自己的数据集，因此需要使用不相关或者基于噪声的输入（例如WafflePattern），或是从客户端提供的自动编码器生成触发集（例如Merkle Sign）
                *   分别学习两项任务可能会对Fedelity产生负面影响
                    *   FedTracker使用持续学习和全局梯度记忆来防止先前学习的干扰
                *   容易遭到Evasion attack
        *   聚合函数
            *   常见的聚合函数
                *   FedAvg
                    *   在客户端执行多个epoch后，参数的平均
                    *   每个客户端的权重矩阵乘以一个缩放因子
                        *   子主题
                            *   n为所有客户端数据集样本的数量
                        *   子主题
            *   水印方法应该独立于聚合函数
            *   由于客户端的水印技术对嵌入消息和触发集敏感，因此他们保持远离彼此的更新
                *   所使用安全聚合技术，一部分的更新可能会因此被拒绝
            *   数据异构的情况，目前缺乏相关工作解决
        *   客户端选择
            *   考虑不同端嵌入水印时客户端选择的影响
        *   跨设备设置
            *   大部分方法处理的是少量客户端的情况
            *   黑盒水印，该问题来自低计算能力
            *   白盒水印，该问题来自嵌入容量
        *   差分隐私和同态加密
            *   差分隐私
                *   服务器和客户端之间（或直接在客户端之间）共享模型或梯度更新，存在对潜在攻击的担忧，例如成员推断
                *   常见DP方法
                    *   将高斯随机噪声引入到发送到聚合器的梯度中，从而添加额外的隐私保护层
            *   同态加密
                *   客户端可以使用其公钥保护其模型更新，在将数据发送到服务器之前对其进行加密。服务器在加密空间中执行模型聚合，客户端可以在收到聚合的全局模型后使用其私钥对其进行解密。
                *   适合S1场景（客户端添加水印），不适用于S1（服务器端嵌入水印）
        *   非CS架构的联邦学习水印
            *   U型架构服务器端执行黑盒水印较为困难，其无法在模型上使用输入和标签
        *   来自客户端和服务器的攻击
            *   服务器可以控制所选择的参与者或如何聚合模型参数。它有时也清楚地了解客户在每一轮的参数。然而，它没有数据，也无法完全控制客户是否严格遵守培训程序。
            *   客户端有自己的私有数据集，他们可以发送他们想要的更新。然而，他们无法控制服务器级别的更新。如果服务器想要避免客户端的子集对模型进行水印，它可以使用拜占庭攻击检测方法。

[1]: https://arxiv.org/abs/2308.03573