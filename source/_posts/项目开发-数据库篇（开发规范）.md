---
title: 项目开发-数据库篇（开发规范）
date: 2023-04-07 15:41:56
categories: technique
tags: [coding]
urlname: 15
---

数据库开发规范

### 数据库开发规范

- **SQL语句**
  - 避免使用双%号和like，搜索严禁左模糊或者全模糊
  - 禁止使用不含字段列表的insert语句
    
    如：insert into values (‘a’,’b’,’c’)；应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’)
  
  - insert into…values(XX),(XX),(XX)…。XX的值不要超过5000个。值过多虽然上线很很快，但会引起主从同步延迟。

  - 禁止使用order by rand（）进行随机排序

  - 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。

  - order by、group by、distinct这些SQL尽量利用索引直接检索出排序好的数据。如where a=1 order by可以利用key(a,b)

  - 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集建议保持在1000行以内，否则SQL会很慢。

  - 禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上order by PK

  - 禁用insert into …on duplicate key update…在高并发环境下

  - 尽量避免in操作，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内

  - 禁止where从句中对列进行函数转换和计算
    
    如：where date（createtime）=‘20160901’ 会无法使用createtime列上索引。改成 where createtime>='20160901' and createtime <'20160902'）

  - 尽量避免使用子查询，可以把子查询优化为join操作
    
    通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。

    子查询性能差的原因：
    1. 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响；
    2. 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；
    3. 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。

  - 避免使用select * 查询
    
    消耗更多的cpu和io及网络带宽资源，无法使用覆盖索引，可减少表结构变更带来的影响（表字段一旦更新，但model层没有来得及更新的话，系统会报错）
  - 避免数据类型的隐式转换
    
    隐式转换会导致索引失效。如：select name,phone from customer where phone = 111

  - 对应同一列进行or判断时，使用in代替or
    
    in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引

  - 在明显不会有重复值时使用UNION ALL而不是UNION，并且UNION子句个数限制在5个以内
    
    UNION会把两个结果集的所有数据放到临时表中后再进行去重操作；UNION ALL不会再对结果集进行去重操作
  - 拆分复杂的大SQL为多个小SQL
    
    大SQL逻辑上比较复杂，需要占用大量CPU进行计算的SQL；MySQL中，一个SQL只能使用一个CPU进行计算；SQL拆分后可以通过并行执行来提高处理效率
  - 避免使用JOIN关联太多的表
    对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。
    
    在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。
    
    如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。
    
    同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过3个。

  - 在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。

  - 事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。

  - 事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。

  - 事务里更新语句尽量基于主键或unique key，如update … where id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。

  - 尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。

  - 事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步终端。

  - 除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。

  - 生产环境禁止使用hint，如sql_no_cache，force index，ignore key，straight join等。因为hint是用来强制SQL按照某个执行计划来执行，但随着数据量变化无法保证自己当初的预判是正确的，因此要相信MySQL优化器。

  - 减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b)。

  - 分页查询，当limit起点较高时，可先用过滤条件进行过滤。如select a,b,c from t1 limit 10000,20;优化为: select a,b,c from t1 where id>10000 limit 20;

  - 禁止在业务的更新类SQL语句中使用join，比如update t1 join t2…。

  - 对于有auto_increment属性字段的表的插入操作，并发需要控制在200以内。

  - 



### 数据库操作规范

- **数据库操作**
  - 禁止使用存储过程、视图、触发器、event
  - 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行。因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。
  - 减少同数据库的交互次数
  
    数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率
  - 超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作

    主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况。
    
    binlog日志为row格式时会产生大量的日志。大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。
  - 对于大表使用pt-online-schema-change修改表结构
    
    避免大表修改产生的主从延迟；避免在对表字段进行修改时进行锁表

    对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。
    
    pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。
    
    把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。
  - 禁止为程序使用的账号赋予super权限
    
    当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。
  - 对于程序连接数据库账号，遵循权限最小原则
    
    程序使用数据库账号只能在一个DB下使用，不准跨库，程序使用的账号原则上不准有drop权限。
  - 程序连接不同的数据库使用不同的账号，禁止跨库查询
    
    为数据库迁移和分库分表留出余地

    降低业务耦合度
    
    避免权限过大而产生的安全风险
  