---
title: 代码练习 | 数组（长度最小的子数组）
tags: [leetcode]
date: 2024-05-23 20:25:06
categories: code
urlname: 39
mathjax: true
---


## 长度最小的子数组


### 209. 长度最小的子数组

leetcode链接：[长度最小的子数组][1]

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 

提示：

1 <= target <= $10^9$
1 <= nums.length <= $10^5$
1 <= nums[i] <= $10^5$


思路：需要找到其总和大于等于 target 的长度**最小**的 连续子数组，可以考虑双指针滑动，一个指针指向子数组起始位置，一个指针用于确定子数组结束位置。当子数组满足条件时，改变子数组起始位置（因为起始指针向右滑动后子数组也可能满足条件，起始指针向右滑动）。在遍历的过程中无法确定当前子数组长度是不是最小，可以设用一个额外的变量，初始值赋予一个大于原数组长度的值，当遇到满足条件的子数组时，对比该变量的值与子数组长度，保留较小值。

```
func minSubArrayLen(target int, nums []int) int {
    minLength := len(nums) + 1
    i := 0
    sum := 0
    j := 0
    for (j < len(nums)){
        sum += nums[j]
        for sum >= target{
            setLen := j - i + 1
            if setLen < minLength{
                minLength = setLen
            }
            
            sum -= nums[i] 
            i += 1
        }
        j += 1
    }
    if minLength > len(nums){
        return 0
    }
    return minLength
}

```


### 904. 水果成篮

leetcode链接：[水果成篮][2]

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。

示例 1：

输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。


示例 2：

输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。


示例 3：

输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。


示例 4：

输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。

提示：

1 <= fruits.length <= $10^5$
0 <= fruits[i] < fruits.length


思路：返回你可以收集的水果的 最大 数目即返回满足条件的子数组大小。此时相当于有两个目标值，且目标值可能发生变化。可以使用两个滑动指针，一个指向子数组的起始位置，一个指向子数组的结束位置。从数组开头滑动指针，第一个目标值为数组的第一个元素，遍历后续元素，若和目标值1不同，则赋值给目标值2，两个目标值确定后，第二个指针继续滑动，确定子数组结束位置。每次找到数组结束位置，需要寻找下一个满足条件的子数组，此时移动第一个指针的位置，使得两个指针内的子数组元素值与结束指针指向的值相同。


```
func totalFruit(fruits []int) int {
    maxNum := 0
    firstFruit := fruits[0]
    secondFruit := -1
    sum := 0
    i := 0
    for j := 0 ; j < len(fruits); j++{
        if fruits[j] != firstFruit && secondFruit == -1{
            secondFruit = fruits[j]
        }
        if fruits[j] == firstFruit || fruits[j] == secondFruit{
            sum += 1
        }
        if fruits[j] != firstFruit && fruits[j] != secondFruit{
            if sum > maxNum{
                maxNum = sum
            }
            i = findIndex(fruits[j-1], fruits[:j])
            sum = j - i + 1
            firstFruit = fruits[j-1]
            secondFruit = fruits[j]
        }
        
    }
    if sum > maxNum{
        maxNum = sum
    }
    return maxNum
}

func findIndex(num int, nums []int) int{
    for j := len(nums) -1 ; j >= 0; j--{
        if nums[j] != num{
            return j + 1
        }
    }
    return 0
}

```



### 76. 最小覆盖子串

leetcode链接：[最小覆盖子串][3]


给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
示例 2：

输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
 

提示：

m == s.length
n == t.length
1 <= m, n <= $10^5$
s 和 t 由英文字母组成



思路：首先可以找包含t字符串字符中的所有元素的子数组，这时不一定是最小的，因此需要从子数组的结束位置向前滑动，重新确认子数组起始位置。


```
func minWindow(s string, t string) string {
    deDuT := make(map[string]int)
    
}


```

[1]: https://leetcode.cn/problems/minimum-size-subarray-sum/description/
[2]: https://leetcode.cn/problems/fruit-into-baskets/description/
[3]: https://leetcode.cn/problems/minimum-window-substring/description/